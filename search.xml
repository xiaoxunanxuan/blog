<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mybatis</title>
    <url>/2024/10/09/Mybatis/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>MyBatis是一款优秀的持久层的框架，用于简化JDBC的开发（JDBC是在java语言使用SQL语言,来调用，修改，添加数据库数据的)</p>
<p>持久层：负责将数据保存到数据库的那一层代码</p>
<p>javaEE三层框架：表现层，业务层，持久层</p>
<p>框架：就是一个半成品的软件，是一套可重用，通用的，软件基础代码模型</p>
<p>在框架的基础上构建软件编写更加高效，规范，可扩张</p>
<h2 id="MyBatis快速入门"><a href="#MyBatis快速入门" class="headerlink" title="MyBatis快速入门"></a>MyBatis快速入门</h2><p>查询user表中所有数据</p>
<ol>
<li>创建user表，添加数据</li>
<li>创建模块，导入坐标</li>
<li>编写MyBatis核心配置文件 —&gt;替换连接信息，解决硬编码问题</li>
<li>编写SQL映射文件 —&gt;统一管理sql语句，解决硬编码问题</li>
<li>编码<ol>
<li>定义POJO类</li>
<li>加载核心配置文件，获取SqlSessionFactory对象</li>
<li>获取SqlSession对象，执行SQL语句</li>
<li>释放资源</li>
</ol>
</li>
</ol>
<p>ait+鼠标左键可以整列编辑</p>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">22</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">22</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;!--mybatis依赖 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">3.5</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--mysql驱动 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">8.0</span><span class="number">.33</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--junit单元测试 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">4.13</span>&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.7</span><span class="number">.20</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--添加logback-classic依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--添加logback-core依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;mysql-repo&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repo.mysql.com/&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在pom-xml中加入"><a href="#在pom-xml中加入" class="headerlink" title="在pom.xml中加入"></a>在pom.xml中加入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;!--mybatis依赖 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">3.5</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--mysql驱动 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">8.0</span><span class="number">.33</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--junit单元测试 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">4.13</span>&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.7</span><span class="number">.20</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--添加logback-classic依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--添加logback-core依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;mysql-repo&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repo.mysql.com/&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br></pre></td></tr></table></figure>

<p>在main的resources中加入logback.xml,mybatis-config.xml和UserMapper.xml</p>
<h3 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--    console表示当前日志信息是可以输出到控制台的--&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;Console&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;【%level】  %cyan(【%thread】) %boldGreen(%logger&#123;<span class="number">15</span>&#125;) - %msg %n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;logger name=<span class="string">&quot;com.Carter_x&quot;</span> level=<span class="string">&quot;DEBUG&quot;</span> additivity=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;Console&quot;</span>/&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">      &lt;typeAliases&gt;</span><br><span class="line">        &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.pugo&quot;</span>/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">    <span class="comment">//起别名之后涉及到USer的实体类是可以直接写user并且不用区分大小写</span></span><br><span class="line">     &lt;!--</span><br><span class="line">    environments:配置数据库连接环境信息的，可以配置多个environment，通过<span class="keyword">default</span>属性切换</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;environments <span class="keyword">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">            &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">&quot;POOLED&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/blog&quot;</span>/&gt;</span><br><span class="line">                <span class="comment">//数据库，端口，</span></span><br><span class="line">                &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">                <span class="comment">//账户名</span></span><br><span class="line">                &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;ROOT&quot;</span>/&gt;</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">         &lt;environment id=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">            &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">&quot;POOLED&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/blog&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;ROOT&quot;</span>/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--包扫描的方式加载映射文件 --&gt;</span><br><span class="line">        &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.mapper&quot;</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="UserMapper-xml"><a href="#UserMapper-xml" class="headerlink" title="UserMapper.xml"></a>UserMapper.xml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    namepace:名称空间</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;selectAll&quot;</span> resultType=<span class="string">&quot;com.ruming.USer&quot;</span>&gt;</span><br><span class="line">        select * from login;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>



<h2 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h2><ol>
<li>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</li>
<li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li>
<li>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id并保持参数类型和返回值类型一致</li>
<li>编码：<ol>
<li>通过SqlSession的getMapper方法获取Mapper接口的代理对象</li>
<li>调用对应方法完成sql的执行</li>
</ol>
</li>
</ol>
<p>细节：如果Mapper接口名称和SQL映射文件名称相同，并且在同一目录下，则可使用包扫描的方式简化sql映射文件的加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 加载mysql的核心配置文件，获取SqlSessionFactory</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">       <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">       <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">       <span class="comment">//2. 获取sqlSession对象，用它库执行sql</span></span><br><span class="line">       <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">       <span class="comment">//3. 执行sql</span></span><br><span class="line">       <span class="comment">//List&lt;USer&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;);</span></span><br><span class="line">       <span class="comment">//获取BrandMapper代理对象</span></span><br><span class="line">       <span class="type">BrandMapper</span> <span class="variable">brandmapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">       List&lt;Brand&gt; brands = brandmapper.selectAll();</span><br><span class="line">       System.out.println(brands);</span><br><span class="line">       sqlSession.close();</span><br></pre></td></tr></table></figure>

<h2 id="MyBatis核心配置文件"><a href="#MyBatis核心配置文件" class="headerlink" title="MyBatis核心配置文件"></a>MyBatis核心配置文件</h2><h3 id="顶层结构"><a href="#顶层结构" class="headerlink" title="顶层结构"></a>顶层结构</h3><p>configuration(配置)</p>
<ul>
<li><p>Properties(属性)</p>
</li>
<li><p>settings(设置)</p>
</li>
<li><p>typeAliases(类型别名)</p>
</li>
<li><p>typeHandlers(类型处理器)</p>
</li>
<li><p>objectFactory(对象工厂)</p>
</li>
<li><p>plugins(插件)</p>
</li>
<li><p>environments(环境配置)</p>
<p>environment(环境变量)</p>
<ul>
<li>transactionManager(事务管理器)</li>
<li>dataSource(数据源)</li>
</ul>
</li>
<li><p>darabaseldProvider(数据库厂商标识)</p>
</li>
<li><p>mapper(映射器)</p>
</li>
</ul>
<p>配置便签时，要注意遵守前后顺序</p>
<h3 id="mybatis-config-xml-1"><a href="#mybatis-config-xml-1" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">      &lt;typeAliases&gt;</span><br><span class="line">        &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.pugo&quot;</span>/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">    <span class="comment">//起别名之后涉及到USer的实体类是可以直接写user并且不用区分大小写</span></span><br><span class="line">     &lt;!--</span><br><span class="line">    environments:配置数据库连接环境信息的，可以配置多个environment，通过<span class="keyword">default</span>属性切换</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;environments <span class="keyword">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">            &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">&quot;POOLED&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo&quot;</span>/&gt;</span><br><span class="line">                <span class="comment">//数据库，端口，</span></span><br><span class="line">                &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">                <span class="comment">//账户名</span></span><br><span class="line">                &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;ROOT&quot;</span>/&gt;</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">         &lt;environment id=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">            &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">&quot;POOLED&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/blog&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;ROOT&quot;</span>/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--包扫描的方式加载映射文件 --&gt;</span><br><span class="line">        &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.mapper&quot;</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>



<h2 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h2><p>用一个案例来演示</p>
<p>要完成的功能列表清单</p>
<ol>
<li><p>查询</p>
<p>查询所有数据</p>
<p>查看情况</p>
<p>条件查询</p>
</li>
<li><p>添加</p>
</li>
<li><p>修改</p>
<p>修改全部字段</p>
<p>修改动态字段</p>
</li>
<li><p>删除</p>
<p>删除一个</p>
<p>批量删除</p>
</li>
</ol>
<h3 id="查看所有数据"><a href="#查看所有数据" class="headerlink" title="查看所有数据"></a>查看所有数据</h3><h4 id="数据库名和实体类名不一样"><a href="#数据库名和实体类名不一样" class="headerlink" title="数据库名和实体类名不一样"></a>数据库名和实体类名不一样</h4><p>数据库表的字段名称 和 实体类的属性名称不一样，则不能自动封装数据</p>
<ul>
<li><p>起别名：对不一样的列名起别名和实体类的属性名一样</p>
<p>select id,brand_name as brandName,company_name as companyName,order from tb_brand;</p>
<p>缺点：每次查询都要定义一次别名</p>
<p>可以使用sql片段</p>
<p><code>&lt;sql id=&quot;sqlbrand&quot;&gt;</code></p>
</li>
<li><p>resultMap:定义<code>&lt;resultMap&gt;</code>标签，在<code>&lt;select&gt;</code>标签中，使用resultMap属性替换resultType属性</p>
<p>id：唯一标识</p>
<p>type:映射的类型，支持别名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;brandResultMap&quot;</span> type=<span class="string">&quot;brand&quot;</span>&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;brand_name&quot;</span> property=<span class="string">&quot;brandName&quot;</span>/&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;company_name&quot;</span> property=<span class="string">&quot;companyName&quot;</span>/&gt;</span><br><span class="line">    &lt;resultMap&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;selectAll&quot;</span> rseultMap=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>resultMap的标签内部：</p>
<p>id:完成主键字段的映射</p>
<ul>
<li>column:表的列名</li>
<li>property：实体类的属性名</li>
</ul>
<p>result：完成一般字段的映射</p>
<ul>
<li>column:表的列名</li>
<li>property：实体类的属性名</li>
</ul>
</li>
</ul>
<p>编写接口方法：Mapper接口</p>
<ul>
<li>参数：无</li>
<li>结果：List<code>&lt;Brand&gt;</code></li>
</ul>
<p>编写SQL语句：SQL映射文件</p>
<p>执行方法，测试</p>
<p>BrandMapper.java，BrandMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mapper;</span><br><span class="line"><span class="keyword">import</span> com.pugo.Brand;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BrandMapper.xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>       <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    namepace:名称空间</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.mapper.BrandMapper&quot;</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;selectAll&quot;</span> resultType=<span class="string">&quot;Brand&quot;</span>&gt;</span><br><span class="line">    select *</span><br><span class="line">    from tb_brand;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>MybatisTest.java,测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 加载mysql的核心配置文件，获取SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">//2. 获取sqlSession对象，用它库执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        <span class="comment">//List&lt;USer&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;);</span></span><br><span class="line">        <span class="comment">//获取BrandMapper代理对象</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">brandmapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">        List&lt;Brand&gt; brands = brandmapper.selectAll();</span><br><span class="line">        System.out.println(brands);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看详情"><a href="#查看详情" class="headerlink" title="查看详情"></a>查看详情</h3><ol>
<li><p>编写接口方法：Mapper接口</p>
<p>参数：id</p>
<p>结果：Brand</p>
</li>
<li><p>编写SQL语句：SQl映射文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectByld&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultType=<span class="string">&quot;brand&quot;</span>&gt;</span><br><span class="line">    select * from tb_brand where id=#&#123;id&#125;;&lt;/select&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行方法，测试</p>
</li>
</ol>
<p>参数占位符：</p>
<ol>
<li>#{}：会将其替换为？，为了防止SQL注入</li>
<li>${}:拼sql。会有SQL注入问题</li>
<li>使用时机：<ul>
<li>参数传递的时候：#{}</li>
<li>表名或者列名不固定的情况下：${}会存在SQL注入问题</li>
</ul>
</li>
</ol>
<p>参数类型：parameterType:可以省略</p>
<p>特殊字符处理：</p>
<ol>
<li>转义字符：&lt;（小于号）的转义字符 &amp;it</li>
<li>CDATA区:<code>&lt;![CDATA[  &lt;  ]]&gt;</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    List&lt;Brand&gt; <span class="title function_">selectByid</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">&lt;--      --&gt;</span><br><span class="line">    </span><br><span class="line">       &lt;select id=<span class="string">&quot;selectByid&quot;</span> resultType=<span class="string">&quot;com.pugo.Brand&quot;</span>&gt;</span><br><span class="line">        select *</span><br><span class="line">        from tb_brand where id=#&#123;id&#125;;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        List&lt;Brand&gt; brands = brandmapper.selectByid(id);</span><br></pre></td></tr></table></figure>



<h3 id="查询-多条件查询"><a href="#查询-多条件查询" class="headerlink" title="查询-多条件查询"></a>查询-多条件查询</h3><ol>
<li><p>编写接口方法：Mapper接口</p>
<p>参数：所有查询条件</p>
<p>结果：List<code>&lt;Brand&gt;</code></p>
</li>
<li><p>编写SQL语句：SQL映射文件</p>
</li>
<li><p>执行方法，测试</p>
</li>
</ol>
<p>参数接收：</p>
<ol>
<li><p>散装参数：如果方法中有多个参数，需要使用@Param(“SQL参数占位符名称”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status,<span class="meta">@Param(&quot;companyName&quot;)</span> String companyName)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象参数：对象的属性名要和参数的名称对应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br><span class="line"><span class="comment">//Brand类的属性名要和需要的参数名对应，属性的值就是参数的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectByCondition&quot;</span> resultType=<span class="string">&quot;com.pugo.Brand&quot;</span>&gt;</span><br><span class="line">       select *</span><br><span class="line">       from tb_brand where id=#&#123;id&#125; and company_name like #&#123;company_name&#125; and brand_name like #&#123;brand_name&#125;;</span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        String companyName=<span class="string">&quot;三只松鼠&quot;</span>;</span><br><span class="line">        String brandName=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        companyName = <span class="string">&quot;%&quot;</span>+companyName+<span class="string">&quot;%&quot;</span>;</span><br><span class="line">        brandName = <span class="string">&quot;%&quot;</span>+brandName+<span class="string">&quot;%&quot;</span>;</span><br><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">        brand.setId(start);</span><br><span class="line">        brand.setBrand_name(brandName);</span><br><span class="line">        brand.setCompany_name(companyName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;Brand&gt; brands = brandmapper.selectByCondition(brand);</span><br></pre></td></tr></table></figure>
</li>
<li><p>map集合参数：其中的键要和参数名对应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br><span class="line"><span class="comment">//Map中的键名要和参数名称对应，键值就是参数值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map= <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,id);</span><br><span class="line">map.put(<span class="string">&quot;companyName&quot;</span>,compantName);</span><br><span class="line">map.put(<span class="string">&quot;brandName&quot;</span>,brandName);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="查询-多条件-动态条件查询动态SQL"><a href="#查询-多条件-动态条件查询动态SQL" class="headerlink" title="查询-多条件-动态条件查询动态SQL"></a>查询-多条件-动态条件查询动态SQL</h3><p>动态SQL</p>
<p>if:用于判断参数是否有值，使用test属性进行条件判断</p>
<p>存在的问题：第一个条件不需要逻辑运算符</p>
<p>解决方法：</p>
<ol>
<li><p>使用恒等式让所有条件的格式都一样</p>
<p>在where后面加上1&#x3D;1，所有的都加上and</p>
</li>
<li><p><code>&lt;where&gt;</code>标签替换where关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;where&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">&quot;compantName !=null and companyName !=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">and company_name like #&#123;companyName&#125;&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">&quot;brandName!=null&quot;</span>&gt;</span><br><span class="line">and brandName like #&#123;brandName&#125;&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/where&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从多个条件中选一个</p>
<p>choose(when,otherwise):选择，类似java中的switch语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from tb_brand</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;choose&gt;&lt;!-- 类似与<span class="keyword">switch</span>--&gt;</span><br><span class="line">&lt;when test=<span class="string">&quot;status!=null&quot;</span>&gt;&lt;!-- 类似于<span class="keyword">case</span>--&gt;</span><br><span class="line">status=#&#123;status&#125;</span><br><span class="line">&lt;/when&gt;</span><br><span class="line">&lt;otherwise&gt;&lt;!--类似于<span class="keyword">default</span>--&gt;</span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line">&lt;/otherwise&gt;</span><br><span class="line">&lt;/choose&gt;</span><br><span class="line">&lt;/where&gt;</span><br></pre></td></tr></table></figure>



<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>编写接口方法：Mapper接口  void add(Brand brand);</p>
<ul>
<li>参数：除了id之外的所有数据</li>
<li>结果：void</li>
</ul>
<p>编写SQL语句：SQL映射文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;add&quot;</span>&gt;</span><br><span class="line">insert into <span class="title function_">tb_brand</span><span class="params">(brand_name,company_name,ordered,description,status)</span> values(#&#123;brandName&#125;,#&#123;companyName&#125;,#&#123;ordered&#125;,#&#123;description&#125;,#&#123;status&#125;);</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>执行方法，测试</p>
<ul>
<li><p>MyBatis事务</p>
<p>openSession():默认开启事务，进行增删改操作后需要使用sqlSession.commit()去手动提交事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">//2. 获取sqlSession对象，用它库执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//执行sql</span></span><br><span class="line">       <span class="comment">//获取BrandMapper代理对象</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">brandmapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line">brandmapper.add(brand);</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>



<p>openSession(true):可以设置为自动提交事务(关闭事务)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 获取sqlSession对象，用它库执行sql</span></span><br><span class="line">  <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>添加的主键返回，让主键能在添加的类的没有设但主键自增的值能实时返回，在添加后就能通过实体类使用。<code>&lt;insert useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;insert useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyProperty=<span class="string">&quot;id&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//执行方法</span></span><br><span class="line">brandmapper.add(brand);</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line">Integer id=brand.getid();</span><br><span class="line">System.out.println(id);</span><br><span class="line"><span class="comment">//id能打印出来就是主键自增的那个值</span></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>编写接口方法：Mapper接口 void update(Brand brand)</p>
<ul>
<li>参数：所有数据</li>
<li>结果：void</li>
</ul>
<p>编写SQL语句：SQL映射文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;update&quot;</span>&gt;</span><br><span class="line">update tb_brand set brand_name=#&#123;brandName&#125;,company_name=#&#123;companyName&#125;,orderd=#&#123;orderd&#125;,description=#&#123;description&#125;,status=#&#123;status&#125;</span><br><span class="line"><span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<p>执行方法。测试</p>
<p>动态修改</p>
<p><code>&lt;set&gt;,&lt;if&gt;</code>标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;updateBrand&quot;</span>&gt;</span><br><span class="line">       update tb_brand</span><br><span class="line">       &lt;set&gt;</span><br><span class="line">           &lt;<span class="keyword">if</span> test=<span class="string">&quot;brand_name!=null and brand_name!=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">               brand_name=#&#123;brand_name&#125;,</span><br><span class="line">           &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">           &lt;<span class="keyword">if</span> test=<span class="string">&quot;company_name!=null and company_name!=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">               company_name=#&#123;company_name&#125;,</span><br><span class="line">           &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">           &lt;<span class="keyword">if</span> test=<span class="string">&quot;orderd!=null&quot;</span>&gt;</span><br><span class="line">               orderd=#&#123;orderd&#125;,</span><br><span class="line">           &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">           &lt;<span class="keyword">if</span> test=<span class="string">&quot;description!=null and description!=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">               description=#&#123;description&#125;,</span><br><span class="line">           &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">           &lt;<span class="keyword">if</span> test=<span class="string">&quot;status!=null and status!=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">               status=#&#123;status&#125;</span><br><span class="line">           &lt;/<span class="keyword">if</span>&gt;    </span><br><span class="line">       &lt;/set&gt;</span><br><span class="line">       <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>sqlw文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;delete id=<span class="string">&quot;deleteByid&quot;</span>&gt;</span><br><span class="line">delete from tb_brand where id=#&#123;id&#125;;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<p>批量删除</p>
<p>接收一个id数组，循环遍历删除</p>
<p>mybatis会将数组参数，封装为一个map集合</p>
<ul>
<li>默认：array&#x3D;数组</li>
<li>使用@Param注解改变map集合的默认名称（@Param(ids))在BrandMApper方法中的参数ids前放上注解</li>
</ul>
<p><code>&lt;foreach&gt;</code>:循环遍历便签</p>
<p>collection:循环的对象，item:循环时的名称</p>
<p>separator:用什么分隔符，比如 ，，open：开始添加什么，close:结束时添加什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;delete id=<span class="string">&quot;deleteByid&quot;</span>&gt;</span><br><span class="line">delete from tb_brand where id</span><br><span class="line">in</span><br><span class="line">&lt;foreach collection=<span class="string">&quot;ids&quot;</span> item=<span class="string">&quot;id&quot;</span> separator=<span class="string">&quot;,&quot;</span> open=<span class="string">&quot;(&quot;</span> close=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">#&#123;id&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>MyBatis参数封装：</p>
<ol>
<li><p>POJO类型（实体类）：直接使用，属性名和参数占位符名称一致</p>
</li>
<li><p>Map集合：直接使用，键名和参数占位符名称一致</p>
</li>
<li><p>Collection:封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名</p>
<p>map.put(“arg0”,collection集合)；</p>
<p>map.put(“collection”,collection集合)</p>
</li>
<li><p>List:封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名</p>
<p>map.put(“arg0”,List集合)；</p>
<p>map.put(“collection”,List集合)</p>
<p>map.put(“List”,List集合)</p>
</li>
<li><p>Array:封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名</p>
<p>map.put(“arg0”,Array集合)；</p>
<p>map.put(“array”,Array集合)</p>
</li>
<li><p>其他类型：直接使用</p>
</li>
</ol>
<p>多个参数：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名</p>
<p>map.put(“arg0”,参数1)；</p>
<p>map.put(“param1”,参数2)；</p>
<p>map.put(“param2”,参数3)；</p>
<p>map.put(“arg1”,参数4)；</p>
<p>----------------@Param(“username”)</p>
<p>map.put(“username”,参数1)；</p>
<p>map.put(“param1”,参数2)；</p>
<p>map.put(“param2”,参数3)；</p>
<p>map.put(“arg1”,参数4)；</p>
<p>使用@Param注解</p>
<h2 id="注解完成增删改查"><a href="#注解完成增删改查" class="headerlink" title="注解完成增删改查"></a>注解完成增删改查</h2><p>注解完成简单功能</p>
<p>配置文件完成复杂功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from tb_brand where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Brand <span class="title function_">selectByid</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<p>在mapper上的方法上面写这个注解</p>
<ul>
<li>查询：@Select</li>
<li>添加：@Insert</li>
<li>修改：@Update</li>
<li>删除：@Delete</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/09/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java的基础知识</title>
    <url>/2024/09/13/java%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>1：使用的是java11.0。java.8公司使用的最多的</p>
<p>java跨windows等操作平台操作。java有jam（翻译）java虚拟机从而进行跨平台操作。</p>
<p>JRE：java的运行环境包含JVM要运行java安装JRE就可以了</p>
<p>JDK：包含JRE和开发环境</p>
<p>bin：JDK的各种工具命令。java和javac就在。</p>
<p>conf：JDK的相关配置文件</p>
<p>jmods：JDK的各种模块</p>
<p>include：一些头文件</p>
<p>legal：模块的授权文档</p>
<p>lib：补充JAR包。</p>
<p>2：DOS命令，运行cmd</p>
<p>盘符：回车（切换盘）。dir（查看现路径下的内容。cd目录（进入目录）。cd..（退回上级目录）。cd目录\目录。cd\ 。cls(清屏)。exit(退出)。</p>
<h2 id="这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。"><a href="#这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。" class="headerlink" title="这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。"></a>这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。</h2><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h5 id="1注释："><a href="#1注释：" class="headerlink" title="1注释："></a>1注释：</h5><p>说明。单行注释&#x2F;&#x2F;   .多行注释&#x2F;*  <em>&#x2F;.文本注释&#x2F;</em>*    *&#x2F;.</p>
<p>java中最基本的组成单位是类。类的定义格式： public class 类名{}。mian方法是入口</p>
<h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>字母全部小写。有特殊颜色标记。</p>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>固定不变的。</p>
<p>字符串，整数，小数，字符，布尔，空(null)</p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>字节B位(比特位)b</p>
<p>byte 1.short 2.int 4(默认).long 8.float 4.double 8(默认).char 2. boolean 1(布尔).</p>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>暂存位置。int a&#x3D;19；a&#x3D;10；</p>
<p>一定要给值。不是默认类型要加L(long)，F(float).</p>
<h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p>由数字，字母，下划线()和美元符()组成</p>
<p>不以数字开头，不是关键字，区分大小写。</p>
<p>小驼峰命名法(方法，变量)：一个单词首字母小写，多个单词的时候第一单词首小写其他首大写</p>
<p>大驼峰命名法(类)：一个单词首字母大写，多个单词的时候每个首字母大写  </p>
<p>类型转换</p>
<p>自动类型转换：表示数据范围小的变成数据表示范围大的 从大到小类型不兼容int k&#x3D;(int)88.8。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h6 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h6><p>+-*&#x2F;% （byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double）</p>
<p>字符加操作：会用字母的ASKNA值（’A’&#x3D;65,’a’&#x3D;97,’0’&#x3D;48)  会自动提升类型</p>
<p>字符串的加操作：将两个拼接，1+99+“王”&#x3D;100王；王+1+99&#x3D;王199；</p>
<h6 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h6><p>在赋值时要转换类型   扩装的赋值预算符隐含强制类型转换</p>
<h6 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h6><p>i++ ；++i； –i；i–；单独使用和参与操作使用；</p>
<h6 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h6><p>值只为为ture或false;</p>
<h6 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h6><p>&amp;：有false则为false（和）全运行；</p>
<p>|：有true则true（或）；</p>
<p>^:同为false,不同为true；</p>
<p>！：相反；</p>
<h6 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h6><p>&amp;&amp;：有false则为false（和）若第一个为false则右边不执行；</p>
<p>||：有true则true（或）若第一个为false则右边不执行；</p>
<h6 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h6><p>a&gt;b?a:b：对为a错为b；</p>
<h6 id="两只老虎"><a href="#两只老虎" class="headerlink" title="两只老虎"></a>两只老虎</h6><p>判断其体重是否相同</p>
<p>有三元运算符</p>
<h6 id="三个和尚"><a href="#三个和尚" class="headerlink" title="三个和尚"></a>三个和尚</h6><p>求三个身高的最高值</p>
<p>也用三元运算符</p>
<h3 id="数据输入Scanner"><a href="#数据输入Scanner" class="headerlink" title="数据输入Scanner:"></a>数据输入Scanner:</h3><p><code>import java.util.Scanner;</code>(导包的动作必须在类定义的上边)</p>
<p><code>Scanner sc=new Scanner(System.in);</code>(sc为变量名可变)创建对象</p>
<p><code>int i=sc.nextInt();</code>(i是变量名可变，sc与上面对应)；接收数据</p>
<h6 id="三个和尚-1"><a href="#三个和尚-1" class="headerlink" title="三个和尚"></a>三个和尚</h6><p>录入三个身高再求最大值</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>顺序结构</p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>1if（关系表达式）{</p>
<p>语句体；}关系表达式为true就执行语句；</p>
<p>2 if（）{</p>
<p>语句体1}else{</p>
<p>语句体2}</p>
<p>3 if（）{</p>
<p>语句1；}else if（）{</p>
<p>语句体2；}else if（）{</p>
<p>语句体3；}—else if（）{</p>
<p>语句体n-1；}</p>
<h6 id="判断是奇偶数"><a href="#判断是奇偶数" class="headerlink" title="判断是奇偶数"></a>判断是奇偶数</h6><p>用if语句</p>
<h6 id="考试奖励"><a href="#考试奖励" class="headerlink" title="考试奖励"></a>考试奖励</h6><p>不同的分有不同的奖励95<del>100山地自行车；90</del>94游乐场80~89变形金刚；80以下竹笋炒肉一顿</p>
<h6 id="数据测试：正确数据，边界数据，错误数据"><a href="#数据测试：正确数据，边界数据，错误数据" class="headerlink" title="数据测试：正确数据，边界数据，错误数据"></a>数据测试：正确数据，边界数据，错误数据</h6><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>switch(表达式){</p>
<p>case值1：语句体1；</p>
<p>​                  break；</p>
<p>case值2：</p>
<p>​                语句体2；</p>
<p>​                 break；……</p>
<p>default：语句体n+1；</p>
<p>break;</p>
<p>}把表达式的值与case比较相同运行其语句遇到break退出</p>
<p>case穿透：无break会向下走直到遇到break退出</p>
<h6 id="春夏秋冬"><a href="#春夏秋冬" class="headerlink" title="春夏秋冬"></a>春夏秋冬</h6><p>输入一个月份输出季节；</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><p>for（初始化语句；条件判断语句；条件控制语句）{</p>
<p>循环体语句}</p>
<p>先初始化再判断语句之后循环语句最后控制语句</p>
<h6 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h6><p>输出9*9乘法表；</p>
<h6 id="求和-sum；"><a href="#求和-sum；" class="headerlink" title="求和 sum；"></a>求和 sum；</h6><h6 id="求偶数和"><a href="#求偶数和" class="headerlink" title="求偶数和"></a>求偶数和</h6><h6 id="输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）"><a href="#输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）" class="headerlink" title="输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）"></a>输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）</h6><p>对任意数字的指定位置上的值：先整除到个位再求余取出</p>
<h6 id="统计水仙花数输出其数量"><a href="#统计水仙花数输出其数量" class="headerlink" title="统计水仙花数输出其数量"></a>统计水仙花数输出其数量</h6><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>初始化；</p>
<p>while（条件判断语句）</p>
<p>{</p>
<p>循环语句；</p>
<p>条件控制语句；}</p>
<h6 id="珠穆朗玛峰8844-43米用一张厚度为0-1毫米。问折叠几次可折成珠峰高度"><a href="#珠穆朗玛峰8844-43米用一张厚度为0-1毫米。问折叠几次可折成珠峰高度" class="headerlink" title="珠穆朗玛峰8844.43米用一张厚度为0.1毫米。问折叠几次可折成珠峰高度"></a>珠穆朗玛峰8844.43米用一张厚度为0.1毫米。问折叠几次可折成珠峰高度</h6><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h4><p>do {</p>
<p>循环体语句；</p>
<p>条件控制语句；}while（条件判断语句）;</p>
<p>三个循环区别：1do while至少一次</p>
<p>2for可直接在初始化时定义但不能带出循环</p>
<p>死循环格式：<code>for(;;)&#123;&#125;</code></p>
<p><code>while(true)&#123;&#125;</code></p>
<p><code>do&#123;&#125;while(true);</code></p>
<h4 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h4><p>continue跳过这次循环进行下一次循环</p>
<p>break退出循环不再循环</p>
<h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>循环语句中包含循环语句</p>
<h6 id="输出一天的小时和分钟"><a href="#输出一天的小时和分钟" class="headerlink" title="输出一天的小时和分钟"></a>输出一天的小时和分钟</h6><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>作用：获得一个随机数；</p>
<p>步骤：导包：<code>import java.util.Random:</code></p>
<p>创建对象：<code>Random r=new Random()；</code>（r可以变，其他不能变。）</p>
<p>获得随机数：<code>int number=r.nextInt(10);</code>(获取数据范围为[0~10）number是变量名，可变，数字10可变。)</p>
<h6 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h6><p>大了小了中了都会提示；</p>
<h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a><strong>idea</strong></h2><hr>
<ul>
<li><p><strong>src中有java文件</strong></p>
</li>
<li><p><strong>out中有class文件</strong></p>
</li>
</ul>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a><strong>项目结构</strong></h4><p><strong>项目（project）——&gt;模块（modern）——&gt;包——&gt;类</strong></p>
<h4 id="内容辅助键和快捷键"><a href="#内容辅助键和快捷键" class="headerlink" title="内容辅助键和快捷键"></a>内容辅助键和快捷键</h4><ul>
<li><p>生成main()方法：psvm回车。</p>
</li>
<li><p>生成输出语句：sout回车。</p>
</li>
<li><p>Ctrl+Alt+space(内容提示，代码补全等).</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">单行注释</th>
<th align="center">多行注释</th>
<th align="center">格式化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ctrl+&#x2F;,再来就是取消</td>
<td align="center">ctrl+shift+&#x2F;再来就是取消</td>
<td align="center">ctrl+alt+L</td>
</tr>
</tbody></table>
<h4 id="模块操作"><a href="#模块操作" class="headerlink" title="模块操作"></a>模块操作</h4><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>同类型，大量的数据的数据模型。</p>
<ol>
<li><p>数据类型[] 变量名 <code>int[] arr</code>定义了一个int类型的数组，名为arr。</p>
</li>
<li><p>数据类型 变量名[]<code>int arr[]</code>定义了一个int类型的变量，名为arr数组。</p>
</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>分配内存空间，并赋值。</p>
<h5 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h5><p>只指定数组长度，由系统为数组分配初始值</p>
<p>数据类型[] 变量名&#x3D;new 数据类型[数组长度]；</p>
<p><code>int [] arr = new int[3];</code></p>
<table>
<thead>
<tr>
<th>int</th>
<th>[  ]</th>
<th>arr</th>
<th>new</th>
<th>int</th>
<th>[     ]</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>数组中的元素类型</td>
<td>说明这是数组</td>
<td>数组名</td>
<td>为数组申请空间</td>
<td>数组中的元素类型</td>
<td>说明这是一个数字</td>
<td>数组长度</td>
</tr>
</tbody></table>
<h4 id="数组元素访问"><a href="#数组元素访问" class="headerlink" title="数组元素访问"></a>数组元素访问</h4><ul>
<li>数组变量访问</li>
</ul>
<p>​    格式：数组名</p>
<ul>
<li>数组元素</li>
</ul>
<p>​     格式：数组名[索引]</p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><code>int [] arr = new int[3];</code></p>
<p>会分配两个空间分别储存地址和元素</p>
<ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th>int [] arr</th>
<th>new int[3]</th>
</tr>
</thead>
<tbody><tr>
<td>指向地址(001)(栈内存)</td>
<td>001(地址)0—0  1—0  2—0（堆内存）</td>
</tr>
</tbody></table>
</li>
</ul>
<p>栈内存：是局部变量使用完后会消失</p>
<p>堆内存：new出来的内容（实体，对象）数组在初始化时会为存储空间添加默认值（new出来的东西会在垃圾回收器空闲时被回收）。</p>
<ul>
<li>整数：0；</li>
<li>浮点数：0.0；</li>
<li>布尔：false；</li>
<li>字符：空字符；</li>
<li>引用数据类型：null；</li>
</ul>
<p>int[ ] arr &#x3D; new int[2];</p>
<p>int[] arr2&#x3D;new int[3];</p>
<p>System.out.println(arr);(地址)</p>
<p>System.out.println(arr[0]);</p>
<p>System.out.println(arr[1]);</p>
<p>System.out.println(arr2);</p>
<p>System.out.println(arr[0]);</p>
<p>System.out.println(arr[2]);</p>
<h5 id="数组内存多个数组指向一个"><a href="#数组内存多个数组指向一个" class="headerlink" title="数组内存多个数组指向一个"></a>数组内存多个数组指向一个</h5><p><code>int[] arr=new int[3];</code></p>
<p><code>int[] arr2=arr;</code></p>
<h4 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h4><p>初始化时指定数组元素初始值，由系统决定数组长度。</p>
<p>格式：数据类型[] 变量名&#x3D;new 数据类型[]{数据1，数据2……};</p>
<p><code>int [] arr= new int[]&#123;1,2,3&#125;;</code></p>
<p>简化：</p>
<p><code>int[] arr=&#123;1,2,3&#125;;</code></p>
<h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><p>索引越界：访问了数组中不存在的元素。</p>
<p>空指针异常：访问的数组不再指向堆内存。null（空指针）。</p>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>数组元素个数：<code>arr.lengh</code></p>
<h5 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h5><p>定义变量取数组第一个数再一次比较</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h3><p>方法是将独立的代码块组织成一个整体，使其成为代码集（类似c语言中的函数）</p>
<ul>
<li>方法定义：方法先创建再使用</li>
<li>方法调用：创建后不直接运行，需手动使用。</li>
</ul>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><code>public static void 方法名(数据类型 变量名1...)</code></p>
<p><code>&#123;</code></p>
<p><code>方法体；&#125;</code></p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>格式：方法名(参数)；</p>
<h6 id="一个方法打印最大值"><a href="#一个方法打印最大值" class="headerlink" title="一个方法打印最大值"></a>一个方法打印最大值</h6><p>形参：方法定义中的参数；</p>
<p>实参：方法调用中的参数；</p>
<h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><p><code>public static 返回值类型 变量名（）&#123;</code></p>
<p><code>...</code></p>
<p><code>return 参数；&#125;</code></p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>数据类型 变量名&#x3D;方法名（参数）；</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><p>不能嵌套定义</p>
</li>
<li><p>void表示无返回值</p>
</li>
</ul>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><ul>
<li>多个方法在同类中</li>
<li>相同的方法名</li>
<li>参数不同，类型不同或数量不同（与返回值无关）</li>
</ul>
<p><code>public static int sun(int a,int b)&#123;</code></p>
<p><code>return a+b;&#125;</code></p>
<p>&#96;&#96;public ststic doublie sun(doublie a,double b){&#96;</p>
<p><code>return a+b;&#125;</code></p>
<p><code>public ststic int sun(int a,int b int c)&#123;</code></p>
<p><code>return a+b+c;&#125;</code></p>
<p>当用public ststic int sun(20,30)时为第一个方法；</p>
<p>通过参数的不同来区别不同方法；</p>
<h6 id="比较两个数使用全整数（byte-short-int-long）并确定是哪个方法。"><a href="#比较两个数使用全整数（byte-short-int-long）并确定是哪个方法。" class="headerlink" title="比较两个数使用全整数（byte short int long）并确定是哪个方法。"></a>比较两个数使用全整数（byte short int long）并确定是哪个方法。</h6><h3 id="方法参数传递"><a href="#方法参数传递" class="headerlink" title="方法参数传递"></a>方法参数传递</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>形参的改变不影响实参的值</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><h4 id="对引用类型的形参影响实参（用地址改变实参）"><a href="#对引用类型的形参影响实参（用地址改变实参）" class="headerlink" title="对引用类型的形参影响实参（用地址改变实参）"></a>对引用类型的形参影响实参（用地址改变实参）</h4><h4 id="其类型为：类，接口，数组，String（字符串）"><a href="#其类型为：类，接口，数组，String（字符串）" class="headerlink" title="其类型为：类，接口，数组，String（字符串）"></a>其类型为：类，接口，数组，String（字符串）</h4><p>ln有换行的作用</p>
<p>System.out.print()——不换行</p>
<h6 id="用方法求数组遍历"><a href="#用方法求数组遍历" class="headerlink" title="用方法求数组遍历"></a>用方法求数组遍历</h6><h6 id="用方法求数组最大值"><a href="#用方法求数组最大值" class="headerlink" title="用方法求数组最大值"></a>用方法求数组最大值</h6><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>概述：查看程序执行流程 ，追踪程序来调试程序</p>
<h4 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h4><p>加断点，运行Debug,按F7继续运行。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h6 id="减肥计划星期1-2-3-4-5-6-7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）"><a href="#减肥计划星期1-2-3-4-5-6-7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）" class="headerlink" title="减肥计划星期1,2,3,4,5,6,7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）"></a>减肥计划星期1,2,3,4,5,6,7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）</h6><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><ul>
<li>手动导包</li>
<li>快捷键：ail+回车</li>
<li>自动导包</li>
</ul>
<h6 id="逢七过包含7或7的倍数"><a href="#逢七过包含7或7的倍数" class="headerlink" title="逢七过包含7或7的倍数"></a>逢七过包含7或7的倍数</h6><h6 id="不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。"><a href="#不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。" class="headerlink" title="不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。"></a>不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。</h6><h6 id="百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。"><a href="#百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。" class="headerlink" title="百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。"></a>百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。</h6><h6 id="数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr-68-27-95-88-171-996-51-210"><a href="#数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr-68-27-95-88-171-996-51-210" class="headerlink" title="数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr[]&#x3D;{68,27,95,88,171,996,51,210}"></a>数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr[]&#x3D;{68,27,95,88,171,996,51,210}</h6><h6 id="数组内容是否相同"><a href="#数组内容是否相同" class="headerlink" title="数组内容是否相同"></a>数组内容是否相同</h6><h6 id="查找找数在数组中的位置"><a href="#查找找数在数组中的位置" class="headerlink" title="查找找数在数组中的位置"></a>查找找数在数组中的位置</h6><p>返回值为索引</p>
<h6 id="反转：把数组反转（借助一个空间）"><a href="#反转：把数组反转（借助一个空间）" class="headerlink" title="反转：把数组反转（借助一个空间）"></a>反转：把数组反转（借助一个空间）</h6><h6 id="评委打分去掉最高分和最低分再算平均分"><a href="#评委打分去掉最高分和最低分再算平均分" class="headerlink" title="评委打分去掉最高分和最低分再算平均分"></a>评委打分去掉最高分和最低分再算平均分</h6><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>类是对现实生活中一类具有共同属性和行为的事物的抽象。</p>
<ul>
<li>类是对象的数据类型</li>
<li>类是具有相同属性和行为的集合</li>
</ul>
<p>属性：对象具有的各种特征，每个对象的每个属性都有特定的值</p>
<p>行为：对象能干什么</p>
<p>对象：是能看到的真实的实体</p>
<p>类是对象的抽象。</p>
<p>类是java的基本组成单位</p>
<p>类的组成：属性和行为</p>
<p>属性和行为在类中的体现：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>成员变量</td>
<td>成员方法</td>
</tr>
</tbody></table>
<p>javabean类不写main方法(不写main方法的类)。</p>
<p>定义步骤：</p>
<ul>
<li>定义类</li>
<li>编写类的成员变量</li>
<li>编写类的成员方法</li>
</ul>
<p><code>public class Phone&#123;</code></p>
<p><code>//成员变量</code></p>
<p><code>String brand;</code></p>
<p><code>int price;</code></p>
<p><code>//成员方法</code></p>
<p><code>public void call()&#123;</code></p>
<p><code>System.out.println(&quot;打电话&quot;)</code></p>
<p><code>public void sendMessage()&#123;</code></p>
<p><code>System.out.println(&quot;发短信&quot;);&#125; </code></p>
<h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h4><p>创建</p>
<ul>
<li>格式：类名 对象名&#x3D;new 类名();</li>
<li>范例：Phone p&#x3D;new Phone();</li>
</ul>
<p>使用</p>
<p>1:使用成员变量     </p>
<ul>
<li>格式：对象名.变量名</li>
<li>范例：p.brond</li>
</ul>
<p>2:使用成员方法</p>
<ul>
<li>格式：对象名.方法名()</li>
<li>范例：p.call()</li>
</ul>
<h6 id="案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。"><a href="#案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。" class="headerlink" title="案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。"></a>案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。</h6><h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><p>能创建多个对象</p>
<p>使用对象在内存中的流程：</p>
<ul>
<li>在栈内存中创建main方法给对象一个地址</li>
<li>在堆内存中创建成员变量（地址一样），在栈内存中使用成员方法。</li>
<li>若有多个对象，重复上述流程（不同的对象的地址不同）</li>
</ul>
<p>多个对象指向相同（其地址相同）</p>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ul>
<li><p>成员变量：类中方法外的变量</p>
</li>
<li><p>局部变量：方法中的变量</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>区别</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类位置不同</td>
<td>类中方法外</td>
<td>方法内或方法声明上</td>
</tr>
<tr>
<td>内存中位置不同</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期不同</td>
<td>随着对象的存在而存在，随着对象的消失而消失</td>
<td>随着方法的调用而存在，随着方法的完毕而消失</td>
</tr>
<tr>
<td>初始值不同</td>
<td>有默认的初始值</td>
<td>没有默认的初始值，必须定义，赋值</td>
</tr>
</tbody></table>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h4><ul>
<li><p>是一个权限权限修饰符</p>
</li>
<li><p>可以修饰成员（成员方法和成员变量）</p>
</li>
<li><p>作用是保护成员不被别的类使用，被private修饰的成员旨在本类中才能访问</p>
<p>针对private修饰的成员变量，如果需要被其他类使用，则需要提供相应的操作（在本类中设置方法）</p>
<ul>
<li>提供“get变量名（）”方法，用于获取成员变量的值，方法用public修饰</li>
<li>提供“set变量名（参数）“方法，用于设置成员变量的值，方法用public修饰</li>
<li>方法可以加判断</li>
</ul>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在方法中加上get&#x2F;set方法</p>
<ul>
<li>set方法是改变值</li>
<li>get方法是获取值</li>
</ul>
<p><code>public void setName(String n)&#123;</code></p>
<p><code>name=n;&#125;</code></p>
<p><code>public int getName()&#123;</code></p>
<p><code>return name;&#125;</code></p>
<p><code>public void showName()&#123;</code></p>
<p><code>System out.println(name);&#125;</code></p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ol>
<li>this修饰的变量指成员变量</li>
</ol>
<ul>
<li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，不是成员变量</li>
<li>方法的形参没有与成员变量同名，不在this的变量也值成员变量</li>
</ul>
<ol start="2">
<li><p>作用：解决局部变量隐藏成员变量</p>
</li>
<li><p>this：代表所在类的对象引用</p>
</li>
</ol>
<h4 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h4><h4 id="封装概述"><a href="#封装概述" class="headerlink" title="封装概述"></a>封装概述</h4><ul>
<li><p>面向对象的三大特征（封装，继承，多态）</p>
</li>
<li><p>是面向对象语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的</p>
</li>
</ul>
<h4 id="封装原则"><a href="#封装原则" class="headerlink" title="封装原则"></a>封装原则</h4><p>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的getXxx()&#x2F;setXxx()方法</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>提高了代码的安全性</li>
<li>提高了代码的复用性</li>
</ul>
<h3 id="构造方法。"><a href="#构造方法。" class="headerlink" title="构造方法。"></a>构造方法。</h3><p>一种特殊的方法</p>
<p>格式：</p>
<p>public class 类名{</p>
<p>修饰符 类名(参数){</p>
<p>}}</p>
<p>注意</p>
<ul>
<li>如无构造方法会默认为无参构造方法</li>
<li>若已定义则不再提供默认的构造方法</li>
<li>构造方法可以重载（推荐书写（无参）构造方法不论是否使用）</li>
</ul>
<h4 id="标准类制作"><a href="#标准类制作" class="headerlink" title="标准类制作"></a>标准类制作</h4><ul>
<li>成员变量都使用private修饰</li>
<li>构造方法提供一个无参构造方法和一个带参构造方法</li>
<li>成员方法提供每一个成员对应的setXxx()&#x2F;getXxx()和显示信息的show()</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>定义：应用程序编程接口（接口类）（类似c语言中的库函数）</p>
<p>java API：JDK中提供的各种功能的java类</p>
<ul>
<li><p>导包：导入附带的软件包（可以使用其中的方法）</p>
</li>
<li><p>创建对象：创建一个具体的事物来接收类</p>
</li>
<li><p>接收数据：用具体的变量来接收对象(具体事物)其中的成员变量</p>
</li>
</ul>
<p>对象调用方法若有返回值用变量接收可用快捷键Ctrl+Alt+v</p>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>String在java.lang包下不需要导包</p>
<p>String在java中是所有“”的字符串文字</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>字符串不可变，它们的值在创建后不能被更改</li>
<li>String的值是不可变的，但可以被共享</li>
<li>字符串效果相当于字符数组(char[]),但底层原理是字节数组（byte[])</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String()</td>
<td>创建一个空白字符串对象</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符串的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] bys)</td>
<td>根据字节数组内容来创建字符串对象</td>
</tr>
<tr>
<td>String s&#x3D;”abc”</td>
<td>直接赋值的方式来创建字符串对象</td>
</tr>
</tbody></table>
<h4 id="String对象的特点"><a href="#String对象的特点" class="headerlink" title="String对象的特点"></a>String对象的特点</h4><ol>
<li>通过new来创建的字符串对象，每次创建的对象都会创建一个存储空间(地址不同)</li>
<li>直接赋值来创建，只要字符串的大小顺序相同它指的都是同一个存储空间(地址相同)</li>
</ol>
<h4 id="比较equals"><a href="#比较equals" class="headerlink" title="比较equals"></a>比较equals</h4><p>使用&#x3D;&#x3D;作比较</p>
<ul>
<li>基本类型：比较的是数据值是否相同</li>
<li>引用类型：比较的是地址是否相同</li>
</ul>
<p>方法：equals()</p>
<ul>
<li>public boolean equals(object anobject)</li>
<li>示例：<code>boolean a=s1.equals(s2)</code>s1,s2为比较的字符串</li>
</ul>
<h6 id="用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。"><a href="#用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。" class="headerlink" title="用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。"></a>用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。</h6><h5 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h5><ul>
<li>录入字符串</li>
<li>遍历字符串public char charAt(int index)；</li>
<li>for(int i&#x3D;0；i&lt;line.length();i++){</li>
<li>System.out.print(line.charAt(i));}</li>
</ul>
<h6 id="统计字符次数"><a href="#统计字符次数" class="headerlink" title="统计字符次数"></a>统计字符次数</h6><ol>
<li>录入一个字符串。</li>
<li>统计三个字符个数，定义三个统计变量初始值都为0</li>
<li>遍历每一个字符</li>
<li>判断该字符是哪种类型对应其统计变量加1；</li>
<li>大写字母：ch&gt;&#x3D;’A’&amp;&amp;ch&lt;&#x3D;’z’</li>
</ol>
<h6 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h6><ol>
<li>定义一个int类型的数组，用静态初始化</li>
<li>定义一个方法用于把int数组中的数据按照格式拼成一个字符串返回String s&#x3D;””;s+&#x3D;arr[0];arr[0]会强制转换为字符串类型</li>
<li>用变量接收结果(s为形参)</li>
</ol>
<h6 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h6><ol>
<li>录入一个字符串</li>
<li>定义一个方法实现反转返回值类型为S听，参数为String s</li>
<li>在方法中倒着遍历再把字符拼接字符串并返回</li>
</ol>
<h3 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><code>String s=&quot;hellow&quot;;</code></p>
<p><code>s+=&quot;world&quot;;</code></p>
<p><code>System.out.println(s);</code></p>
<p>在堆内存中进行：</p>
<ol>
<li>创建一个空间，s存储其地址，其值为hellow</li>
<li>因为没有world的空间所以创建一个空间存储world</li>
<li>最后在创建一个空间存储两个字符串拼接在一起的值，s存储最后空间的地址</li>
</ol>
<p>因为字符串每次拼接都会创造空间，故使用StringBuilder</p>
<p>StringBuilder是可变的字符串类，在其申请的空间中改变值</p>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder()</td>
<td>创建一个空白可变字符串</td>
<td>StringBuilder sb&#x3D;new StringBuilder();</td>
</tr>
<tr>
<td>public StringBuilder(Srting str)</td>
<td>根据字符串的内容来创建可变字符串对象</td>
<td>StringBuilder sb2&#x3D;new StringBuilder(“hellow”);</td>
</tr>
</tbody></table>
<h4 id="添加和反转"><a href="#添加和反转" class="headerlink" title="添加和反转"></a>添加和反转</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuiler append()</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public StringBuiler reverse()</td>
<td>返回相反的字符序列</td>
</tr>
</tbody></table>
<p>append:</p>
<ul>
<li>StringBuiler sb2&#x3D;sb.append(“hellow”)</li>
<li>sb.append(“hellow”)</li>
<li>sb.append(“hellow”).append(“world”).apppend(“java”).append(100)</li>
</ul>
<p>reverse:</p>
<p>sb.reverse()</p>
<h4 id="String与StringBuiler的相互转化"><a href="#String与StringBuiler的相互转化" class="headerlink" title="String与StringBuiler的相互转化"></a>String与StringBuiler的相互转化</h4><p>StringBuiler转换String通过toString();</p>
<p>String s&#x3D;toString(sb);</p>
<p>String转换为StringBuiler通过构造方法</p>
<p>String s；StringBuiler sb&#x3D;new StrngBuiler(s)</p>
<h6 id="定义一个方法把int数组用字符串返回"><a href="#定义一个方法把int数组用字符串返回" class="headerlink" title="定义一个方法把int数组用字符串返回"></a>定义一个方法把int数组用字符串返回</h6><ul>
<li>定义一个int类型的数组并初始化</li>
<li>定义一个方法用于把数字中的数据按指定格式拼接成一个字符串返回(用StringBuiler节省空间)</li>
</ul>
<h6 id="字符串反转-用StringBuiler"><a href="#字符串反转-用StringBuiler" class="headerlink" title="字符串反转(用StringBuiler)"></a>字符串反转(用StringBuiler)</h6><ul>
<li>录入字符串，用Scanner实现</li>
<li>定义一个方法，实现字符串反转。返回值类型为String，参数为String类型</li>
<li>在方法中用StringBuiler实现字符串反转并把结果转成String返回</li>
<li>调用方法，用变量接受并输出。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>特点：存储空间可变的存储模型</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ArrayList()</td>
<td>创建一个空的集合对象</td>
</tr>
<tr>
<td>public boolean add(E e)</td>
<td>将指定的元素追加到集合末尾</td>
</tr>
<tr>
<td>public .void add(int index,E element)</td>
<td>在指定的位置加入集合</td>
</tr>
<tr>
<td>pubilc boolean remove(Object o)</td>
<td>删除元素，并返回成功</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定元素，并返回被删除元素</td>
</tr>
<tr>
<td>public E set(int inder,E element)</td>
<td>修改指定处的元素并返回被修改元素</td>
</tr>
<tr>
<td>public E get（int inder）</td>
<td>返回指定索引处的元素</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合元素的个数</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>ArrayList<String> array &#x3D; new ArrayList&lt;&gt;();</p>
</li>
<li><p>array.add(e)</p>
</li>
<li><p>array.add(1,E)</p>
</li>
<li><p>array.remove( Object E)</p>
</li>
<li><p>array.remove(int 2)</p>
</li>
<li><p>array.set(0,A)</p>
</li>
<li><p>array.get(0)</p>
</li>
<li><p>array.size()</p>
</li>
</ul>
<h6 id="存储字符串并遍历"><a href="#存储字符串并遍历" class="headerlink" title="存储字符串并遍历"></a>存储字符串并遍历</h6><ol>
<li>创建一个集合对象</li>
<li>在集合中添加字符串对象</li>
<li>遍历集合，首先要获得集合中的每一个元素用get(i)</li>
<li>遍历要获取集合长度用size()</li>
<li>通用格式</li>
</ol>
<p><code>for(int i;i&lt;array.size();i++)&#123;</code></p>
<p><code>String s=array.get(i);</code></p>
<p><code>System.out.println(s);&#125;</code></p>
<h6 id="存储学生对象并遍历"><a href="#存储学生对象并遍历" class="headerlink" title="存储学生对象并遍历"></a>存储学生对象并遍历</h6><ol>
<li><p>定义学生类，成员变量用String</p>
</li>
<li><p>创建集合对象</p>
</li>
<li><p>录入学生数据</p>
</li>
<li><p>创建学生对象并添加学生数据</p>
</li>
<li><p>添加学生对象到集合中</p>
</li>
<li><p>遍历集合</p>
</li>
</ol>
<h5 id="学生管理系统"><a href="#学生管理系统" class="headerlink" title="学生管理系统"></a>学生管理系统</h5><h6 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h6><p>1.添加学生<br>2.删除学生<br>3.修改学生<br>4.查看所有学生<br>5.退出系统</p>
<h6 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h6><p>1.定义学生类{</p>
<ul>
<li>学号</li>
<li>姓名</li>
<li>年龄</li>
<li>居住地<br>标准方法(快捷键alt+insert)<br>}<br>2.用输出语句完成主界面的编写<br>3.用Scanner实现录入数据<br>4.用switch语句选择，使用方法实现<br>5.用循环再会回到主界面(System.exit()退出Java虚拟机)</li>
</ul>
<h6 id="添加学生方法编写："><a href="#添加学生方法编写：" class="headerlink" title="添加学生方法编写："></a>添加学生方法编写：</h6><p>  1.定义一个方法<br>  2.提示信息<br>  3.创建学生对象并把数据赋值给学生对象<br>  4.把学生添加到集合中</p>
<h6 id="查看学生方法"><a href="#查看学生方法" class="headerlink" title="查看学生方法"></a>查看学生方法</h6><ol>
<li>先判断是否有数据</li>
<li>显示表头信息</li>
<li>调出数据</li>
</ol>
<h6 id="删除学生的方法"><a href="#删除学生的方法" class="headerlink" title="删除学生的方法"></a>删除学生的方法</h6><ol>
<li>提示信息</li>
<li>录入要删除的学生的信息</li>
<li>遍历集合删除对象</li>
</ol>
<h6 id="修改学生的方法"><a href="#修改学生的方法" class="headerlink" title="修改学生的方法"></a>修改学生的方法</h6><ol>
<li>录入要修改的学生的信息</li>
<li>创建学生对象</li>
<li>遍历修改对应的学生信息</li>
</ol>
<p>解决删除修改时要判断数据不存在问题</p>
<p>解决添加学生学号重复问题</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>两个类有相同的的特征（变量和方法）</p>
<p>可以使子类继承父类的成员和方法</p>
<p>格式：public class 子类 extends 父类{}</p>
<p>好处：提高了代码的复用性，维护性。</p>
<p>弊端：父类变化子类也变化</p>
<p>继承中的变量访问</p>
<p>在子类中访问一个变量</p>
<ul>
<li>子类局部范围找</li>
<li>子类成员</li>
<li>父类成员</li>
<li>都不有就报错(不考虑父亲的父亲…)</li>
</ul>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>当变量名相同时：</p>
<ul>
<li><p>this关键字是访问本类的成员变量也可访问其方法</p>
</li>
<li><p>super关键字是访问父类的成员变量也可访问其方法</p>
</li>
</ul>
<h4 id="访问子类方法的特点"><a href="#访问子类方法的特点" class="headerlink" title="访问子类方法的特点"></a>访问子类方法的特点</h4><h5 id="子类构造方法"><a href="#子类构造方法" class="headerlink" title="子类构造方法"></a>子类构造方法</h5><p>子类中的构造方法都会默认访问父类的无参构造方法</p>
<p>每个子类的构造方法会默认有supre()(访问父类的无参构造方法)</p>
<p>父类中无无参构造方法：</p>
<ul>
<li>用super访问带参构造方法!</li>
<li>手写一个</li>
</ul>
<h5 id="子类方法"><a href="#子类方法" class="headerlink" title="子类方法"></a>子类方法</h5><ul>
<li>子类有方法调子类的方法</li>
<li>子类没有父类有再调用父类的方法</li>
</ul>
<h5 id="super的内存执行"><a href="#super的内存执行" class="headerlink" title="super的内存执行"></a>super的内存执行</h5><h5 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h5><ul>
<li><p>子类出现与父类一样的方法声明</p>
</li>
<li><p>在子类中加上super.方法(参数)来继承父类的方法</p>
</li>
<li><p>@Override是一个注解可以帮我看看方法重写是否相同</p>
</li>
<li><p>父类中的私有方法子类不能重写(父类私有成员是不能被继承的)</p>
</li>
<li><p>子类方法的访问权限不能比父类低(public&gt;默认&gt;私有)</p>
</li>
</ul>
<h3 id="继承的注意"><a href="#继承的注意" class="headerlink" title="继承的注意"></a>继承的注意</h3><ul>
<li>在java中一个类只能继承一个类，只支持单个继承</li>
<li>类支持多层继承</li>
</ul>
<h6 id="老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码"><a href="#老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码" class="headerlink" title="老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码"></a>老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码</h6><ol>
<li>定义老师类(姓名，年龄，教书())</li>
<li>定义学生类(姓名，年龄，学习())</li>
<li>定义测试类，测试</li>
<li>抽取共性父类，定义人类(姓名，年龄)</li>
<li>用继承改写老师类和学生类并给出各自的特有方法</li>
<li>在测试</li>
</ol>
<h6 id="猫和狗：直接使用继承实现"><a href="#猫和狗：直接使用继承实现" class="headerlink" title="猫和狗：直接使用继承实现"></a>猫和狗：直接使用继承实现</h6><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>就是文件夹，对类进行分类管理</p>
<h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>package 包名；</p>
<p><code>package com.ithema;</code></p>
<p>手动建包和自动建包</p>
<h3 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h3><p>使用不同包：</p>
<ul>
<li>需要写全路径</li>
<li>导包(简化带包操作)</li>
<li>import 包名.类名；</li>
<li>improt java.util.Scanner;</li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类中</th>
<th>同包不同类中子类无关类</th>
<th>不同包的子类</th>
<th>不同包的无关类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>能</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认</td>
<td>能</td>
<td>能</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>能</td>
<td>能</td>
<td>能</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>能</td>
<td>能</td>
<td>能</td>
<td>能</td>
</tr>
</tbody></table>
<h3 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h3><ul>
<li>修饰变量：表示该变量为常量，不能再次被赋值</li>
<li>修饰方法：表示该方法为最终方法，不能再次被重写</li>
<li>修饰类：表明该类为最终类，不能被继承</li>
</ul>
<p>修饰局部变量</p>
<p>final修饰基本类型变量为常数，数据值不能变</p>
<p>修饰引用类型变量，地址值不能变，但其内容可以改变。</p>
<h3 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h3><h6 id="static关键字是静态的意思"><a href="#static关键字是静态的意思" class="headerlink" title="static关键字是静态的意思"></a>static关键字是静态的意思</h6><h6 id="无需创建实例就可以被调动"><a href="#无需创建实例就可以被调动" class="headerlink" title="无需创建实例就可以被调动"></a>无需创建实例就可以被调动</h6><ul>
<li>被类的所有对象共享</li>
<li>可以使用类名调用也可用对象调用</li>
</ul>
<p>静态成员方法只能访问静态成员</p>
<p>静态方法和静态成员属于类本身，在类加载时就存在</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个对象，在不同时刻表现出来的不同形态</p>
<h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><ol>
<li><p>继承或实现</p>
</li>
<li><p>方法重写</p>
</li>
<li><p>有父类引用指向子类对象</p>
<p>fu f&#x3D;new zi();</p>
<p>当用a调用成员时</p>
<ul>
<li>成员对象：编译看左边，执行看左边</li>
<li>成员方法：编译看左边，执行看右边</li>
<li>因为成员方法有重写</li>
</ul>
</li>
</ol>
<p>好处：定义方法的时候，使用父类型作为参数，将来在使用的时候使用具体的子类型参与操作</p>
<p>弊端：不能使用子类特有功能</p>
<h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><p>在操作类中用：public void 方法名(fu a){</p>
<p>重写的方法(必须是重写的方法别的方法不行)</p>
<p>}在操作中就是使用子类重写之后的方法，都会跳转到子类方法。</p>
<p>当多子类继承父类的时候可以少写代码到达复用性</p>
<h4 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h4><p>向上转型：(上面的那个实例</p>
<ul>
<li>从子类到父类</li>
<li>父类引用指向子类对象</li>
</ul>
<p>向下转型：(调用子类特殊方法)</p>
<ul>
<li>从父类到子类</li>
<li>父类引用转为子类对象</li>
<li>zi z&#x3D;(zi)f;把父类引用强转为子类</li>
</ul>
<p>![](C:\Users\xiaoxin\Pictures\Screenshots\屏幕截图 2024-07-12 154117.png)</p>
<p>![](C:\Users\xiaoxin\Pictures\Screenshots\屏幕截图 2024-07-12 154434.png)</p>
<p>当运行到Cat cc&#x3D;(Cat) a;时会报错cat类型不能强转为dog类型（父类可以强转为子类但cat和dog不为子父类关系）</p>
<h6 id="猫和狗案例（变量姓名，年龄，方法-标准类，构造方法有无参，eat方法）多态"><a href="#猫和狗案例（变量姓名，年龄，方法-标准类，构造方法有无参，eat方法）多态" class="headerlink" title="猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）多态"></a>猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）多态</h6><h3 id="抽象类概述"><a href="#抽象类概述" class="headerlink" title="抽象类概述"></a>抽象类概述</h3><ul>
<li><p>没有方法体的方法被称为抽象方法，有抽象方法的类被称为抽象类</p>
</li>
<li><p>用abstract来修饰</p>
<p>public abstract class 类名{}</p>
<p>public abstract void 方法名();</p>
</li>
<li><p>抽象方法一定是抽象类，抽象类中可以有非抽象方法，抽象类中可以没有抽象方法</p>
</li>
<li><p>抽象类中无法创建对象（不能实体化），可以参照多态的使用，通过建立子类对象实例化，这叫抽象类多态</p>
</li>
<li><p>抽象类的子类</p>
<p>要么重写抽象类中的所有抽象对象</p>
<p>要么是抽象类</p>
</li>
</ul>
<h4 id="抽象类中的成员特点"><a href="#抽象类中的成员特点" class="headerlink" title="抽象类中的成员特点"></a>抽象类中的成员特点</h4><ul>
<li>抽象类中是包含成员方法，构造方法成员方法</li>
<li>成员变量：可以是变量，也可以是常量</li>
<li>构造方法：不能实体化，用于子类访问父类数据的初始化</li>
<li>成员方法： 可以是抽象方法，必须限定子类完成某些动作，也可是非抽象方法，来提高代码的复用性</li>
</ul>
<h6 id="猫和狗案例（变量姓名，年龄，方法-标准类，构造方法有无参，eat方法）抽象思想"><a href="#猫和狗案例（变量姓名，年龄，方法-标准类，构造方法有无参，eat方法）抽象思想" class="headerlink" title="猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）抽象思想"></a>猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）抽象思想</h6><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种公共行为规范，在java中体现在对行为的抽象</p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li><p>接口是抽象的，用interface修饰，public interface 接口名{}</p>
</li>
<li><p>类实现接口，public class 类名 implements 接口名</p>
</li>
<li><p>接口不能实例化，故参照多态</p>
<p>多态形式：具体类多态，抽象类多态，接口多态</p>
<p>前提：有继承或实现关系，有方法重写，有父类\接口指向子类\实现类对象</p>
</li>
<li><p>实现和抽象类一样</p>
</li>
</ul>
<h5 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h5><ul>
<li>接口中的变量只能是常量默认修饰符，public static final</li>
<li>构造方法：没有构造方法，默认继承Object类</li>
<li>成员方法:只能是抽象方法，默认修饰符，public abstract</li>
</ul>
<h6 id="猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成"><a href="#猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成" class="headerlink" title="猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成"></a>猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成</h6><h4 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h4><ul>
<li><p>类和类是继承关系，只能单继承，但可以多层继承</p>
</li>
<li><p>类和接口是实现关系，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
</li>
<li><p>接口和接口是继承关系可以多继承</p>
</li>
</ul>
<h6 id="运动员和教练"><a href="#运动员和教练" class="headerlink" title="运动员和教练"></a>运动员和教练</h6><p>现在有乒乓球运动员和篮球运动员，乒乓球，篮球教练，乒乓球的相关人员要出国需要英语要用具体类，抽象类，和接口</p>
<p>思路:</p>
<ol>
<li>定义说英语的接口</li>
<li>定义抽象人类（吃饭）</li>
<li>定义抽象教练类，继承人类（教）</li>
<li>定义运动员类继承人类（学）</li>
<li>定义具体的篮球运动员，乒乓球运动员，篮球教练，乒乓球教练分别重写吃饭学习教说英语</li>
</ol>
<h4 id="形参和返回值的问题"><a href="#形参和返回值的问题" class="headerlink" title="形参和返回值的问题"></a>形参和返回值的问题</h4><ul>
<li><p>方法的形参作为类名是需要该类的对象</p>
</li>
<li><p>方法的返回值为是类名，返回的是该类的对象</p>
</li>
<li><p>方法的形参是抽象类名需要的是该抽象类的子类对象</p>
</li>
<li><p>方法返回值是抽象类名，需要的是该抽象类的子类对象</p>
</li>
<li><p>方法的形参是接口名，需要的是该接口的实现类对象</p>
</li>
<li><p>方法的返回值是接口名，返回的是该接口的实现类</p>
</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在类中再定义一个类</p>
<p>public class 类名{</p>
<p>修饰符 class 类名{}}</p>
<p>内部类可以直接访问外部类的成员包括私有</p>
<p>外部类要想访问内部类需要创建对象</p>
<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ol>
<li>成员内部类：在类的成员位置</li>
</ol>
<ul>
<li>外部类名.内部类名 对象名&#x3D;外部类对象.内部类对象</li>
<li>Outerus.inner an&#x3D;new Outer().inner();</li>
<li>一般使用定义方法来调用内部类</li>
</ul>
<ol start="2">
<li><p>局部内部类：直接写<strong>class 类名</strong></p>
<p>在类的局部位置（在成员方法内）</p>
</li>
</ol>
<ul>
<li><p>需要在方法内部创建对象并使用</p>
</li>
<li><p>该类可以直接访问外部类成员，也可访问方法内部的局部变量</p>
<ol start="3">
<li>匿名内部类：存在一个接口或类</li>
</ol>
</li>
<li><p>new 类名或接口(){</p>
</li>
<li><p>重写方法；}</p>
</li>
<li><p>本质：是一个继承了该类或实现了该接口的子类匿名对象（可以当对象使用）</p>
</li>
<li><p>接口名 i&#x3D;new 接口名(){重写方法}  这就是一个接口子类对象</p>
</li>
</ul>
<h1 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h1><p>若类没有构造方法，看是否是静态的，若是就可以通过类名直接调用</p>
<p>看方法的源码，选中，ctrl b</p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>无构造方法是静态</p>
<p>直接调用</p>
<p>包含基本数学运算</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>![](C:\Users\xiaoxin\Pictures\Screenshots\屏幕截图 2024-07-13 102817.png)</p>
<p>实例：int b&#x3D;Math.abs(a);</p>
<p>Math.abs(a);int</p>
<p>Math.ceil(a);double</p>
<p>Math.floor(a);double</p>
<p>Math.round(a);flaot</p>
<p>Math.max(a,b);int</p>
<p>Math.min(a,b);int</p>
<p>Math.pow(a,b);double幂次方</p>
<p>Math.random();返回值为double类型的随机数[0.0,1.0)</p>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>一些与系统交互和进行基本系统操作的方法和属性，是无构造方法是静态的类</p>
<p>包含几个常用的方法</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul>
<li><p>System.out.print();</p>
</li>
<li><p>public static void exit(int status)；终止当前运行的java虚拟机，非零表示异常终止</p>
</li>
<li><p>public static long currentTimeMillis();表示返回当前时间（以毫秒为单位）当前时间与1970年之间存在时间</p>
</li>
<li><p>System.exit(0);</p>
</li>
<li><p>System.currentTimeMillis();用两个相减可以得到程序运行时间</p>
</li>
</ul>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>是所有类的祖宗类只有一个无参构造方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>返回对象的字符串表示形式包含地址，重写后是表示内容自动生成</td>
</tr>
<tr>
<td>public boolean equals(Object   obj)</td>
<td>比较对象是否相等，默认比较地址，重写可比较内容自动生成</td>
</tr>
</tbody></table>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序：只要有大的在后面就会交换</p>
<p>简单选择排序：是只与最大的一个交换位置选择交换</p>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>用于查找和排序</p>
<p>直接调用就行</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static String toString(int[] a)</td>
<td>返回指定数组的内容的字符串表示形式</td>
</tr>
<tr>
<td>public static void sort(int[] a)</td>
<td>按照数字顺序排序指定的数组</td>
</tr>
</tbody></table>
<p>Arrays.toString(arr)</p>
<p>Arrays.sort(arr)</p>
<p>工具类的设计思想：</p>
<ul>
<li>构造方法用private修饰</li>
<li>成员用public static修饰</li>
</ul>
<h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><p>将基本数据类型封装为对象的好处是可以在对象中定义更多功能方法操作该数据</p>
<p>常用与基本数据类型与字符串之间的转换</p>
<p>![](C:\Users\xiaoxin\Pictures\Screenshots\屏幕截图 2024-07-13 150439.png)</p>
<h4 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h4><p>Integer包装int类</p>
<h5 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h5><ul>
<li><p>public Integer(int value);public Integer(String s)；【过时了】</p>
</li>
<li><p>public static Integer valueOf (int i);【现在的】</p>
</li>
<li><p>punlic static Integer valueOf(String s);</p>
</li>
</ul>
<p>实例：</p>
<ul>
<li><p>Integer i1&#x3D;Integer.valueOf(100);</p>
</li>
<li><p>Integer i2&#x3D;Integer.valueOf(“100”);</p>
</li>
</ul>
<h5 id="int与String的相互转化"><a href="#int与String的相互转化" class="headerlink" title="int与String的相互转化"></a>int与String的相互转化</h5><p>int-&gt;String</p>
<ol>
<li><p>字符串参与加法连接从而变成字符串</p>
<p>String s1&#x3D;””+number</p>
</li>
<li><p>String s2&#x3D; String.valueOf(number)</p>
<p>public static String valueOf(int i);</p>
</li>
</ol>
<ul>
<li><p>该方法是String类中的方法是将int转化为String类返回String类</p>
<p>String-&gt;int</p>
</li>
</ul>
<ol>
<li><pre><code>Integer i=new Integer.valueOf(s);

int x=i.intValue();

public int intValue();
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   int y=Integer.parseInt(s);</span><br><span class="line">   </span><br><span class="line">   public static int parseInt(String s);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<ul>
<li>该方法是将String类转化为int类返回int</li>
</ul>
<h6 id="字符串数据排序"><a href="#字符串数据排序" class="headerlink" title="字符串数据排序"></a>字符串数据排序</h6><p>思路：</p>
<ol>
<li>定义一个字符串</li>
<li>把字符串遍历取出并转换为int数组</li>
<li>把int数据排序</li>
<li>把int数据拼接成字符串</li>
</ol>
<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>装箱：把基本类型转换为包装类型</p>
<p>拆箱：是把包装类型转换为基本类型</p>
<p>Interger i&#x3D;100；包含自动装箱</p>
<p>i+&#x3D;200；&#x2F;&#x2F;i&#x3D;i+200;i+200自动拆箱，i&#x3D;i+200;自动装箱</p>
<p>在使用包装类类型的时候最好先判断是否为nulll，nulllbuneng调用方法</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>代表了一个时间以毫秒为精度单位</p>
<p>public Date();</p>
<p>public Date(long date);</p>
<p>需要导入</p>
<p>public long grtTime();获得的是日期从1970年1月1日0:00到想在的毫秒值</p>
<p>public void setTime(long time);设置时间，给的是毫秒值</p>
<h4 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h4><p>是一个具体类，用于以区域设置敏感的方式格式化和解析日期。格式化日期和解析</p>
<p>日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中，从A到Z以及从a到z引号的字母被解释为日期或时间字符串的组件的模式字母</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SimpleDateFormat()</td>
<td>构造一个SimpleDateFormat，使用默认模式和日期格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat使用给定的模式和默认的日期格式</td>
</tr>
</tbody></table>
<h5 id="格式化和解析日期"><a href="#格式化和解析日期" class="headerlink" title="格式化和解析日期"></a>格式化和解析日期</h5><ul>
<li>格式化：public final String format（Date date）将日期格式化成日期、时间字符串 </li>
<li>解析：public Date parse（String source）从给定的字符串开始解析文本以生成日期</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d=<span class="keyword">new</span> <span class="title class_">Date</span><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日   HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">String s=sdf.format(d);<span class="comment">//传来的是上面格式的日期</span></span><br></pre></td></tr></table></figure>

<p>从String到Date</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String ss=<span class="string">&quot;2024年08月09日 11:11:11&quot;</span>；</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf2=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">Date dd=sdf2.parse(ss);<span class="comment">//把字符串解析成日期对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(dd);</span><br></pre></td></tr></table></figure>

<h6 id="定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类"><a href="#定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类" class="headerlink" title="定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类"></a>定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类</h6><ol>
<li><p>因为是工具类构造方法要私有化，方法静态</p>
</li>
<li><p>第一个方法：参数为要转化的日期和代表格式的字符串，再用format方法转换日期再返回字符串日期 </p>
</li>
<li><p>第二个方法：参数为要解析的字符串和字符串的格式，定义SimpleDateFormat 的对象调用parse方法再返回日期</p>
</li>
</ol>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><p>概述</p>
<ul>
<li><p>为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历提供了方法</p>
</li>
<li><p>用类方法获取Calendar对象 ，期日历字段已使用当前日期和时间初始化：</p>
<p>Calendar c&#x3D; Calendar.getlnstance();</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>public int get(int field)</th>
<th>返回日历字段的值</th>
<th>int year&#x3D;c.get(Calendar.YEAR);</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract void add(int filed,int amount)</td>
<td>将给定的时间量添加或减去给定的日历字段</td>
<td>c.add(Calendar.YEAR,-3)三年前的今天</td>
</tr>
<tr>
<td>public final void set (int year,int month,int date)</td>
<td>设置当前日段</td>
<td>c.set(2023,11,11)</td>
</tr>
</tbody></table>
<h6 id="二月天获取任意一年的二月有多少天"><a href="#二月天获取任意一年的二月有多少天" class="headerlink" title="二月天获取任意一年的二月有多少天"></a>二月天获取任意一年的二月有多少天</h6><ol>
<li><p>录入年份</p>
</li>
<li><p>设置日历对象的年月日</p>
<p>年：是录入</p>
<p>月：三月，月份从零开始所以设置的为2</p>
<p>日：设置为1天</p>
</li>
<li><p>三月一日往前推一天即为而与人最后一天</p>
</li>
<li><p>获取这一天输出即可</p>
</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>就是程序出现了不正常情况</p>
<p><img src="/../../themes/butterfl/source/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-15%20104324.png" alt="themes/butterfl/source/img/屏幕截图 2024-07-15 104324.png"></p>
<p>Error:严重问题，不需要处理</p>
<p>Exception:称为异常类，表示程序本身可以处理的问题</p>
<ul>
<li>RuntimeException:在编译期间是不检查的，出问题后修改代码</li>
<li>非RuntimeException:编译期间必须处理，否者不能通过编译（语法问题）</li>
</ul>
<h5 id="JVM的默认处理方案："><a href="#JVM的默认处理方案：" class="headerlink" title="JVM的默认处理方案："></a>JVM的默认处理方案：</h5><ul>
<li>把异常的名称，原因即处理异常出现的位置等信息输出到控制台</li>
<li>程序停止执行</li>
</ul>
<h4 id="异常处理（手动）"><a href="#异常处理（手动）" class="headerlink" title="异常处理（手动）"></a>异常处理（手动）</h4><h5 id="try…catch…"><a href="#try…catch…" class="headerlink" title="try…catch…"></a>try…catch…</h5><p>try{</p>
<p>可能出现异常的代码；}</p>
<p>catch(异常类名 变量名){</p>
<p>异常的处理代码}</p>
<p>程序从try里面的代码开始执行出现异常，会自动生成一个异常类对象，该对象将会被提交给java运行时的系统。当java运行时的系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行处理，执行完毕后程序还会继续往下执行</p>
<h5 id="Throwable的成员方法"><a href="#Throwable的成员方法" class="headerlink" title="Throwable的成员方法"></a>Throwable的成员方法</h5><table>
<thead>
<tr>
<th>public String getMessage()</th>
<th>返回此throwable的详细消息字符串</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>返回此可抛出的简短描述</td>
</tr>
<tr>
<td>public void printStackTrace()</td>
<td>把异常的错误信息输出在控制台上</td>
</tr>
</tbody></table>
<p>java中的异常分为两种：编译时异常和运行时异常，也称为受检异常和非受检异常</p>
<p>编译时异常：必需显示处理</p>
<p>运行时处理：无需显示处理，也可和编译时异常一样处理</p>
<h4 id="throws处理异常"><a href="#throws处理异常" class="headerlink" title="throws处理异常"></a>throws处理异常</h4><p>有时try…catch..处理不了的异常可以用throws处理</p>
<p>throws 异常类名；这个是跟在括号后面的</p>
<p>把异常抛出去了并没有处理只是让调用者来处理</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>继承exception</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 类名()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 类名(String message)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>还要再设一个使用类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Techer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span> <span class="keyword">throws</span> 类名&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(score&lt;<span class="number">0</span>||score&gt;<span class="number">100</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 类名(<span class="string">&quot;你给的分数有误&quot;</span>)<span class="comment">//在方法体内部抛出异常</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;System.out.println(<span class="string">&quot;分数正常&quot;</span>)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><table>
<thead>
<tr>
<th>throws</th>
<th>throw</th>
</tr>
</thead>
<tbody><tr>
<td>用在方法后面，跟的是异常名</td>
<td>用在方法体内，跟的是异常对象名</td>
</tr>
<tr>
<td>表示抛出异常，由方法调用者来处理</td>
<td>表示抛出异常由方法体内的语句来处理</td>
</tr>
<tr>
<td>表示有出现异常的可能性，并不一定会发生这些异常</td>
<td>执行throw一定抛出了某些异常</td>
</tr>
</tbody></table>
<h1 id="集合进阶"><a href="#集合进阶" class="headerlink" title="集合进阶"></a>集合进阶</h1><p>集合：是提供了一种存储空间可变的存储模型</p>
<h4 id="集合类体系："><a href="#集合类体系：" class="headerlink" title="集合类体系："></a>集合类体系：</h4><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240715155008658.png" alt="image-20240715155008658"></p>
<h2 id="Collection集合："><a href="#Collection集合：" class="headerlink" title="Collection集合："></a>Collection集合：</h2><p>JDK无具体的实现类，只有更具体的子接口（Set，List）要调用Collection需要自己创建使用多态</p>
<p>是单例集合的顶层接口，表示一组对象，这些对象也称为Collection的元素</p>
<p>创建Collection集合的对象：</p>
<ul>
<li>多态的方式</li>
<li>具体的实现类ArrayList</li>
<li>要导入</li>
</ul>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240715160023274.png" alt="image-20240715160023274"></p>
<h4 id="Collection集合的遍历"><a href="#Collection集合的遍历" class="headerlink" title="Collection集合的遍历"></a>Collection集合的遍历</h4><p>Iterator：迭代器，集合的专用遍历方式</p>
<ul>
<li>Iterator<E> iterator():返回此集合中元素的迭代器，通过集合的iterator()的方法实现的</li>
<li>迭代器是通过集合的iterator()方法的到的，故它是依赖于集合存在的</li>
</ul>
<p>常用方法</p>
<ul>
<li>E next():返回迭代中的下一个元素</li>
<li>boolean hasNext():如果迭代具有更多元素，则返回true</li>
</ul>
<p>就是返回下一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">c.add(<span class="string">&quot;hellow&quot;</span>);</span><br><span class="line"></span><br><span class="line">c.add(<span class="string">&quot;wrold&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it=c.iterator();whle</span><br><span class="line"></span><br><span class="line">System.out.println(it.Next());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it.hasNext)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(it.Next);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h4><ol>
<li><p>创建集合对象</p>
</li>
<li><p>添加元素</p>
<p>2.1 创建元素</p>
<p>2.2添加元素到集合</p>
</li>
<li><p>遍历集合</p>
<ol>
<li><p>通过结合对象获取迭代器对象</p>
</li>
<li><p>通过迭代器对象的hasNext()方法判断是否还有元素</p>
</li>
<li><p>通过迭代器对象的Next()方法获取下一元素</p>
</li>
</ol>
</li>
</ol>
<h6 id="Collection集合储存学生对象并遍历"><a href="#Collection集合储存学生对象并遍历" class="headerlink" title="Collection集合储存学生对象并遍历"></a>Collection集合储存学生对象并遍历</h6><p>创建一个储存学生对象的集合，储存三个学生对象，遍历该集合</p>
<p>思路：</p>
<ol>
<li>定义学生类</li>
<li>创建Collection集合对象</li>
<li>创建学生对象</li>
<li>把学生添加到集合</li>
<li>遍历集合（迭代器方式）</li>
</ol>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><p>直接创造方法返回的类型：在方法写完后ctrl+alt+v</p>
</li>
<li><p>导入构造方法，getxxx方法，setxxx方法：alt+insert</p>
</li>
<li><p>跟进查看源码：ctrl+b</p>
</li>
<li><p>导包ait+enter(回车)</p>
</li>
</ul>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><ul>
<li>需要导入</li>
<li>有序集合（也称为序列），用户可以精准的控制列表中的每一个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素</li>
<li>与Set集合不同，列表允许重复元素</li>
<li>有序：存储和取出的元素顺序一致</li>
<li>可重复：存储的元素可以重复</li>
</ul>
<table>
<thead>
<tr>
<th>void <strong>add</strong>(int inder,E element)</th>
<th>在此集合中的指定位置插入指定的元素</th>
</tr>
</thead>
<tbody><tr>
<td>E <strong>remove</strong>(int inder)</td>
<td>删除指定索引处的元素，返回被删除元素</td>
</tr>
<tr>
<td>E <strong>set</strong>(int inder,E element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td>E <strong>get</strong>(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody></table>
<h6 id="List集合存储学生对象并遍历"><a href="#List集合存储学生对象并遍历" class="headerlink" title="List集合存储学生对象并遍历"></a>List集合存储学生对象并遍历</h6><ol>
<li>定义学生类</li>
<li>创建List集合对象</li>
<li>创建学生对象</li>
<li>把学生添加到集合</li>
<li>遍历集合（迭代器方式）</li>
</ol>
<h5 id="并发修改异常："><a href="#并发修改异常：" class="headerlink" title="并发修改异常："></a>并发修改异常：</h5><p>用迭代器时使用add等方法就会造成并发修改异常；</p>
<p>改用for循环就不会有问题</p>
<h3 id="listlterator列表迭代器"><a href="#listlterator列表迭代器" class="headerlink" title="listlterator列表迭代器"></a>listlterator列表迭代器</h3><ul>
<li><p>通过List集合的listlerator()方法得到的，所以说它是List集合特有的迭代器</p>
</li>
<li><p>它允许从任意方向遍历集合，在迭代期间膝盖列表，并获得列表中迭代器的当前位置</p>
</li>
</ul>
<h5 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h5><ul>
<li>E <strong>next</strong>()：返回迭代中的下一个元素</li>
<li>boolean <strong>hasNext</strong>():如果迭代具有更多元素，则返回true</li>
<li>E <strong>previous</strong>():返回列表的上一个元素</li>
<li>boolean <strong>hasPrevious</strong>():如果此列表迭代器在<strong>相反</strong>的方向遍历列表是具有更多元素，则返回true</li>
<li><strong>void add(E e):将指定元素插入列表</strong></li>
</ul>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>简化数组和Collecttion集合的遍历</p>
<ul>
<li>实现lterable接口的类允许其对象成为增强型for语句的目标</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li>
</ul>
<p>增强for的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素数据类型 变量名：数组或Collection)&#123;</span><br><span class="line">    <span class="comment">//在此处使用变量即可，变量就是元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">        System.out.println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//会输出1，2，3，4</span></span><br></pre></td></tr></table></figure>

<h6 id="List集合储存学生对象用三种方式遍历"><a href="#List集合储存学生对象用三种方式遍历" class="headerlink" title="List集合储存学生对象用三种方式遍历"></a>List集合储存学生对象用三种方式遍历</h6><ol>
<li><p>定义学生类</p>
</li>
<li><p>创建List集合对象</p>
</li>
<li><p>创建学生对象</p>
</li>
<li><p>把学生添加到集合</p>
</li>
<li><p>遍历集合</p>
<p>迭代器：集合特有的方式</p>
<p>for：带有索引的遍历方式</p>
<p>增强for：最方便的遍历方式</p>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈顶元素，栈底元素，先进后出</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队头&#x2F;前端：出队列</p>
<p>队尾&#x2F;后端：入队列</p>
<p>先进先出</p>
<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p>查询快，增删慢</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>查询慢，增删快</p>
<h3 id="List集合子类"><a href="#List集合子类" class="headerlink" title="List集合子类"></a>List集合子类</h3><ul>
<li>ArrayList：底层数据结构是数组，查询快，增删慢</li>
<li>LinkedList：底层数据结构是链表，查询慢，增删快</li>
</ul>
<h6 id="分别使用ArrayList和LinkedList完成存储字符串并遍历"><a href="#分别使用ArrayList和LinkedList完成存储字符串并遍历" class="headerlink" title="分别使用ArrayList和LinkedList完成存储字符串并遍历"></a>分别使用ArrayList和LinkedList完成存储字符串并遍历</h6><p>ArrayList的遍历：</p>
<ol>
<li><p>定义学生类</p>
</li>
<li><p>创建ArrayList集合对象</p>
</li>
<li><p>创建学生对象</p>
</li>
<li><p>把学生添加到集合</p>
</li>
<li><p>遍历集合</p>
<p>迭代器：集合特有的方式</p>
<p>for：带有索引的遍历方式</p>
<p>增强for：最方便的遍历方式</p>
</li>
</ol>
<p>LinkedList的遍历</p>
<ol>
<li><p>定义学生类</p>
</li>
<li><p>创建LinkedList集合对象</p>
</li>
<li><p>创建学生对象</p>
</li>
<li><p>把学生添加到集合</p>
</li>
<li><p>遍历集合</p>
<p>迭代器：集合特有的方式</p>
<p>for：带有索引的遍历方式</p>
<p>增强for：最方便的遍历方式</p>
</li>
</ol>
<h5 id="LinkedList集合的特有功能："><a href="#LinkedList集合的特有功能：" class="headerlink" title="LinkedList集合的特有功能："></a>LinkedList集合的特有功能：</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240716195849087.png" alt="image-20240716195849087"></p>
<h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>不包含重复元素的集合，是一个接口，要导入</p>
<p>没有带索引的方法，所以不能使用普通for循环</p>
<p>HashSet:对迭代顺序不作任何保证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">&quot;hellow&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String s:set)&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><ul>
<li><p>是JDK 根据对象的地址或字符串或数字算出来的int类型的数组</p>
</li>
<li><p>Object类中有一个方法可以获得对象的哈希值</p>
</li>
<li><p>pubhlic int hashCode():返回对象的哈希值</p>
</li>
<li><p>同一个对象的哈希值是相同的，默认情况下，不同对象的哈希值是不同的</p>
</li>
<li><p>可以重写hashCode()方法，让不同的对象实现相同</p>
</li>
</ul>
<h4 id="HashSet集合概述和特点"><a href="#HashSet集合概述和特点" class="headerlink" title="HashSet集合概述和特点"></a>HashSet集合概述和特点</h4><ul>
<li>底层数据结构是哈希表</li>
<li>对迭代顺序不作任何保证，不保证存入的顺序和取出的顺序一致</li>
<li>没有带索引的方法，所以不能使用普通for循环</li>
<li>是Set集合，不包含重复元素</li>
<li>要保证元素唯一性，就需要重写hashCode()和equals()【在对象中重写这两个方法】</li>
</ul>
<h6 id="用哈希表遍历集合"><a href="#用哈希表遍历集合" class="headerlink" title="用哈希表遍历集合"></a>用哈希表遍历集合</h6><h4 id="数据结构之哈希表"><a href="#数据结构之哈希表" class="headerlink" title="数据结构之哈希表"></a>数据结构之哈希表</h4><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240716211106932.png" alt="image-20240716211106932"></p>
<h6 id="HashSet集合存储学生对象并遍历"><a href="#HashSet集合存储学生对象并遍历" class="headerlink" title="HashSet集合存储学生对象并遍历"></a>HashSet集合存储学生对象并遍历</h6><ol>
<li>定义学生类，在其中重写hashCode和equals()方法</li>
<li>创建HashSet集合对象</li>
<li>创建学生对象</li>
<li>把学生对象添加到集合</li>
<li>遍历集合（增强for）</li>
</ol>
<h4 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h4><ul>
<li>由哈希表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储顺序和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复元素</li>
</ul>
<h6 id="存储字符串并遍历-1"><a href="#存储字符串并遍历-1" class="headerlink" title="存储字符串并遍历"></a>存储字符串并遍历</h6><h3 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h3><ul>
<li><p>元素有序，这里的有序是按照一定的规则进行排序，具体的排序方式取决于构造方法</p>
<p>TreeSet():根据其元素的自然排序进行排序</p>
<p>TreeSet(Comparator comparator):根据指定的比较器进行排序</p>
</li>
<li><p>没有带索引的方法，所以不能使用普通for循环</p>
</li>
<li><p>无重复元素,要导包</p>
</li>
<li><p>创建集合是使用的是包装类类型,会自动装箱</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">TreeSet&lt;Integer&gt; ts=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">    ts.add(<span class="number">10</span>)；</span><br><span class="line">    ts.add(<span class="number">23</span>);</span><br><span class="line">    ts.add(<span class="number">1</span>);</span><br><span class="line">    ts.add(<span class="number">21</span>);</span><br><span class="line">    <span class="keyword">for</span>(Interger i:ts)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;<span class="comment">//会输出1,10,21,23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自然排序Comparable的使用"><a href="#自然排序Comparable的使用" class="headerlink" title="自然排序Comparable的使用"></a>自然排序Comparable的使用</h5><ul>
<li><p>存储学生对象并遍历，创建集合使用无参构造方法</p>
</li>
<li><p>要求：按照年龄从小到大排序，年龄相同时，按照名字字母排序</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">TreeSet&lt;student&gt; ts=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xishi&quot;</span>,<span class="number">23</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangzhuaojun&quot;</span>,<span class="number">18</span>);</span><br><span class="line">ts.add(s1);</span><br><span class="line">ts.add(s2);</span><br><span class="line"><span class="keyword">for</span>(Student s :ts)&#123;</span><br><span class="line">System.out.println(s.getName()+<span class="string">&quot;,&quot;</span>+s.getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写comparaTo方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">comparaTo</span><span class="params">(Student s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="built_in">this</span>.age-s.age;<span class="comment">//this是这个本身的对象，s是上一个的对象</span></span><br><span class="line">    num==<span class="number">0</span>?<span class="built_in">this</span>.name.comparaTo(S.name):num;<span class="comment">//次要条件姓名不相同</span></span><br><span class="line">    <span class="keyword">return</span> num;<span class="comment">//主要条件比较年龄从小到大</span></span><br><span class="line">    <span class="comment">//return 0表示重复就只能存储进第一个对象</span></span><br><span class="line">    <span class="comment">//return 1;正数表示用升序来存储</span></span><br><span class="line">    <span class="comment">//return -1;负数表示用降序来存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结论：	</p>
<ul>
<li><p>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序</p>
</li>
<li><p>使用类的对象时，其类要实现compareTo接口，重写comparaTo(to)方法</p>
</li>
<li><p>自然排序</p>
</li>
<li><p>重写方法时一定要注意排序规则必须按照要求的主要条件和次要条件来重写</p>
</li>
</ul>
<h5 id="比较器排序Comparator"><a href="#比较器排序Comparator" class="headerlink" title="比较器排序Comparator"></a>比较器排序Comparator</h5><p>存储学生对象并遍历使用TreeSet的带参构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">TreeSet&lt;Student&gt; ts=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Student&gt;(<span class="keyword">new</span> <span class="title class_">comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Sudent s1,Student s2)</span>&#123;</span><br><span class="line">   <span class="type">int</span> num=s1.age-s2.age;</span><br><span class="line">   num==<span class="number">0</span>?s1.name.comparator(s2.name):num ;</span><br><span class="line">   <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line">&#125;)<span class="comment">//用的是匿名内部类它需要一个comparaTo的实现类子接口</span></span><br><span class="line"> Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xishi&quot;</span>,<span class="number">23</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangzhuaojun&quot;</span>,<span class="number">18</span>);</span><br><span class="line">ts.add(s1);</span><br><span class="line">ts.add(s2);</span><br><span class="line"><span class="keyword">for</span>(Student s :ts)&#123;</span><br><span class="line">System.out.println(s.getName()+<span class="string">&quot;,&quot;</span>+s.getAge());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h6><ol>
<li><p>定义学生类</p>
</li>
<li><p>创建TreeSet集合对象，通过比较器进行排序或自然排序；</p>
</li>
<li><p>创建学生对象</p>
</li>
<li><p>把学生对象添加到集合中</p>
</li>
<li><p>遍历集合</p>
</li>
</ol>
<h6 id="不重复的随机数"><a href="#不重复的随机数" class="headerlink" title="不重复的随机数"></a>不重复的随机数</h6><ol>
<li>创建Set集合对象</li>
<li>创建随机数对象</li>
<li>判断集合的长度是不是小于10</li>
<li>遍历集合</li>
<li>创建随机数方法：Random</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> numbe=r.nextInt(<span class="number">20</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>本质是参数化类型，就是将由原来的具体的类型参数化，然后在使用时传入具体的类型</p>
<p>可以分别应用在类，方法和接口中，分别被称为泛型类，泛型方法和泛型接口</p>
<p>泛型定义格式：</p>
<ul>
<li>&lt;类型&gt;:指定一中类型格式。这里的类型可以看成是形参</li>
<li>&lt;类型1，类型2…&gt;:指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看做是形参</li>
<li>将来具体调用的时候给定的类型可以看作是实参，并且实参的类型只能是引用数据类型</li>
</ul>
<h4 id="泛型类："><a href="#泛型类：" class="headerlink" title="泛型类："></a>泛型类：</h4><ul>
<li>修饰符 class 类名&lt;类型&gt;{}</li>
<li>public class Generic<T>{}&#x2F;&#x2F;T为随意 的任意标识</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gener</span>&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> T t;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.t=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gener<String> g&#x3D;new Gener<String>();</p>
<p>Gener<int> i&#x3D;new Gener<int>();</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>修饰符&lt;类型&gt; 返回值类型 方法名(类型 变量名){}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>g.show(“ling”);</p>
<p>g.show(122);</p>
<p>g.show(“124”);</p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>用接口实现的泛型</p>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<ul>
<li>类型通配符：&lt;?&gt;</li>
<li>List&lt;?&gt;:表示元素型未知的List，它的元素可以匹配任何的类型</li>
<li>这种带通配符的List仅表示它是各种泛型类的父类，并不能把元素添加的其中</li>
</ul>
<p>类型通配符的上限，只表示它是代表某一类泛型List的父类</p>
<ul>
<li><? extends 类型>
</li>
<li><p>List&lt;? extends Number&gt;:表示的是Number 或者其子类型</p>
</li>
</ul>
<p>类型通配符的下限</p>
<ul>
<li>类型通配符的下限：&lt;? super 类型&gt;</li>
<li>List&lt;?super Number&gt;:表示的是Number或其父类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? &gt; list1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;? &gt; list2=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">List&lt;? &gt; list3=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">System.out.println(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list4=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list5=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">System.out.println(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">List&lt;? <span class="built_in">super</span> Number&gt; list6=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> Number&gt; list7=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>参数个数可变的方法</p>
<p>public static int sum(int b,int… a){}</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>可变参数其实就是一个数组</p>
<p>当包含不变参数时，可变参数要放在最后</p>
<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><ul>
<li><p>Arrays类工具类的静态方法(static)</p>
<p>public static <T> List<T> asList(T…a):放回由指定数组的大小固定的列表</p>
<p>不能作增删，能修改</p>
</li>
<li><p>List接口中有静态方法：</p>
<p>public static<E> List<E> of(E…e):返回包含任意数量元素的不可变列表</p>
<p>不能增删改</p>
</li>
<li><p>Set接口中有一个静态方法：</p>
<p>public static<E> Set<E> of(E…e):返回一包含任意数量元素的不可变集合</p>
<p>元素不能重复，不能增删改</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=Arrays.asList(<span class="string">&quot;hellow&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;javase&quot;</span>);</span><br><span class="line"><span class="comment">//list.add(&quot;javawed&quot;);//会报错，是固定大小的数组</span></span><br><span class="line"><span class="comment">//list.remove(&quot;javase&quot;)://也会报错</span></span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">List&lt;<span class="type">int</span>&gt; listt=List.of(<span class="number">12</span>,<span class="number">24</span>,<span class="number">353</span>,<span class="number">4652</span>);</span><br><span class="line"><span class="comment">//listt.add(21);都会报错</span></span><br><span class="line"><span class="comment">//listt.remove(12);都会报错</span></span><br><span class="line"><span class="comment">//listt.set(1,22);都会报错</span></span><br><span class="line">Set&lt;<span class="type">int</span>&gt; se=Set.of(<span class="number">12</span>,<span class="number">23</span>,<span class="number">234</span>,<span class="number">354</span>);<span class="comment">//不能有重复的元素</span></span><br><span class="line"><span class="comment">//se.add(122);//会报错</span></span><br><span class="line"><span class="comment">//se.remove(12会报错</span></span><br><span class="line"><span class="comment">//se.set(1,33);//不能调，没有带索引的方法不存在</span></span><br></pre></td></tr></table></figure>

<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><ul>
<li><p>要导包，是一个接口</p>
</li>
<li><p>Interface Map&lt;K,V&gt;,k是键的类型，v是值的类型</p>
</li>
<li><p>将键映射到值的对象；不能包含重复的键每个键可以映射到最多一个值</p>
</li>
<li><p>多态方式，HashMap是具体实现对象</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V put (k key,v value)</td>
<td>将指定的值与该映射中的指定值相关联，有唯一性，出现重复的会替代，添加元素</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>删除键值对元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除所有键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断是否有指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合中键值对的个数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;wa&quot;</span>,<span class="string">&quot;zhao&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;guo&quot;</span>,<span class="string">&quot;huang&quot;</span>);</span><br><span class="line">map.remove(<span class="string">&quot;guo&quot;</span>);</span><br><span class="line">map.clear();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>获取方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V get(Object key)</td>
<td>获取键对应的值</td>
</tr>
<tr>
<td>Set<K> keySet()</td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td>Collection<V> values()</td>
<td>获取所有值的集合</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String inw=map.get(<span class="string">&quot;wa&quot;</span>);</span><br><span class="line">Set&lt;String&gt; key=map.keySet();</span><br><span class="line">Collection&lt;String&gt; values=map.values();</span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt; en=map.entrySet();</span><br></pre></td></tr></table></figure>

<h6 id="Map集合遍历1"><a href="#Map集合遍历1" class="headerlink" title="Map集合遍历1"></a>Map集合遍历1</h6><ol>
<li>获取所有键的集合</li>
<li>遍历键的集合</li>
<li>根据键去找值</li>
</ol>
<p>2</p>
<ol>
<li>获取键值对对象的集合</li>
<li>遍历其集合</li>
<li>获得键和值</li>
<li>getKey()和getValue()获得键和值</li>
</ol>
<h6 id="HashMap集合存储学生对象并遍历"><a href="#HashMap集合存储学生对象并遍历" class="headerlink" title="HashMap集合存储学生对象并遍历"></a>HashMap集合存储学生对象并遍历</h6><ol>
<li>定义学生类</li>
<li>创建HashMap集合对象</li>
<li>创建学生对象，值是学生对象</li>
<li>把学生对象添加到集合</li>
<li>遍历集合（键找值   或   键值对找键和值）</li>
</ol>
<h6 id="HashMap集合存储学生对象并遍历-1"><a href="#HashMap集合存储学生对象并遍历-1" class="headerlink" title="HashMap集合存储学生对象并遍历"></a>HashMap集合存储学生对象并遍历</h6><p>要求：键是学生对象，值是居住地，存储多个键值对元素，并遍历，要保证键的唯一性</p>
<ol>
<li>定义学生类，重写hashCode()和equals()方法</li>
<li>创建HashMap集合对象</li>
<li>创建学生对象</li>
<li>把学生对象添加到集合</li>
<li>遍历集合（键找值   或   键值对找键和值）</li>
</ol>
<h6 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h6><p>ArrayList集合存储HashMap元素并遍历</p>
<ul>
<li>创建ArrayList集合</li>
<li>创建HashMap集合，并添加键值对元素</li>
<li>把HashMap作为元素添加到ArrayList中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,String&gt; hum1=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hum1.put(<span class="string">&quot;孙十万&quot;</span>,<span class="string">&quot;大乔&quot;</span>)；</span><br><span class="line">hum1.put(<span class="string">&quot;周瑜&quot;</span>,<span class="string">&quot;小乔&quot;</span>)；</span><br><span class="line">array.add(hum1);</span><br><span class="line">HashMap&lt;String,String&gt; hum2=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hum2.put(<span class="string">&quot;郭靖&quot;</span>,<span class="string">&quot;黄蓉&quot;</span>)；</span><br><span class="line">hum2.put(<span class="string">&quot;演过&quot;</span>,<span class="string">&quot;小龙女&quot;</span>)；</span><br><span class="line">array.add(hum2);</span><br><span class="line"><span class="keyword">for</span>(HashMap&lt;String,String&gt; hm:array)&#123;</span><br><span class="line">    Set&lt;String&gt; keySet=hm.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key:keySet)&#123;</span><br><span class="line">        String value=hm.get(key);</span><br><span class="line">        System.out.println(key+<span class="string">&quot;,&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap集合存储ArrayList元素并遍历</p>
<ul>
<li>创建HashMap集合</li>
<li>创建ArrayList集合，并添加元素</li>
<li>把ArrayList作为元素添加到HashMap中</li>
<li>并遍历</li>
</ul>
<h6 id="统计字符串中每个字符出现的次数"><a href="#统计字符串中每个字符出现的次数" class="headerlink" title="统计字符串中每个字符出现的次数"></a>统计字符串中每个字符出现的次数</h6><ol>
<li><p>录入一个字符串</p>
</li>
<li><p>创建HashMap集合,键是Character,值是Intrger</p>
</li>
<li><p>遍历字符串，得到每一个字符</p>
</li>
<li><p>拿得到的每一个字符到HashMap中去找对应的值，看起返回值</p>
<p>若返回值为null说明该字符在HashMap中没有，就把它作为键，1作为值存储</p>
<p>若返回值不为null说明存在，其值加1，然后重新存储该字符和值</p>
</li>
<li><p>遍历HashMap集合，得到键和值，拼接成a()b()c()</p>
</li>
</ol>
<h4 id="Collections的概述"><a href="#Collections的概述" class="headerlink" title="Collections的概述"></a>Collections的概述</h4><p>是针对集合操作的工具类</p>
<ul>
<li>public static &lt;T extends Comparable&lt;?super T&gt;&gt; void sort(List<T> list):将指定的列表按升序排序</li>
<li>public static void reverse(List&lt;?&gt; list):反转指定列表中的元素的顺序</li>
<li>public static void shuffle(List&lt;?&gt; list)：使用默认的随机源随机排序列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">Collections.sort(list);</span><br><span class="line">Collextions.reverse(list);</span><br><span class="line">Collextions.shuffle(list);</span><br></pre></td></tr></table></figure>

<h6 id="ArrayList存储大学生并排序使用Collections"><a href="#ArrayList存储大学生并排序使用Collections" class="headerlink" title="ArrayList存储大学生并排序使用Collections"></a>ArrayList存储大学生并排序使用Collections</h6><ol>
<li>定义学生类</li>
<li>创建ArrayList集合对象</li>
<li>创建学生对象</li>
<li>把学生对象添加到集合</li>
<li>使用Collections对ArrayLIst集合进行排序</li>
<li>遍历集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(array,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compara</span><span class="params">(Student s1,Student s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=s1.getAge-s2.getAge();</span><br><span class="line">    <span class="type">int</span> num2=(num==0s1.getName().compareTo(s2.getName()):num);</span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)<span class="comment">//这是使用匿名内部类创造了一个VComparator(调试器)子接口的具体实现类来对ArrayList进行排序</span></span><br></pre></td></tr></table></figure>

<h6 id="模拟斗地主的洗牌，发牌和看牌"><a href="#模拟斗地主的洗牌，发牌和看牌" class="headerlink" title="模拟斗地主的洗牌，发牌和看牌"></a>模拟斗地主的洗牌，发牌和看牌</h6><ol>
<li>创建一个牌盒</li>
<li>往牌盒里面装牌</li>
<li>洗牌：把牌打散</li>
<li>发牌：遍历集合，给三个玩家发牌</li>
<li>看牌，就是玩家各自遍历自己的牌</li>
</ol>
<p>升级版：</p>
<ol>
<li>创建HashMap，键是编号，值是牌</li>
<li>创建ArrayList,存储编号</li>
<li>创建花色数组，点数数组</li>
<li>从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList中存储编号</li>
<li>洗牌（洗编号），用Coolections的shuffle()方法实现</li>
<li>发牌（发编号），为了保证编号是排序的，创建TreeSet集合接收</li>
<li>定义看牌的方法（遍历TreeSet集合，获取编号，到HashMap中找对应的牌）</li>
<li>调用看牌的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();<span class="comment">//创建HashMap，键是编号，值是牌</span></span><br><span class="line">ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();<span class="comment">//创建ArrayList,存储编号</span></span><br><span class="line">String[] colors=&#123;<span class="string">&quot;♦&quot;</span>,<span class="string">&quot;♣&quot;</span>,<span class="string">&quot;♥&quot;</span>,<span class="string">&quot;♠&quot;</span>&#125;;</span><br><span class="line">String[] numbers=&#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//创建花色数组，点数数组</span></span><br><span class="line"><span class="type">int</span> inder=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String hu:colors)&#123;</span><br><span class="line">    <span class="keyword">for</span>(String mu:numbers)&#123;</span><br><span class="line">        hm.put(inder,hu+mu);</span><br><span class="line">        array.add(inder);</span><br><span class="line">        inder++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList中存储编号</span></span><br><span class="line">hm.put(inder,<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">array.add(inder);</span><br><span class="line">inder++;</span><br><span class="line">hm.put(inder,<span class="string">&quot;大王&quot;</span>);</span><br><span class="line">array.add(inder);<span class="comment">//从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList中存储编号</span></span><br><span class="line">TreeSet&lt;Integer&gt; lqxSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();<span class="comment">//创建角色对象,创建TreeSet集合接收</span></span><br><span class="line">TreeSet&lt;Integer&gt; wtSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">TreeSet&lt;Integer&gt; lySet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">TreeSet&lt;Integer&gt; dpSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">Collections.shuffle(array);<span class="comment">//洗牌（洗编号），用Coolections的shuffle()方法实现</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.size();i++)&#123;</span><br><span class="line">    <span class="type">int</span> x=array.get(i);</span><br><span class="line">   <span class="keyword">if</span>(i&gt;=array.size()-<span class="number">3</span>)&#123;</span><br><span class="line">       dpSet.add(x);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">       lqxSet.add(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        wtSet.add(x);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">        lySet.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 发牌（发编号），为了保证编号是排序的，创建TreeSet集合接收</span></span><br><span class="line">lookpoker(<span class="string">&quot;林青霞&quot;</span>,lqxSet,hm);</span><br><span class="line">lookpoker(<span class="string">&quot;王涛&quot;</span>,wtSet,hm);</span><br><span class="line">lookpoker(<span class="string">&quot;柳岩&quot;</span>,lySet,hm);</span><br><span class="line">lookpoker(<span class="string">&quot;底牌&quot;</span>,dpSet,hm);<span class="comment">//看牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lookpoker</span><span class="params">(String name,TreeSet&lt;Integer&gt; tt,HashMap hm)</span>&#123;</span><br><span class="line">    System.out.print(name+<span class="string">&quot;的牌是：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(TreeSet&lt;Integer&gt; ka:tt)&#123;</span><br><span class="line">        String poker=hm.get(ka);</span><br><span class="line">        System.out.print(poker+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Io流"><a href="#Io流" class="headerlink" title="Io流"></a>Io流</h1><p>Io:输入&#x2F;输出(Input&#x2F;Output)</p>
<p>流：是一种抽象概念，是对数据传输的总称，数据在设备之间的传输称为流</p>
<p>Io流就是用来处理设备之间的传输的问题的，常应用于文件复制，文件下载，文件上传</p>
<p>按数据流向分为;</p>
<p>输入流：读数据</p>
<p>输出流：写数据</p>
<p>按数据类型分：</p>
<p>字节流：字节输入流和字节输出流</p>
<p>字符流：字符输入流和字符输出流</p>
<p>若用记事本打开能看懂就是字符流，是乱码就是字节流，一般使用字节流</p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>file：是文件和目录路径名的抽象表示</p>
<ul>
<li><p>文件和目录是可以通过File封装成对象的</p>
</li>
<li><p>对File来说，封装的并不是一个真正存在的文件，仅仅是一个路径名。他可以存在也可以不存在将来是要通过具体操作来把这个路径的内容转化为具体存在的</p>
</li>
</ul>
<h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><table>
<thead>
<tr>
<th>File(String pathname)</th>
<th>通过给定的路径名字字符串转化为抽象路径名来创建新的File实例</th>
</tr>
</thead>
<tbody><tr>
<td>File(String path,String child)</td>
<td>从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td>File(File parent,String child)</td>
<td>从父抽象路径名和子路径名字符串创建新的File实例</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E\\ithema\\java.txt&quot;</span>);</span><br><span class="line">System.out.println(f1);<span class="comment">//输出E\\ithema\\java.txt</span></span><br><span class="line">File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E\\ithema&quot;</span>,<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">System.out.println(f2);<span class="comment">//输出E\\ithema\\java.txt</span></span><br><span class="line">File f3=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E\\ithema&quot;</span>);</span><br><span class="line">File f4=<span class="keyword">new</span> <span class="title class_">File</span>(f3,<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">System.out.println(f4);<span class="comment">//输出E\\ithema\\java.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h5><table>
<thead>
<tr>
<th>public boolean createNewFile()</th>
<th>当具有该名称的文件不存在时，创建一个有该抽象路径命名的新文件则返回true</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean mkdir()</td>
<td>创建由此抽象路径命名的目录</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>创建由此抽象路径命名的目录，包含任意必需但不存在的父目录</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E\\笔记\\java.txt&quot;</span>);<span class="comment">//创建文件，创建成功则返回true</span></span><br><span class="line">System.out.ptintln(f1.createNewFile());</span><br><span class="line">File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E\\笔记\\javase&quot;</span>);<span class="comment">//创建目录，创建成功则返回true</span></span><br><span class="line">System.out.ptintln(f2.mkdir());</span><br><span class="line">File f3=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E\\笔记\\javase\\hema&quot;</span>);</span><br><span class="line">System.out.ptintln(f3.mkdirs());<span class="comment">//一键创建多级目录，创建成功则返回true</span></span><br></pre></td></tr></table></figure>



<h5 id="File的判断和获取"><a href="#File的判断和获取" class="headerlink" title="File的判断和获取"></a>File的判断和获取</h5><table>
<thead>
<tr>
<th>public boolean isDirectory()</th>
<th>看此抽象路径名是否为目录</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isFile()</td>
<td>是否为文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>是否存在</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>返回绝对路径名字符串</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>转化为路径字符串</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回此抽象路径名表示的文件和目录</td>
</tr>
<tr>
<td>public String[] list()</td>
<td>返回此抽象路径名表示的文件和目录的名称的字符串数组</td>
</tr>
<tr>
<td>public File[] listFiles()</td>
<td>返回此抽象路径名表示的文件和目录的File对象数组</td>
</tr>
<tr>
<td>public boolean dalete()</td>
<td>删除此抽象路径表示的文件或目录，一步一步删除要先删除先删除文件</td>
</tr>
</tbody></table>
<p>绝对路径： 完整的路径名，不需要任何其他信息就可以定位</p>
<p>相对路径：必须借用其他路径的信息解释</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>不死神兔</p>
<p><strong>定义一个方法f(n)<strong>，</strong>表示第n个月兔子的对数</strong></p>
<p><strong>那么f(n-1</strong>)，<strong>表示第n-1个月的兔子对数</strong></p>
<p><strong>f(n-2),表示第n-2个月的兔子对数</strong></p>
<p><strong>再加一个出口</strong></p>
<p>递归的出口，且与原问题相似的规模较小的问题</p>
<h6 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">jc</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*jc(a-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240718105820499.png" alt="image-20240718105820499"></p>
<h6 id="用递归遍历该目录下的所有内容"><a href="#用递归遍历该目录下的所有内容" class="headerlink" title="用递归遍历该目录下的所有内容"></a>用递归遍历该目录下的所有内容</h6><p>思路：</p>
<ol>
<li><p>创建一个File对象</p>
</li>
<li><p>定义一个方法，用于获取目录下的所有内容参数为File</p>
</li>
<li><p>获取该目录下的所有文件或目录的File数组</p>
</li>
<li><p>遍历该数组，得到File对象</p>
</li>
<li><p>判断该File对象是否是目录</p>
<p>是递归调用</p>
<p>不是，获取绝对路径输出</p>
</li>
<li><p>调用方法</p>
</li>
</ol>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>InputStream:这个抽象类是表示字节输入流的所有类的超类</p>
<p>OutputStream:这个抽象类是表示字节输出流的所有类的超类</p>
<p>子类名都是以其父类名作为子类名的后缀</p>
<p>FileOutputStream:文件输出流用于将数据写入File</p>
<ul>
<li>FileOutputStream(String name):创建文件输出流以指定的写入文件</li>
<li>创建了字节输出流对象</li>
<li>调动字节输出流方法写入</li>
<li>释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;developing\\fos.txt&quot;</span>);</span><br><span class="line"><span class="comment">/*调用系统创建了文件</span></span><br><span class="line"><span class="comment">创建了字节输出流对象</span></span><br><span class="line"><span class="comment">让字节输出流对象指向文件*/</span></span><br><span class="line">fos.write(<span class="number">97</span>);<span class="comment">//在fos文件中写入a，用的是ASKMA值</span></span><br><span class="line">fos.close<span class="comment">//Io操作都要释放资源,关闭输出流并释放相关资源</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>void write(int b)</th>
<th>将字节写入文件输出流，一次一个字节数据</th>
</tr>
</thead>
<tbody><tr>
<td>void write(byte[] b)</td>
<td>将b.length字节从指定的字节数组写入此文件输出流，一次一个字节数组</td>
</tr>
<tr>
<td>void write(byte[] b,int off,int len)</td>
<td>从偏移量off开始写入此文件输出流写len个，一次写一个字节数组的部分数据</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;developing\\fos.txt&quot;</span>);</span><br><span class="line">fos.write(<span class="number">33</span>);</span><br><span class="line">fos.write(<span class="number">353</span>);</span><br><span class="line">fos.write(<span class="number">363</span>);</span><br><span class="line"><span class="type">byte</span>[] bys=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="type">byte</span>[] byy=<span class="string">&quot;abcd&quot;</span>.getBytes();<span class="comment">//和上面的那个写入的是一样的都是abcd</span></span><br><span class="line">fos.write(bys);</span><br><span class="line">fos.write(<span class="string">&quot;hellow&quot;</span>.getBytes());</span><br><span class="line">fos.write(bys,<span class="number">0</span>,bys.length);<span class="comment">//从0开始写入bys.length的字节</span></span><br><span class="line">fos.close();<span class="comment">//释放资源</span></span><br></pre></td></tr></table></figure>

<p>字节流换行：</p>
<p>window : \r\n</p>
<p>linux : \n</p>
<p>mac : \r</p>
<p>追加写入：</p>
<ul>
<li><p>public FileOutputStream(String name,boolean append)</p>
</li>
<li><p>创建文件输出流以指定的名称写入文件，若第二个参数为true则将写入文件的末尾而不是开头</p>
</li>
</ul>
<h5 id="字节流写数据加异常处理"><a href="#字节流写数据加异常处理" class="headerlink" title="字节流写数据加异常处理"></a>字节流写数据加异常处理</h5><p>finally:在异常处理事提供finally块来执行所有清除操作</p>
<p>finally语句一定执行，除非JVM退出</p>
<p>try{</p>
<p>可能出现异常的代码；</p>
<p>}catch(异常类名 变量名){</p>
<p>异常的处理代码；</p>
<p>}finally{执行所有清除操作；}</p>
<h5 id="字节流读数据"><a href="#字节流读数据" class="headerlink" title="字节流读数据"></a>字节流读数据</h5><p><strong>FileInputStream(String name)</strong>:  通过打开与实际文件的链接来创建一个FileInputStream,该文件由name命名</p>
<ul>
<li>创建了字节输入流对象</li>
<li>调动字节输入流方法写入</li>
<li>释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> by=fos.read();<span class="comment">//一次只能读一个字节的数据，输出的是ASCII值</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="type">char</span>(by));<span class="comment">//可以强制类型转换，若到达文件末尾值为-1；</span></span><br><span class="line"><span class="type">int</span> gby;</span><br><span class="line"><span class="keyword">while</span>((gny=fos.read())！=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>)gby);</span><br><span class="line">&#125;<span class="comment">//循环读取全部</span></span><br></pre></td></tr></table></figure>

<h5 id="复制文本文件"><a href="#复制文本文件" class="headerlink" title="复制文本文件"></a>复制文本文件</h5><p>就是把一个文件的内容从一个文件中读取出来（数据源），再写入另一个文件中（目的地）</p>
<p>思路：</p>
<ol>
<li>根据数据源创建字节输入流</li>
<li>根据目的地创建字节输出流</li>
<li>读写数据，复制文本（一次读一个字节，一次写一个字节）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;developing\\fos.txt&quot;</span>);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;begin\\fos.txt&quot;</span>);</span><br><span class="line"><span class="type">int</span> by;</span><br><span class="line"><span class="keyword">while</span>((by=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    fos.write(by);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>

<h5 id="读取一个字节数组"><a href="#读取一个字节数组" class="headerlink" title="读取一个字节数组"></a>读取一个字节数组</h5><p>int read(byte[] b):读取最多为b.length个字节的数据到一个字节数组，并返回实际读取到的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;developing\\fos.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] bys=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]<span class="comment">//1024及其整数倍</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(<span class="type">byte</span>))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">byte</span>,<span class="number">0</span>,len));<span class="comment">//转换成String</span></span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>

<h5 id="复制图片"><a href="#复制图片" class="headerlink" title="复制图片"></a>复制图片</h5><ol>
<li>根据数据源创建字节输入流</li>
<li>根据目的地创建字节输出流</li>
<li>读写数据，复制图片（一次读一个字节数组，一次写一个字节数组）</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;developing\\fos.txt&quot;</span>);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;begin\\fos.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] by=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(by))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    fos.write(by,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>

<h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><p>要导包</p>
<p>字节缓冲流：</p>
<ul>
<li>BufferOutputStream:  该类实现缓冲输出流，向底层输出流写入字节，不再调动底层系统</li>
<li>构造方法：BufferedOutputStream(OutputStream out)</li>
<li>BufferInputStream:  创建一个缓冲区，流可以从中读取字节，从而填充，一次可以很多字节</li>
<li>构造方法：BufferedInputStream(InputStream in)</li>
<li>字节缓冲流仅仅提供缓冲区，而真正读写数据还得依靠基本的字节流对象操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FileOutputStream fos=new FileOutputStream(&quot;begin\\fos.txt&quot;);</span></span><br><span class="line"><span class="comment">//BufferedOutputStream bos=new BufferedOutputStream(fos);</span></span><br><span class="line">BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;begin\\fos.txt&quot;</span>));<span class="comment">//上面两个二合一</span></span><br><span class="line">bos.write(<span class="string">&quot;hellow&quot;</span>.getBytes());</span><br><span class="line">BufferedInputStream fis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;begin\\fos.txt&quot;</span>));</span><br><span class="line"><span class="type">byte</span>[] by=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(by))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(by,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line">fis.close;</span><br><span class="line">bos.close;</span><br></pre></td></tr></table></figure>

<h5 id="复制视频"><a href="#复制视频" class="headerlink" title="复制视频"></a>复制视频</h5><ol>
<li>根据数据源创建字节输入流</li>
<li>根据目的地创建字节输出流</li>
<li>读写数据，复制图片（一次读一个字节数组，一次写一个字节数组）</li>
<li>释放资源</li>
</ol>
<p>分别使用四种方式实现，并记录时间</p>
<ol>
<li>基本字节流，一次读写一个字节       &#x2F;&#x2F;最慢</li>
<li>基本字节流，一次读写一个字节数组</li>
<li>字节缓冲流，一次读写一个字节</li>
<li>字节缓冲流，一次读写一个字节数    &#x2F;&#x2F;最快</li>
</ol>
<h4 id="字符流："><a href="#字符流：" class="headerlink" title="字符流："></a>字符流：</h4><p>字符流&#x3D;字节流+编码表</p>
<p>一个汉字存储：</p>
<p>如果是GBK编码，占用2个字节</p>
<p>如果是UTF-8编码，占用3个字节</p>
<p>第一个字节都是负数</p>
<h4 id="编码表："><a href="#编码表：" class="headerlink" title="编码表："></a>编码表：</h4><ul>
<li>计算机中的信息存储的使用二进制表示的，英文，汉字都是二进制转换而成的</li>
<li>将字符存储到计算机中，为编码。将存储在计算机的数解析显示出来，为解码</li>
</ul>
<p>字符编码是一套自然语言的字符与二进制数之间的对应规则（A,65)</p>
<p>字符集：</p>
<ul>
<li>是一个系统支持的所有字符的集合，包括各个国家的文字，标点，图形，数字等</li>
<li>计算机要准确的存储和识别各种字符集，就要进行字符编码，一套字符集必有一套编码。常见的字符集有ASCII字符集，GBXXX字符集,Unicode字符集</li>
</ul>
<h5 id="ASCII字符集："><a href="#ASCII字符集：" class="headerlink" title="ASCII字符集："></a>ASCII字符集：</h5><p>是美国为英文和各种符号，进退等编写的</p>
<h5 id="GBXXX字符集"><a href="#GBXXX字符集" class="headerlink" title="GBXXX字符集"></a>GBXXX字符集</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240718201314000.png" alt="image-20240718201314000"></p>
<h5 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h5><p>UTF-8编码</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240718201656694.png" alt="image-20240718201656694"></p>
<h5 id="字符串中编码解码"><a href="#字符串中编码解码" class="headerlink" title="字符串中编码解码"></a>字符串中编码解码</h5><p>编码：</p>
<p>byte[] getBytes():使用平台默认的字符集编码</p>
<p>byte[] getBytes(String charsetName):使用指定的字符集编码</p>
<p>String(byte[] byte):使用平台默认的字符集解码，指定的字节数组来郭建新的String</p>
<p>String(byte[] byte，String charsetName):使用指定的字符集解码</p>
<p>字符流抽象基类</p>
<ul>
<li>Reader ：字符输入流的抽象类</li>
<li>Wreter ：字符输出流的抽象类</li>
</ul>
<p>字符流中和编码解码相关的类：</p>
<ul>
<li>InputStreamReader:是从字节流到字符流的桥梁（先读再编，可指定）</li>
<li>InputStreamReader fis&#x3D;new InputStreamReader(new FileInputStream(“developing\ows.txt”))</li>
<li>OutputStreamWriter：是从字符流到字节流的桥梁（先读再编，可指定）</li>
<li>OutputStreamReader fos&#x3D;new OutputStreamReader(new FileOutputStream(“developing\ows.txt”))</li>
</ul>
<h5 id="写读数据"><a href="#写读数据" class="headerlink" title="写读数据"></a>写读数据</h5><table>
<thead>
<tr>
<th>void write(int c)</th>
<th>写一个字符</th>
</tr>
</thead>
<tbody><tr>
<td>void write(char[] cbuf)</td>
<td>写一个字符数组</td>
</tr>
<tr>
<td>void write(char[] cbuf,int off,int len)</td>
<td>写入字符数组的一部分</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>写一个字符串</td>
</tr>
<tr>
<td>void write(String str,int off,int len)</td>
<td>写一个字符串的一部分</td>
</tr>
</tbody></table>
<p>字符流有缓冲要刷新，flush()刷新，close()是先刷新再关闭 </p>
<table>
<thead>
<tr>
<th>int read()</th>
<th>一次读一个字符数据</th>
</tr>
</thead>
<tbody><tr>
<td>int read(char[] cbuf)</td>
<td>一次读一个字符数组数据</td>
</tr>
</tbody></table>
<h6 id="复制java文件"><a href="#复制java文件" class="headerlink" title="复制java文件"></a>复制java文件</h6><ol>
<li>根据数据源创建字符输入流</li>
<li>根据目的地创建字符输出流</li>
<li>读写数据，复制文本（一次读一个字符，一次写一个字符）</li>
<li>可以简化InputStreamReader，OutputStreamReader</li>
<li>FileReader(String fileName):用于读取字符文件的便捷类</li>
<li>FileWriter(String FileName)；用于写入文件的便捷类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InputStreamReader fis=new InputStreamReader(new FileInputStream(&quot;developing\\ows.txt&quot;))//根据数据源创建字符输入流</span></span><br><span class="line">FileReader fis=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;developing\\ows.txt&quot;</span>)</span><br><span class="line"><span class="comment">//OutputStreamReader fos=new OutputStreamReader(new FileOutputStream(&quot;developing\\ows.txt&quot;))//根据目的地创建字符输出流</span></span><br><span class="line">FileWriter fos=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;developing\\ows.txt&quot;</span>)  </span><br><span class="line"><span class="type">char</span>[] ch=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(ch))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    fos.<span class="keyword">while</span>(ch,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>

<h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><p>BufferedWriter:将文本写入字符输出流，缓冲字符，可指定缓冲区大小，也可默认</p>
<p>BufferedWriter(Writer out);</p>
<p>BufferedReader:从字符输入流读取文本，可指定缓冲区的大小，也可默认</p>
<p>BufferedReader(Reader in)</p>
<p>BufferedWriter bw&#x3D;new BufferedWriter(new FileWriter(“”));</p>
<h6 id="复制java文件（字符缓冲流）"><a href="#复制java文件（字符缓冲流）" class="headerlink" title="复制java文件（字符缓冲流）"></a>复制java文件（字符缓冲流）</h6><ol>
<li>根据数据源创建字符缓冲输入流</li>
<li>根据目的地创建字符缓冲输出流</li>
<li>读写数据，复制文本（一次读一个字符，一次写一个字符）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BuffererdWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;developing\\ows.txt&quot;</span>));</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BuffereReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;developing\\ows.txt&quot;</span>)) ;  <span class="type">char</span>[] ch=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=br.read(ch))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    bw.<span class="keyword">while</span>(ch,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">bw.close();</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>viod newLine()</th>
<th>写一行行分隔符，分隔符有系统定义</th>
</tr>
</thead>
<tbody><tr>
<td>public String readLine()</td>
<td>读一行文字，结果包含行的内容的字符串，不包括任何终止字符，若到达末尾则为null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BuffererdWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;developing\\ows.txt&quot;</span>));</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BuffereReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;developing\\ows.txt&quot;</span>)) ; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">bw.write(<span class="string">&quot;hellow&quot;</span>+<span class="number">1</span>);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.flush();&#125;</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">bw.close();</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>

<h4 id="Io流小结"><a href="#Io流小结" class="headerlink" title="Io流小结"></a>Io流小结</h4><h5 id="字节流小结"><a href="#字节流小结" class="headerlink" title="字节流小结"></a>字节流小结</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240719081409233.png" alt="image-20240719081409233"></p>
<h5 id="字符流小结"><a href="#字符流小结" class="headerlink" title="字符流小结"></a>字符流小结</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240719081610554.png" alt="image-20240719081610554"></p>
<h6 id="把集合中的数据写入文件"><a href="#把集合中的数据写入文件" class="headerlink" title="把集合中的数据写入文件"></a>把集合中的数据写入文件</h6><p>要求：每一个字符串元素作为文件的一行元素</p>
<p>思路：</p>
<ol>
<li>创建ArrayList集合</li>
<li>往集合中存储字符串元素</li>
<li>创建字符缓冲输出流对象</li>
<li>遍历集合，得到每一个字符串数据</li>
<li>调用字符缓冲输出流对象的方法写数据</li>
<li>释放资源</li>
</ol>
<h6 id="把文件中的数据读到集合中"><a href="#把文件中的数据读到集合中" class="headerlink" title="把文件中的数据读到集合中"></a>把文件中的数据读到集合中</h6><ol>
<li>创建字符缓冲输入流对象</li>
<li>创建ArrayList集合</li>
<li>调用字符缓冲输入流对象的方法读数据</li>
<li>那读取的数据存储的到集合中</li>
<li>释放资源</li>
<li>遍历集合</li>
</ol>
<h6 id="点名器"><a href="#点名器" class="headerlink" title="点名器"></a>点名器</h6><p>有一个文件存储了同学的名字，每个姓名占一行，要求实现点名器</p>
<ol>
<li>创建字符缓冲输入流对象</li>
<li>创建ArrayList集合</li>
<li>调用字符缓冲输入流对象的方法读数据</li>
<li>把独到的数据存储到集合中</li>
<li>释放资源</li>
<li>使用Random产生一个随机数范围在【0，集合长度）</li>
<li>把第6产生的的随机数的作为索引获取值</li>
<li>输出数据</li>
</ol>
<h6 id="把集合中的数据写入文件-1"><a href="#把集合中的数据写入文件-1" class="headerlink" title="把集合中的数据写入文件"></a>把集合中的数据写入文件</h6><p>要求：每一个学生对象数据作为文件的一行元素</p>
<p>思路：</p>
<ol>
<li>定义学生类</li>
<li>创建ArrayList集合</li>
<li>创建学生对象</li>
<li>把学生对象添加到集合中</li>
<li>创建字符缓冲输出流对象</li>
<li>遍历集合，得到每一个学生对象</li>
<li>把学生对象拼接成指定格式的字符串</li>
<li>调用字符缓冲输出流对象的方法写数据</li>
<li>释放资源</li>
</ol>
<h6 id="把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值"><a href="#把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值" class="headerlink" title="把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值"></a>把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值</h6><ol>
<li>定义学生类</li>
<li>创建字符缓冲输入流对象</li>
<li>创建ArrayList集合</li>
<li>调用字符缓冲输入流对象的方法读数据</li>
<li>把读到的数据用split()进行分割，得到一个字符串数组</li>
<li>创建学生对象</li>
<li>字符串数组中的每一个元素取出对应的赋值给学生对象的成员变量值</li>
<li>把学生对象添加到集合中</li>
<li>释放资源</li>
<li>遍历集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BuffereReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;developing\\ows.txt&quot;</span>)) ; </span><br><span class="line">ArrayList&lt;student&gt; array=<span class="keyword">new</span> <span class="title class_">Array</span>&lt;student&gt;();</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">    String[] strArray=line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">s.setSid(strArray[<span class="number">0</span>]);</span><br><span class="line">s.setName(strArray[<span class="number">1</span>]);</span><br><span class="line">s.setAge(Integer.parseInt(strArray[<span class="number">2</span>]));</span><br><span class="line">s.setAddress(strArray[<span class="number">3</span>]);</span><br><span class="line">array.add(s)&#125;</span><br><span class="line">br.colse();</span><br><span class="line"><span class="keyword">for</span>(student s:array)&#123;</span><br><span class="line">  System.out.println(s.getSid()+<span class="string">&quot;,&quot;</span>+s.getName+<span class="string">&quot;,&quot;</span>+s.getAge+<span class="string">&quot;,&quot;</span>+s.getAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="集合到文件"><a href="#集合到文件" class="headerlink" title="集合到文件"></a>集合到文件</h6><p>键盘录入5个学生信息（姓名，语文成绩，数学成绩，英语成绩）要去按照成绩总分从高到低写入文件</p>
<ol>
<li>定义学生类</li>
<li>创建TreeSett集合，通过比较器比较</li>
<li>键盘录入学生信息</li>
<li>创建学生对象，把信息赋值到学生变量中</li>
<li>把学生对象添加到集合中</li>
<li>创建字符缓冲输出流对象</li>
<li>遍历集合，得到每一个学生对象</li>
<li>把学生对象拼接成指定格式的字符串</li>
<li>调用字符缓冲输出流对象的方法写数据</li>
<li>释放资源</li>
</ol>
<h5 id="复制单级文件夹"><a href="#复制单级文件夹" class="headerlink" title="复制单级文件夹"></a>复制单级文件夹</h5><ol>
<li>创建数据源目录File对象，路径是E:\itcast</li>
<li>获取数据源目录File的名称(itcast)</li>
<li>创建目的地目录File对象，路径名是模块名+itcast组成</li>
<li>判断目的地对应的File是否存在，不存在就创建</li>
<li>获取数据源目录下的所有文件的File数组</li>
<li>遍历File数组，得到每一个File对象，该对象就是数据源文件</li>
<li>获取数据源文件的名称</li>
<li>创建目的地文件File对象，路径名是目的地目录+数据源对象名称组成</li>
<li>复制文件用字节流不光文件还有视频</li>
</ol>
<h5 id="复制多级文件夹"><a href="#复制多级文件夹" class="headerlink" title="复制多级文件夹"></a>复制多级文件夹</h5><ol>
<li><p>创建数据源File对象，路径是E:\itcast</p>
</li>
<li><p>创建目的地File对象，路径是F:\</p>
</li>
<li><p>写方法实现文件夹的复制，参数为数据源Flie对象和目的地File对象</p>
</li>
<li><p>判断数据源Fila是否是目录</p>
<p>是</p>
<p>在目的地下创建和数据源File名称一样的目录</p>
<p>获得数据源File下所有文件或目录File数组</p>
<p>遍历该File数组，得到每一个File对象</p>
<p>把该File作为数据源File对象，递归调用复制文件夹的方法</p>
<p>不是：直接复制</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">srcFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\笔记&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">desFile</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\&quot;</span>);</span><br><span class="line">        copyFilder(srcFile,desFile);&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFilder</span><span class="params">(File srcFile,File desFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span>(srcFile.isDirectory())&#123;</span><br><span class="line">                String srcFileName=srcFile.getName();</span><br><span class="line">                <span class="type">File</span> <span class="variable">newFolder</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(desFile,srcFileName);</span><br><span class="line">                <span class="keyword">if</span>(!newFolder.exists())&#123;</span><br><span class="line">                    newFolder.mkdir();</span><br><span class="line">                &#125;</span><br><span class="line">                File[] fileArray = srcFile.listFiles();</span><br><span class="line">                <span class="keyword">for</span>(File file:fileArray)&#123;</span><br><span class="line">                    copyFilder(file,newFolder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(desFile,srcFile.getName());</span><br><span class="line">                copyFile(srcFile,newFile);</span><br><span class="line">            &#125;   &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">( File srcFile,File desFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            BufferedOutputStream fos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(desFile));<span class="comment">//上面两个二合一</span></span><br><span class="line">            BufferedInputStream fis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile));</span><br><span class="line">            <span class="type">byte</span>[] str=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len=fis.read(str))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(str,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            fos.close();</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复制文件的异常处理"><a href="#复制文件的异常处理" class="headerlink" title="复制文件的异常处理"></a>复制文件的异常处理</h4><p><strong>之前的：</strong></p>
<p>try{</p>
<p>可能出现异常的代码；</p>
<p>}catch(异常类名 变量名){</p>
<p>异常的处理代码；</p>
<p>}finally{执行所有清除操作；}</p>
<p><strong>JDK7的改进：不用抛异常</strong></p>
<p>try(定义流对象){</p>
<p>可能出现异常的代码；}</p>
<p>catch(异常类名 变量名){</p>
<p>异常的处理代码；}</p>
<p><strong>JDK9的改进：要抛出异常</strong></p>
<p>定义输出流对象；</p>
<p>定义输入流对象；</p>
<p>try(输入流对象；输出流对象){</p>
<p>可能出现异常的代码；}</p>
<p>catch(异常类名 变量名){</p>
<p>异常的处理代码；}</p>
<h2 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h2><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><ul>
<li><p>public static final InputStream in:标准输入流。通常该流对应于键盘输入或主机环境或用户指定 的另一个输入源</p>
</li>
<li><p>public static final PrintStream out:标准输出流。通常该流对应于显示输出或主机环境或用户指定的另一个输出目标</p>
</li>
<li><p><strong>标准输入流 System.in</strong></p>
</li>
<li><p>自己实现键盘录入数据：</p>
<p>BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(System.in));</p>
</li>
<li><p>这么写太麻烦，java就提供了一个实现键盘录入</p>
</li>
<li><p>Scanner sc&#x3D;new Scanner(System.in);</p>
</li>
<li><p><strong>标准输出流  :System.out</strong></p>
</li>
<li><p>能够方便的打印各种值</p>
</li>
<li><p>System.out.println();本质是一个标准的输出流</p>
</li>
<li><p>PrintStream ps&#x3D;System.out;</p>
</li>
<li><p>PrintStream类特有的方法，System.out都可以使用</p>
</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><p>分类：</p>
<p>字节打印流</p>
<p>字符打印流</p>
<p>特点：</p>
<p>只输出数据不读取数据，有自己的特有方法</p>
<h5 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流:"></a>字节打印流:</h5><ul>
<li>PrintStream(String FileName):使用指定文件名创建新的打印流对象</li>
<li>使用继承父类的方法写数据的时候会转码(ps.write())  ,使用自己特有的方法写数据原样输出(ps.print(33);ps.println();)</li>
</ul>
<h5 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流:"></a>字符打印流:</h5><table>
<thead>
<tr>
<th>PrintWriter(String fileName)</th>
<th>使用指定的文件名创建一个新的PrintWriter,而不需要刷新</th>
</tr>
</thead>
<tbody><tr>
<td>PrintWriter(write out,boolean autoFlush)</td>
<td>创建一个新的PrintWrite  ,out:字符输出流   ，autoFlush:一个布尔值，为真则println,printf或format方法刷新缓冲区</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter pw=<span class="keyword">new</span> <span class="title class_">printWriter</span>(<span class="string">&quot;develop\\pw.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">pw.println(<span class="string">&quot;hellow&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure>

<h6 id="复制java文件（用打印流）"><a href="#复制java文件（用打印流）" class="headerlink" title="复制java文件（用打印流）"></a>复制java文件（用打印流）</h6><ol>
<li>根据数据源创建字符缓冲输入流</li>
<li>根据目的地创建字符打印流</li>
<li>读写数据，复制文本（一次读一个字符，一次写一个字符）</li>
</ol>
<h3 id="对象序列化流"><a href="#对象序列化流" class="headerlink" title="对象序列化流"></a>对象序列化流</h3><p>对象序列化：就是将对象保存到磁盘中，或在网络中传输对象</p>
<p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型，对象的数据和对象中存储的属性等信息</p>
<ul>
<li>对象序列化流：ObjectOutputStream</li>
<li>对象反序列化流：ObjictInputStrream</li>
</ul>
<h5 id="对象序列化流：ObjectOutputStream"><a href="#对象序列化流：ObjectOutputStream" class="headerlink" title="对象序列化流：ObjectOutputStream"></a>对象序列化流：ObjectOutputStream</h5><ul>
<li>将Java对象的原始数据类型和图形写入OutputStream.可以通过使用流的文件来实现对象的长时间保存，若流是网络套接字流，则可以在另一个主机或另一个进程中重构对象</li>
<li>构造方法：OutputStream（OutputSream out)</li>
<li>序列化对象的方法：void writeObject(Object obj):将其写入OutputStream</li>
<li>一个对象要实现序列化，该对象所属的类必须实现Serializable接口，Serializable接口是一个标记接口，不用重写方法</li>
</ul>
<h5 id="对象反序列化流：ObjictInputStrream"><a href="#对象反序列化流：ObjictInputStrream" class="headerlink" title="对象反序列化流：ObjictInputStrream"></a>对象反序列化流：ObjictInputStrream</h5><ul>
<li>ObjictInputStrream反序列化先前使用的bjectOutputStream编写的原始数据和对象</li>
<li>构造方法：ObjictInputStrream（InputStrream in）</li>
<li>Objict readObject():从ObjictInputStrream中读取一个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> throwsIOException,ClassNotFoundException&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>()) ;</span><br><span class="line">    Object obj=ois.readObject();</span><br><span class="line">    student s= (student) obj;</span><br><span class="line">    System.out.println(s.getName()+<span class="string">&quot;,&quot;</span>+s.getAge())</span><br><span class="line">        ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用对象序列化了一个对象后，修改了对象所属的类文件，若不加serialersionUID会报错</p>
<p>private static final long serialVersionUID&#x3D;42L;</p>
<p>如果一个对象的某个成员变量不想被序列化，要给该成员加transient关键字修饰，该关键字标记的成员变量不参与序列化过程</p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><ul>
<li>是一个Map体系的集合类</li>
<li>Properties可以保存到流中或从流中加载</li>
<li>ProPerties prop &#x3D; new Properties();默认使用Object</li>
</ul>
<table>
<thead>
<tr>
<th>Object setProperty(String key,String value)</th>
<th>设置集合的键和值，都是String类型的，底层调用Hashable方法 put</th>
</tr>
</thead>
<tbody><tr>
<td>String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性</td>
</tr>
<tr>
<td>Set<String> stringPropertyNames()</td>
<td>从属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</td>
</tr>
</tbody></table>
<p>ProPerties与Io流结合的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void load(InputStream inStream)</td>
<td>从输入字节流<strong>读取数据列表</strong>（键和元素对）</td>
</tr>
<tr>
<td>void load(Reader reader)</td>
<td>从输入字符流<strong>读取属性列表</strong>（键和元素对）</td>
</tr>
<tr>
<td>void store(OutputStream out,String comments)</td>
<td>将此属性列表（键和元素对）写入此ProPerties表中，以适合与使用load(InputStream)方法的格式<strong>写入输出字节流</strong></td>
</tr>
<tr>
<td>void store(Write write,String comments)</td>
<td>将此属性列表（键和元素对）写入此ProPerties表中，以适合与使用load(InputStream)方法的格式<strong>写入输出字符流</strong></td>
</tr>
</tbody></table>
<h6 id="游戏次数"><a href="#游戏次数" class="headerlink" title="游戏次数"></a>游戏次数</h6><p>需求：请写一个猜数字小游戏只能玩三次，若还想玩请充值</p>
<p>思路：</p>
<ol>
<li><p>写一个游戏类，里有一个猜数字小游戏</p>
</li>
<li><p>写一个测试类，测试类中有main()方法</p>
<p>A:从文件中读取到Properties集合，用load方法实现</p>
<p>​    文件已经存在：game.txt</p>
<p>​    里面有一个数据值：count&#x3D;0;</p>
<p>B:通过Properties集合获取到玩游戏的次数</p>
<p>C：判断次数是否到达3次，</p>
<p>  到了给提示</p>
<p>  不到：</p>
<p>​       玩游戏，次数加1，重回写回文件，用Properties的store()方法实现</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\Java\\study\\basis\\练习\\developing\\src\\Gather\\game.txt&quot;</span>);</span><br><span class="line">        prop.load(fr);</span><br><span class="line">        fr.close();</span><br><span class="line">        <span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> prop.getProperty(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ww=Integer.parseInt(w);</span><br><span class="line">        <span class="keyword">if</span>(ww&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;游戏次数不够请充值，(www.platgame)&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            playgame.guess();</span><br><span class="line">            ww++;</span><br><span class="line">            FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;E:\\Java\\study\\basis\\练习\\developing\\src\\Gather\\game.txt&quot;</span>);</span><br><span class="line">            prop.setProperty(<span class="string">&quot;count&quot;</span>,String.valueOf(ww));</span><br><span class="line">            prop.store(fw,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>是正在运行的程序</p>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>是进程中的单个顺序控制流，是一条执行路径</p>
<ul>
<li>单线程：一个进程只有一条执行路径</li>
<li>多线程：一个进程有多条执行路径</li>
</ul>
<h4 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h4><p>方式1：继承Thread类</p>
<ul>
<li>定义一个类MyThread继承Thread类</li>
<li>在MyThread类中重写run()方法</li>
<li>创建MYThread类的对象</li>
<li>start()方法启动线程</li>
</ul>
<p>run()方法是u用来封装被执行线性程序的代码</p>
<p>run():封装线性执行程序，直接调用相当于普通方法调用</p>
<p>start():启动线程；由JVM调用此线程的run()方法</p>
<p>设置和获取线程名称的方法</p>
<ul>
<li>void setName(String name): 更改线程名称</li>
<li>String getName():得到线程名称</li>
<li>构造方法：在自定类中提供带参构造方法,super(name)</li>
</ul>
<p>获取main()方法的线程名称：</p>
<p>public static Thread currentThread()：返回对当前正在执行的线程对象的引用</p>
<p>再获取线程名称</p>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><ul>
<li>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用的CPU时间</li>
<li>抢占式调度模型：优先让优先级高的现线程使用CPU，若优先级相同，则随机选择，优先级高的CPU获取的CPU时间片相对长</li>
<li>java使用的是抢占式调度模型</li>
</ul>
<p>假设计算机只有一个CPU,那么CPU在某一个时刻只能执行一天指令。所以说多线程程序的执行具有随机性</p>
<p>Thread类中设置和获取线程优先级的方法：</p>
<ul>
<li><p>public final int getPriority():返回此线程的优先级</p>
</li>
<li><p>public final void setPriority(int newPriority):更改此线程的优先级</p>
<p>线程默认优先级是5；范围是1~10</p>
<p>线程优先级高只表示线程获取CPU的时间片几率高，但是要在次数比较多，或多次运行的时候才能看到你想要的结果</p>
</li>
</ul>
<h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><table>
<thead>
<tr>
<th>static void sleep(long millis)</th>
<th>使当前正在执行的线程停留（暂停执行）指定的毫秒数</th>
</tr>
</thead>
<tbody><tr>
<td>void join()</td>
<td>等待这个线程死亡</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程，当运行的线程都是守护线程是java虚拟机将退出，随主线程的退出而停止</td>
</tr>
</tbody></table>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720084108566.png" alt="image-20240720084108566"></p>
<p><strong>若有程序在主函数中先运行主函数最后运行run()线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;关羽&quot;</span>);</span><br><span class="line"><span class="comment">//        mt.start();</span></span><br><span class="line"><span class="comment">//        mn.start();</span></span><br><span class="line">        mt.setName(<span class="string">&quot;野蛮&quot;</span>);</span><br><span class="line">        mn.setName(<span class="string">&quot;武圣&quot;</span>);</span><br><span class="line">        mn.setPriority(<span class="number">9</span>);</span><br><span class="line">        mn.start();</span><br><span class="line">        mt.start();</span><br><span class="line">        System.out.println(mt.getPriority());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="多线程的实现方式-1"><a href="#多线程的实现方式-1" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h4><p>方式2：实现Runnable接口</p>
<ol>
<li>定义一个类MyRunnable实现Runnable接口</li>
<li>在MyRunnable类中重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li>
<li>启动线程</li>
</ol>
<p>好处：</p>
<ul>
<li>避免了java单继承的局限性</li>
<li>适合多高相同的程序的代码区处理同一个资源的情况，把线程和程序的代码，数据有效分离，较好的体现离面向对象的设计思想</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MtRunnable my=<span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;高铁&quot;</span>)；<span class="comment">//构造方法：Runnable的实现子类和线程的名称</span></span><br><span class="line">Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">t1,start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<h6 id="卖票"><a href="#卖票" class="headerlink" title="卖票"></a>卖票</h6><p>有三个窗口卖票，共有100张票</p>
<ol>
<li><p>定义一个类SelllTicket实现Runnable接口，里面定义一个成员变量：private int tickets&#x3D;100;</p>
</li>
<li><p>在SellTicket类中重写run()方法实现卖票，并告知是那个窗口卖的</p>
<p>A：判断票数打印0，就卖票，并告知那个窗口卖的，每次出票的时间为0.1秒</p>
<p>B：卖票之后，中票数减1</p>
<p>C：票没有了，也可能有人来问，故让卖票的动作一直执行</p>
</li>
<li><p>定义一个测试类SellTicktDemo,里面有main方法</p>
<p>A:创建SellTicket类的对象</p>
<p>B:创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</p>
<p>C:启动线程</p>
</li>
</ol>
<p>相同的票出现了多次：当t1线程抢到的CPU之后要休息0.1秒，之后t2线程重复</p>
<p>线程执行的随机性：当第一个语句执行完后，第2个语句可能会被别的线程抢占</p>
<p>多线程的数据安全问题：</p>
<ul>
<li>多线程环境</li>
<li>共享数据</li>
<li>多条语句操作共享数据</li>
</ul>
<p>解决安全问题：</p>
<p>让程序没有安全数据环境</p>
<p>把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行，java提供了同步代码块的方式来解决</p>
<p>格式：</p>
<ul>
<li>synchronized(任意对象){</li>
<li>多条语句操作共享数据的代码}</li>
<li>synchronized(任意对象)：就相当于给代码加上了锁，任意对象可以看成是一把锁</li>
</ul>
<p>好处：解决了多线程的数据安全问题</p>
<p>弊端：但线程衡多是，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</p>
<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>就是把synchronized加到方法上</p>
<ul>
<li>格式：</li>
<li>修饰符 synchronized 返回值类型 方法名（方法参数）{}</li>
<li>同步方法的锁对象是：  this</li>
</ul>
<p>同步静态方法：就是把synchronized关键字加到静态方法上</p>
<ul>
<li>格式：</li>
<li>修饰符 static synchronized 放回值类型 方法名（方法参数）{}</li>
<li>同步静态方法的锁对象是： 类名.class</li>
</ul>
<h4 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h4><p>StringBUffer:</p>
<p>Vector:</p>
<p>Hashtable:</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720102511486.png" alt="image-20240720102511486"></p>
<p>可以使用Collections.synchronizedList(List<T> list)返回指定列表支持的同步列表</p>
<p>List<String> list &#x3D; Collections.synchronizedList(new Arraylist<String>());</p>
<p>将线程不安全类变成线程安全类</p>
<h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p>是接口，是一个锁对象</p>
<p>提供比使用synchronized方法和语句更广泛的锁定操作</p>
<ul>
<li>void lock():获得锁</li>
<li>void unlock():释放锁</li>
</ul>
<p>Lock是接口不能直接实例化，这里才用实现类ReentrantLock来实例化</p>
<ul>
<li>ReentantLock():创建一个ReentrantLock的实例</li>
</ul>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><h5 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h5><p>省常中消费者模式是一个十分经典的多线程协助的模式</p>
<p>有2个线程：</p>
<ul>
<li>一个是生产者线程用于生产数据</li>
<li>一列是消费者线程用于消费数据</li>
</ul>
<p>为解耦生产者和消费者的关系，通常会在用共享的数据区域</p>
<ul>
<li>生产者生产数据之后直接凡在共享数据区域中，并不关心消费者的行为</li>
<li>消费者中需要从共享数据区域中去获取数据，并不关心生产者的行为</li>
</ul>
<p>Object类的等待和唤醒方法</p>
<table>
<thead>
<tr>
<th>void wait()</th>
<th>倒着当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</th>
</tr>
</thead>
<tbody><tr>
<td>void noify()</td>
<td>唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td>voidnotifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody></table>
<h6 id="奶箱类生产者与消费者"><a href="#奶箱类生产者与消费者" class="headerlink" title="奶箱类生产者与消费者"></a>奶箱类生产者与消费者</h6><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720105851313.png" alt="image-20240720105851313"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><p>计算机网络：将不同的独立的多台计算机及其外部设备，通过通信路线连接起来，在饿忘了操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息换的的计算机系统</p>
<p>网路编程：在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以实现数据交换</p>
<h5 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h5><ol>
<li>IP地址：为网络中的计算机指定一个标识号，通过标识号来指定要接收的计算机和识别发送的计算机，IP就是这个标识号</li>
<li>端口：端口号就是唯一标识设备中的应用程序的，是应用程序的标识</li>
<li>协议：网络规定 UDP协议和TCP协议</li>
</ol>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720120016831.png" alt="image-20240720120016831"></p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IPv4：是给连接在网络的主机分配的一个32bit地址，为4个字节</p>
<p>IPv6:每16个字节为一组，分成8组16进制数，128为地址长度</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720142350657.png" alt="image-20240720142350657"></p>
<p>命令：</p>
<ul>
<li>ipconfig:查看本机IP地址</li>
<li>ping IP地址：检查网络是否联通</li>
</ul>
<p>特殊IP地址：</p>
<p>127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用</p>
<h4 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h4><p>InetAddress:此类表示Internet协议(IP)地址</p>
<table>
<thead>
<tr>
<th>static InetAddress grtByName(String host)</th>
<th>确定直接名称的IP地址，主机名称可以是机器名称，也可以是IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>String getHostName()</td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td>String getHostAddress()</td>
<td>返回文本显示中的IP地址字符串</td>
</tr>
</tbody></table>
<h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><p>端口：设备上应用程序的唯一标识</p>
<p>端口号：用两个字节表示的整数，它的取值范围是0<del>65535.起重工0</del>1023之间的端口号用于一些知名的网路服务和应用，若端口号被另一个服务或应用所占用，会导致当前程序启动失败</p>
<h5 id="协议："><a href="#协议：" class="headerlink" title="协议："></a>协议：</h5><p>UDP协议：消耗资源小，通信效率高，但不确定接收端是否存在</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720154915128.png" alt="image-20240720154915128"></p>
<p>TCP协议：建立连接在传输数据，保证了数据传输的安全</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720155111982.png" alt="image-20240720155111982"></p>
<h3 id="UPD通信原理"><a href="#UPD通信原理" class="headerlink" title="UPD通信原理"></a>UPD通信原理</h3><p>是一种不可靠的网络协议，它在两端建立一个Socket对象，Socket只是发送，每有客户端和服务器的概念</p>
<h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><ol>
<li><p>创建发送端的Socket对象(DatagramSocket)</p>
<p>DatagramSocket()</p>
</li>
<li><p>创建数据，并把数据打包</p>
<p>DatagramPacket(byte[] buf,int length,InetAddress address,int port)</p>
</li>
<li><p>调用DatagramSocket对象的方法发送数据</p>
<p>void send(DatagramPacket p)</p>
</li>
<li><p>关闭发送端</p>
<p>void close()</p>
</li>
</ol>
<h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><ol>
<li><p>创建接收端的Socket对象(DatagramSocket)</p>
<p>DatagramSocket(int port)</p>
</li>
<li><p>创建一个数据包，用于接收数据</p>
<p>DatagramPacket(byte[] buf,int length)</p>
</li>
<li><p>调用DatagramSocket对象的方法接收数据</p>
<p>void receive(DategramPacket p)</p>
</li>
<li><p>解下数据包，并包数据在控制台上显示</p>
<p>byte[] getDate()</p>
<p>int getLength()</p>
</li>
<li><p>关闭接收端</p>
<p>void.close()</p>
</li>
</ol>
<h4 id="TCP通信原理"><a href="#TCP通信原理" class="headerlink" title="TCP通信原理"></a>TCP通信原理</h4><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720172738749.png" alt="image-20240720172738749"></p>
<p>步骤：</p>
<ol>
<li><p>创建客户端的Socket对象(Socket)</p>
<p>Socket(String host,int port)</p>
</li>
<li><p>获取输出流，写数据</p>
<p>OutputStream getOutputStream()</p>
</li>
<li><p>释放资源</p>
<p>void close()</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket s=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;192.168.2.93&quot;</span>,<span class="number">30006</span>)</span><br><span class="line">    </span><br><span class="line">    OutputStream os=s.getOutputStream();</span><br><span class="line">os.write(<span class="string">&quot;hellow,wrold,&quot;</span>.getBytes())</span><br><span class="line">    s.close();</span><br></pre></td></tr></table></figure>

<p>要进行三次握手</p>
<p>TCP接收数据</p>
<ol>
<li>创建服务器端的Socket对象(ServerSocket)</li>
<li>获取输入流，读数据，并把数据显示在控制台</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket ss= newServerSocket;</span><br><span class="line">Socket s=ss.accept();</span><br><span class="line">InputStream is==s.getInputStream();</span><br><span class="line">btte[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len=ia.read(bys);</span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> newString(bts,<span class="number">0</span>,len);</span><br><span class="line">System.out.println(<span class="string">&quot;数据是：&quot;</span>+data);</span><br><span class="line">s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure>

<p>客户端：发送数据，接收服务器反馈，数据来自着键盘录入，知道输入的数据是886，发送数据接收</p>
<p>服务器：接收到的数据在控制台输出，并写进文本文档</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;192.168.2.93&quot;</span>,<span class="number">30002</span>)</span><br><span class="line"><span class="type">BuuferReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine()！=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(line))&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWreite</span>(<span class="keyword">new</span> <span class="title class_">OutputStream</span>(s.getOutputStream()));</span><br><span class="line">    bw.write(line);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.flush();</span><br><span class="line">    s.close();</span><br><span class="line">    bw.close();</span><br><span class="line">    bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SreverSocket ss=<span class="keyword">new</span> <span class="title class_">SeverSocket</span>(<span class="number">30002</span>);</span><br><span class="line">Socket s=ss.accept();</span><br><span class="line">BufferdReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(New <span class="title function_">inputStreamReader</span><span class="params">(s.getInputStream()</span>));</span><br><span class="line">BufferedWrite bw=<span class="keyword">new</span> <span class="title class_">BufferedWrite</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;&quot;</span>))\\路径</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = br.readline())!=<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">    bw.write(line);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.flush();</span><br><span class="line">&#125;</span><br><span class="line">BufferedWrite bwSeret=<span class="keyword">new</span> <span class="title class_">BufferdWrite</span></span><br><span class="line">ss.close();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>

<h6 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a>练习5</h6><p>客户端：数据来着文本，接受服务器反馈</p>
<p>服务器：接收到的数据写入文本，给出反馈</p>
<p>出现问题：程序一直等待</p>
<p>原因：读数据的方法是阻塞式的</p>
<p>解决：自定义结束标志；使用shutdownOutput()方法</p>
<p>结束标记：shutdownOutput()</p>
<h6 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a>练习6</h6><p>多个线程的输入输出</p>
<p>服务器多线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket ss= <span class="keyword">new</span> <span class="title class_">SreverSocket</span>(<span class="number">30002</span>);</span><br><span class="line">Socket s=ss.accept();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ServerThread</span>(s)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h4 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h4><p>做什么</p>
<p>Lambda表达式的标准格式</p>
<p>格式：（形参）-&gt;{代码块}</p>
<ul>
<li>形参：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</li>
<li>-&gt;:有英文中的画像和大于符号组成，固定写法，代表指向动作</li>
<li>代码块：之前的方法体</li>
</ul>
<p>使用前提：</p>
<p>有一个接口，且接口只有一个抽象方法</p>
<h6 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h6><p>定义一个接口，且只有一个抽象方法，在主方法中使用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useFilable</span><span class="params">(Filable f)</span>&#123;</span><br><span class="line">    f.fly(<span class="string">&quot;风车&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">useFlyable((String s)-&gt;&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;)&#125;</span><br></pre></td></tr></table></figure>

<h5 id="省略模式"><a href="#省略模式" class="headerlink" title="省略模式"></a>省略模式</h5><p>参数的类型可以省略，但是有多个参数是要一致</p>
<p>参数有一个，小括号也能省略，</p>
<p>代码块只有一条可以省略大括号和分号，如果有return，return也要省略</p>
<p>useFlyable(s-&gt;System.out.println(s));</p>
<p>useFlyable((x,y)-&gt;x+y);</p>
<p>注意事项</p>
<p>接口中只有一个方法</p>
<p>有上下文环境，1在主函数中有相应的方法，2局部赋值，调用方法的参数</p>
<h5 id="匿名内部类和Lambda表达式的区别"><a href="#匿名内部类和Lambda表达式的区别" class="headerlink" title="匿名内部类和Lambda表达式的区别"></a>匿名内部类和Lambda表达式的区别</h5><p>所需类型不同：</p>
<ul>
<li><p>Lambda表达式必须是接口</p>
</li>
<li><p>匿名内部类：可也是接口，抽象类，具体类，可以多个方法</p>
</li>
</ul>
<p>实现原理不同：</p>
<ul>
<li>匿名内部类：编译之后，会产生一个单独的.class字节码文件</li>
<li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码文件会在运行的时候动态生成</li>
</ul>
<h4 id="接口的组成更新"><a href="#接口的组成更新" class="headerlink" title="接口的组成更新"></a>接口的组成更新</h4><p>接口的组成：</p>
<ul>
<li>常量</li>
<li>抽象方法</li>
<li>默认方法</li>
<li>静态方法</li>
<li>私有方法</li>
</ul>
<p>接口中不再只有抽象方法，默认方法等可以有方法体</p>
<h5 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h5><ul>
<li><p>格式：public default 返回值类型 方法名（参数列表）{}</p>
</li>
<li><p>puublic default void show(){}</p>
</li>
<li><p>可以直接调动方法</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>默认方法不是抽象方法，不强制被重写，办事可以被重写，重写的时候去掉default</li>
<li>public可以省略，default不能省略</li>
</ul>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><ul>
<li>public static void  show(){}</li>
<li>只能被接口调用，不能被实现类调用</li>
</ul>
<h5 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h5><p>private 返回值类型 方法名(参数列表){}</p>
<p>private void show(){}</p>
<p>private static void method(){}</p>
<p>在静态方法中只能调用静态方法</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用符 ：：</p>
<ul>
<li><p>Lambda表达式：usePrintable(s-&gt;System.out.println(s));</p>
<p>参数通过Lambda表达式，传递给System.out.println方法去处理</p>
</li>
<li><p>方法引用：usePrintable(System.out::println);</p>
<p>风险：直接使用System.out中的pringln方法来取代Lambda,代码更简洁</p>
</li>
<li><p>若使用Lambda，根据“可推导就是可省略”的原则，无需指定参数类型</p>
</li>
<li><p>若是方法引用同样可以根据上下文推导</p>
</li>
<li><p>方法引用是Lambda的孪生兄弟</p>
</li>
</ul>
<h5 id="Lambda表达式支持的方法引用"><a href="#Lambda表达式支持的方法引用" class="headerlink" title="Lambda表达式支持的方法引用"></a>Lambda表达式支持的方法引用</h5><p>引用类方法：引用类的静态方法</p>
<ul>
<li>格式：类名：：静态方法</li>
<li>Integer::parselent</li>
<li>Integer类的方法：pubilc static int parselent(String s)将String转换为int类型数据</li>
<li>Lambda表达式被类方法替代的时候，它的形参全部传递给静态方法作为参数</li>
</ul>
<h6 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h6><ol>
<li><p>定义一个接口（Coinverter,里面定义一个抽象方法</p>
</li>
<li><p>定义一个测试类（ConverterDemo）在测试类中提供两个方法</p>
<p>useConverterDemo(Converter c)</p>
<p>主方法</p>
</li>
</ol>
<h5 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h5><p>:就是引用类中的成员方法</p>
<ul>
<li><p>格式：对象：：成员方法</p>
</li>
<li><p>“HellowWorld”::toUpperCase</p>
<p>String类中的方将此String索引字符转化为大写</p>
</li>
</ul>
<p>Lambda表达式被对象的实例方法替代的时候，它的形参全部传递到该方法作为参数</p>
<h5 id="引用类的实例方法"><a href="#引用类的实例方法" class="headerlink" title="引用类的实例方法"></a>引用类的实例方法</h5><p>：就是引用类的成员方法</p>
<ul>
<li><p>格式：类名：：成员方法</p>
</li>
<li><p>String::substring</p>
</li>
<li><p>String中的方法：从beginIndex到endIndex结束，截取字符串。返回一个子串</p>
</li>
<li><p>Lambda表到时被类的实例方法代替的时候</p>
<p>第一个参数作为调用者，后面的参数全部传递给该方法作为参数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    useMyString(String::substring);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useMyString</span><span class="params">(MyString my)</span>&#123;</span><br><span class="line">    String s=my.myString(<span class="string">&quot;Hellowrld&quot;</span>,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h5><p>就是引用构造方法</p>
<ul>
<li><p>格式：类名::new</p>
</li>
<li><p>Student::new</p>
</li>
</ul>
<p>Lambda表达式被构造器代替的时候，它的全部形参传递给构造器作为参数</p>
<p>练习：</p>
<ul>
<li><p>定义一个类（Student），里面有两个成员变量（name，age）</p>
<p>并提供无参构造方法和带参构造方法</p>
</li>
<li><p>定义一个接口（StudentBuilder），里面定义一个抽象方法</p>
<p>Student build(String name,int age);</p>
</li>
<li><p>定义一个测试类（StudentDemo）,在测试类中提供两个方法</p>
<p>一个方法是：useStudentBuilder(StudentBuilder s)</p>
<p>一个方法是猪方法，在猪方法中调用useStudentBuilder方法</p>
</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口：尤其只有一个抽象方法的接口</p>
<p>java中的函数式编程体现就是Lambda表达式，函数式接口就是可以适用于Lambda表达式的接口</p>
<p>只有确保接口中只有一个抽象方法，java中的Lambda才能推导</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyInterface my=()-&gt;Systerm.out.println(<span class="string">&quot;函数式接口&quot;</span>)；</span><br></pre></td></tr></table></figure>

<p>函数式注解：@FunctionalInterface放在接口上方，通过就是</p>
<h5 id="函数式接口作为方法的参数"><a href="#函数式接口作为方法的参数" class="headerlink" title="函数式接口作为方法的参数"></a>函数式接口作为方法的参数</h5><p>如果方法的参数是一个函数式接口，我们可以使用Lambda表达式作为参数传递</p>
<ul>
<li>startThread(()-&gt;System.out.println(Thread.currentThread().getName()+”线程启动了”))；</li>
</ul>
<p>函数式接口作为方法的返回值</p>
<p>方法的返回值是函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;Student&gt; <span class="title function_">getComparator</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s1,s2)-&gt;s1.getSid().compareTo(s2.getSid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义比较器</p>
<p>常用的函数式接口</p>
<ul>
<li>Supplier接口</li>
<li>Consumer接口</li>
<li>Predicate接口</li>
</ul>
<h5 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h5><p>Supplier<T>:包含一个无参的方法</p>
<ul>
<li>T get():获得结果</li>
<li>不需要参数，他会按照某种路基范湖一个数据</li>
<li>Supplier<T>接口也被称为生产型接口，指定接口的泛型是什么类型，接口get方法就会生产什么类型数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> suo.get();&#125;</span><br><span class="line">String s=getString(()-&gt;<span class="string">&quot;林青霞&quot;</span>)；</span><br></pre></td></tr></table></figure>

<p>定义一个类提供两个方法</p>
<p>一个用于返回int数据的最大值</p>
<p>一个是主方法interest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] ar=&#123;<span class="number">12</span>,<span class="number">34</span>,<span class="number">5453</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> maxValue=getMax(()-&gt;&#123;</span><br><span class="line">        <span class="type">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ar.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ar[i]&lt;ma)&#123;</span><br><span class="line">                    ma=ar[i] ;&#125; &#125;<span class="keyword">return</span> ma;  &#125;);</span><br><span class="line">    System.out.println(max);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; r)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r.get(); &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h5><ul>
<li>void accept(T t):对给定的参数执行此操作</li>
<li>default Consumer<T> andThen(Consumer after):返回一个组合的Consumer，依次执行此操作，然后执行after操作</li>
<li>Consumer<T>接口也被称为消费型接口，他消费的数据好数据类型由泛型指定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    operatorString(<span class="string">&quot;林青霞&quot;</span>，s-&gt;System.out.println(s));</span><br><span class="line">    operatorString(<span class="string">&quot;林青霞&quot;</span>，s-&gt;System.out.println(s),s-&gt;System.out.println(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name,Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span>&#123;</span><br><span class="line">    con1.andThen(con2).accept(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name,Consumer&lt;String&gt; con)</span>&#123;</span><br><span class="line">    con.accept(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把字符串按指定的方式打印</p>
<h5 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h5><ul>
<li>boolean test(T t):对给定的参数进行判断（判断逻辑由Lambda表达式实现）返回一个布尔值</li>
<li>default Predicate<T> negate():返回一个逻辑的否定，对应逻辑非</li>
<li>default Predicate<T> and(Predicate other):返回一个组合判断，对应短路与</li>
<li>default Predicate<T> or(Predicate other):返回一个组合判断，对应短路或</li>
<li>Predicate<T>接口通常用于判断该参数是否满足条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> b1=checkString(<span class="string">&quot;hellow&quot;</span>,s-&gt;s.length()&gt;<span class="number">8</span>);</span><br><span class="line"><span class="type">boolean</span> b2=checkString(<span class="string">&quot;hellowworld&quot;</span>,s-&gt;length()&gt;<span class="number">8</span>,s-&gt;length()&lt;<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkString</span><span class="params">(String s,Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre1.or(pre2).test(s);</span><br><span class="line">    <span class="comment">//return pre1.and(pre2).test;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkString</span> <span class="params">(String Predicate&lt;String&gt;)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre.negate().test(s);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h5><ul>
<li>R apply(T t):将此函数应用于给定的参数</li>
<li>default<V> Function andThen(Function after):返回一个组合函数，首先将函数应用于输入，然后将after函数应用于结果</li>
<li>Function&lt;T，R&gt;：接口通常用于对参数进行处理，转换（处理逻辑由Lamnda表达式实现），返回一个新的值</li>
</ul>
<p>要求：将字符串截取得到数字年龄部分，将年龄转成int类型的数据，将int类型的加70输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;林青霞，30&quot;</span>；</span><br><span class="line">    convert(s,ss-&gt;split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>],ss-&gt;Integer.parseInt(ss),i-&gt;i+<span class="number">70</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s,Function&lt;String,String&gt; fun1,Functon&lt;String,Integer&gt; fun2,Function&lt;Integer,Integer&gt; fun3)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fun1.andThen(fun2).andThen(fun3).apply(s);</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>生成方式</p>
<ul>
<li><p>生成流：</p>
<p>通过数据源（集合等）生成流</p>
<p>list.stream()</p>
</li>
<li><p>中间操作</p>
<p>多个操作</p>
<p>filter()</p>
</li>
<li><p>终结操作</p>
<p>一个流只有一个终结操作</p>
<p>forEach()</p>
</li>
</ul>
<h5 id="常见的生成方式："><a href="#常见的生成方式：" class="headerlink" title="常见的生成方式："></a>常见的生成方式：</h5><ul>
<li><p>Collection体现的结合可以使用默认方法stream()生成流</p>
<p>default Stream<E> stream()</p>
</li>
<li><p>Map体现的集合间的生成流</p>
</li>
<li><p>数据可以通过流</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Stream&lt;String&gt; liststream = list.stream();<span class="comment">//Collection集合的默认方法Set HashSet也有默认方法</span></span><br><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">Stream&lt;String&gt; ketStream=map.KeySet().stream();</span><br><span class="line">Stream&lt;Integer&gt; valueStream=map.values().stream();</span><br><span class="line">Stream&lt;Map&lt;String,Integer&gt;&gt; entryStream = map.entrySet().stream();<span class="comment">//Map集合间接生成流</span></span><br><span class="line">Stream&lt;String&gt; strArrayStream = Stream.of(<span class="string">&quot;hellow&quot;</span>,<span class="string">&quot;world&quot;</span></span><br><span class="line">,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; intStream=Stream.of(<span class="number">10</span>,<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h5><ul>
<li><p>Stream<T> <strong>filter(predicate predicate):</strong></p>
<p>Predicate接口中的方法boolean test(T,t);</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;林青霞&quot;</span>)；</span><br><span class="line">list.stream().filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s-&gt;s.lengtrh()==<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//1判断过滤</span></span><br><span class="line">list.stream().skip(<span class="number">2</span>).limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//2,3取前几个数据；跳过几个数据</span></span><br><span class="line">Stream&lt;String&gt; s1=list.stream().limit(<span class="number">4</span>);</span><br><span class="line">Stream&lt;String&gt; s2=list.stream().skip(<span class="number">2</span>);</span><br><span class="line">Stream.concat(s1,s2).distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,4.合并a和b流为一个流</span></span><br><span class="line"><span class="comment">//返回由流的不同元素(根据Object.equals(Object))组成的流,用的是equals方法</span></span><br><span class="line">list.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//返回由此流的元素组成的流，根据自然顺序排序</span></span><br><span class="line">list.stream().sorted((s1,s2)-&gt;&#123;</span><br><span class="line">    <span class="type">int</span> num=s1.length()-s2.length();</span><br><span class="line">    <span class="type">int</span> num2=num==<span class="number">0</span>?s1.comparaTo(s2):num;</span><br><span class="line"><span class="keyword">return</span> num2;&#125;).forEach(System.out::println);</span><br><span class="line"><span class="comment">//排序5,6返回由Comparator的排序之后的流</span></span><br><span class="line">list.stream().map(s-&gt;Integer::parseInt).forEach(System.out::println);</span><br><span class="line">list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);</span><br><span class="line"><span class="type">int</span> result= list.stream().mapToInt(Integer::parseInt).sum();</span><br><span class="line"><span class="comment">//有独属于IntStream的方法，sum求和</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Stream<T> <strong>limit</strong>(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据，<strong>取前几个数据</strong>；</p>
</li>
<li><p>Stream<T> <strong>skip</strong>(long n):跳过指定参数个数的数据，返回由该留的剩余元素组成的流，<strong>跳过几个数据</strong></p>
</li>
<li><p>static<T> Streram<T> <strong>concat</strong>(Stream a,Stream b):<strong>合并</strong>a和b流为一个流</p>
</li>
<li><p>Stream<T> <strong>distinct</strong>():<strong>返回由流的不同元素</strong>(根据Object.equals(Object))组成的流,用的是equals方法</p>
</li>
<li><p>Stream<T> <strong>sorted</strong>():返回由此流的元素组成的流，根据自然顺序排序</p>
</li>
<li><p>Stream<T> <strong>sorted(Comparator comparator)</strong>:返回由Comparator的排序之后的流</p>
</li>
<li><p><R>Stream<R> map(unction mapper):返回由给定<strong>函数应用于此流的元素的结果的流</strong></p>
<p>Function 接口中的方法     Rapply(T t)</p>
</li>
<li><p>IntStream mapToInt(TIntFunction mapper):返回一个<strong>IntSream</strong>其中包含给定函数应用于此流的元素的结果</p>
<p>IntStream:表示原始int流</p>
<p>ToIntFunction接口中的方法     int applyAslnt(T value)</p>
</li>
</ul>
<h5 id="常见终结方法"><a href="#常见终结方法" class="headerlink" title="常见终结方法"></a>常见终结方法</h5><ul>
<li><p>void forEach(Consumer action):对此流的每一个元素执行操作</p>
<p>Consumer接口中的方法    void accept(T t):对参数执行此操作</p>
</li>
<li><p>long count():返回此流中的元素数</p>
</li>
</ul>
<p>练习</p>
<ol>
<li>有两个集合分别存储6名男演员和6名女演员，</li>
<li>男演员要名字为3个字段前三人</li>
<li>女演员只要姓林的，并且不要第一个</li>
<li>把过滤值后的男演员和女演员合并到一起</li>
<li>再创建一个集合，存储上面的对象，并遍历数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.concat(manList.stream().filter(s-.s.length()==<span class="number">3</span>).limit(<span class="number">3</span>),womanList.stream.filter(s-&gt;s.startsWith(<span class="string">&quot;林&quot;</span>)).skip(<span class="number">1</span>)).map(Actor::<span class="keyword">new</span>).forEach(p-&gt;System.out.println(p.getName()));</span><br></pre></td></tr></table></figure>

<h5 id="Stream流的收集操作"><a href="#Stream流的收集操作" class="headerlink" title="Stream流的收集操作"></a>Stream流的收集操作</h5><p>Stream流的收集方法</p>
<ul>
<li>R collect(Collector collector)</li>
<li>这个收集参数是一个Collector接口</li>
</ul>
<p>工具类Collectors提供了具体的收集方式</p>
<ul>
<li>public static<T> Collector toKist():把元素收集到List集合中</li>
<li>public static<T> Collector toSet():把元素收集到Set集合中</li>
<li>public static Collector toMap(Functon keyMapper,Function valueMapper):把元素收集到Map集合中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; listStream = list.stream().filter(s-&gt;s.length()==<span class="number">3</span>);</span><br><span class="line">List&lt;String&gt;names=listStream.collect(Collectors.toList());</span><br><span class="line">Stream&lt;Integer&gt; setStream= set.stream().filter(age-&gt;age&gt;<span class="number">25</span>);</span><br><span class="line">Set&lt;Integer&gt; ages=setStream.collect(Collection.toSet());</span><br><span class="line">arrayStream.collect(Collectros.toMpa(s-&gt;s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>],s-&gt;Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line"><span class="comment">//对键和值进行操作</span></span><br></pre></td></tr></table></figure>

<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>当程序要使用蘑菇类是，若类还未加载到内存中，则系统会通过类的加载，类的连接， 类的初始化这三个步骤来对类进行初始化，</p>
<h5 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h5><ul>
<li>就是将类class文件读入内存中国，并为之建立一个java.lang.Class对象</li>
<li>任何类被使用时，系统都会为其奖励一个java.lang.Class对象</li>
</ul>
<h5 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h5><ul>
<li>验证阶段：用于检验被加载的类是否有正确的内部结构，并与其他类协调一致</li>
<li>………</li>
</ul>
<h5 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240723161132873.png" alt="image-20240723161132873"></p>
<p>初始化步骤：</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240723163136574.png" alt="image-20240723163136574"></p>
<h5 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h5><p>全盘机制：就是当类的加载器负责加载加载某个Class是，该Class所依赖的和引用的其他的Class也将由该加载器负责，除非显示使用另一个加载器</p>
<p>父类委托：先让父类的加载器尝试加载该类，父类加载器无法加载该类才从自己的类路径中加载该类</p>
<p>缓存机制：保证所有加载过的Class都会被缓存，当程序血药摸个Class对象时先从缓存中搜索，没有在读取转换成Class对象，并存储到缓存区</p>
<p>ClassLoader:是负责加载类的对象</p>
<p>java运行时具有以下的内置加载器</p>
<ul>
<li>Bootstrap class loader:他是虚拟机的内置类加载器，通常表示null,并且没有复null</li>
<li>Platform class loader:平台类加载器可以看到所有平台类包括平台类加载器和其祖先定义的javaSE平台API，其实现类和JDK特定的运行时的类</li>
<li>System class loader:它也被称为应用程序加载类，与平台类加载器不同，系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类</li>
<li>类加载器的继承关系：System的父加载器为Platform,而Platform的父加载器为Bootstrap</li>
</ul>
<p>ClassLoader中的方法</p>
<p>static ClassLonder getSystemClassLoader():返回用于委派的系统类加载器</p>
<p>ClassLoader getParent()：返回父类加载器进行委派</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>java反射机制：是值在运行时获取一个类的变量和方法信息，然后通过获取到的信息来创建对象，调用方法的机制。</p>
<p>成员变量：Field[] field</p>
<p>构造方法：Constructor[] cons</p>
<p>成员方法 Menthod[] menthods</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240724114236724.png" alt="image-20240724114236724"></p>
<h5 id="获取Class类的对象"><a href="#获取Class类的对象" class="headerlink" title="获取Class类的对象"></a>获取Class类的对象</h5><p>要想通过反射去使用一个类，首先要获取Class文件</p>
<p>获取Class文件的方法</p>
<ul>
<li>是有类的Class属性来获取Class对象。Student.class将会返回Student对应的Class对象</li>
<li>调用对象的getClass方法返回对象的Class对象</li>
<li>使用Class类中的静态方法forName(String className),该方法需要传入字符串参数，字符串参数的值是某个类的全路径，也就是完整包名的路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Student&gt; c=Student.class;</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Student</span>&gt; c3=s.getClass();</span><br><span class="line">Class&lt;?&gt; c4=Class.forName(<span class="string">&quot;包名.类名&quot;</span>)<span class="comment">//完整包名的路径</span></span><br></pre></td></tr></table></figure>

<h5 id="反射获取构造方法并使用"><a href="#反射获取构造方法并使用" class="headerlink" title="反射获取构造方法并使用"></a>反射获取构造方法并使用</h5><p>Class类中用于获取构造方法的方法</p>
<ul>
<li>Constructor&lt;?&gt;[] getConstructors():返回所有公共构造方法对象的数组</li>
<li>Constructor&lt;?&gt;[] getDeclaredConstructors():返回所有构造方法对象的数组</li>
<li>Constructor&lt;?&gt; getConstructor():返回单个公共构造方法对象</li>
<li>Constructor&lt;?&gt; getDeclaredConstructor():返回单个构造方法对象</li>
</ul>
<p>Constructor类中用于创建对象的方法</p>
<ul>
<li>T newInstance(Object…initargs):根据指定的构造方法创建对象</li>
</ul>
<h6 id="通过反射实现："><a href="#通过反射实现：" class="headerlink" title="通过反射实现："></a>通过反射实现：</h6><p>Student s &#x3D;new Student(“林青霞”，33，“西安”)；</p>
<p>System.out.priontln(s);</p>
<p>基本数据也可获得Class类型</p>
<p>con.setAccessible(true);解除访问权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c=Class.forName(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con = c.getVonstructor(String.class,<span class="type">int</span>.class,String.class);</span><br><span class="line">Object obj=con.newInstance(<span class="string">&quot;林青霞&quot;</span>，<span class="number">30</span>,<span class="string">&quot;西安&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; cin= c.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//获取私有方法</span></span><br><span class="line"><span class="comment">//暴力反射使用私有方法</span></span><br><span class="line">con.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object obj=con.newInstance(<span class="string">&quot;林青霞&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="反射获取成员变量并使用"><a href="#反射获取成员变量并使用" class="headerlink" title="反射获取成员变量并使用"></a>反射获取成员变量并使用</h5><ul>
<li><p>Field[] getFields()返回包含Field对象的数组，反映所有可访问的对象</p>
</li>
<li><p>Field[] getDetlareFields()返回所有的对象</p>
<p>例子：field[] s&#x3D;c.getFields();</p>
</li>
<li><p>Field getField (String name):返回一个公共对象</p>
</li>
<li><p>Field getDetlareField(String name):返回对象</p>
</li>
<li><p>void set(Object obj,Object value)：给obj成员变量赋值</p>
<p>addressField.set(obj,”西安”)；</p>
</li>
</ul>
<h5 id="反射获取方法并使用"><a href="#反射获取方法并使用" class="headerlink" title="反射获取方法并使用"></a>反射获取方法并使用</h5><ul>
<li><p>Method[] getMethods():返回一个包含方法的数组，公共的,包括继承的</p>
</li>
<li><p>Method[] getDeclaredMethods():返回所有方法，不包括继承的</p>
</li>
<li><p>Method[] methods &#x3D; c.getMethods();</p>
</li>
<li><p>Method getMethod(String name,Class&lt;?&gt;… parameterTypes):返回一个方法对象，公共的</p>
</li>
<li><p>Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes):返回一个方法对象</p>
<p>Method m&#x3D;con.getMethod(“method”);</p>
</li>
<li><p>Object invoke(Object obj,Object…args):调用此方法</p>
<p>Object:表示返回值类型</p>
<p>obj:调用方法的对象</p>
<p>args:方法需要的参数</p>
<p>m.invoke(obj);</p>
</li>
</ul>
<p>通过反射实现</p>
<p>Student s&#x3D; new Student();</p>
<p>s.method1();</p>
<p>s.method2(“林青霞”);</p>
<p>String ss&#x3D;s.method3(“林青霞”，30)；</p>
<p>System.out.println(ss);</p>
<p>s.function();</p>
<p>通过配置文件运行文件类中的方法</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>把java分为N个模块</p>
<h4 id="模块的基本使用"><a href="#模块的基本使用" class="headerlink" title="模块的基本使用"></a>模块的基本使用</h4><ul>
<li>创建模块</li>
</ul>
<h4 id="模块服务"><a href="#模块服务" class="headerlink" title="模块服务"></a>模块服务</h4><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240723213717957.png" alt="image-20240723213717957"></p>
<ul>
<li><p>在myOne模块下创建一个包com.ithema_03,在包下提供一个接口，在接口中定义一个抽象方法</p>
<p>public interface MyService{</p>
<p>void service();}</p>
</li>
<li><p>在com.ithema_03包下创建一个包impl,在改包下提供接口的两个实现类Itheima和Czxy</p>
</li>
</ul>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240723214525789.png" alt="image-20240723214525789"></p>
]]></content>
  </entry>
  <entry>
    <title>javaweb的基础知识</title>
    <url>/2024/09/17/javaweb%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="javaweb"><a href="#javaweb" class="headerlink" title="javaweb"></a>javaweb</h1><ol>
<li>junit单元测试</li>
<li>反射</li>
<li>注解</li>
</ol>
<h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><ul>
<li>黑盒测试：运行看不见，不需要写代码，看程序是否输出期望值</li>
<li>白盒测试：需要写代码。关注具体流程。看的见</li>
</ul>
<p>junit测试：白盒测试</p>
<p>步骤：</p>
<ol>
<li><p>定义一个测试类</p>
<p>测试类名:被此时的类名Test，  CalculatorTest</p>
<p>包名：xxx.xxx.xx.test    cn.it.test</p>
</li>
<li><p>测试方法：可以独立运行</p>
<p>方法名：test测试的方法名    testAdd()</p>
<p>返回值：void</p>
<p>参数列表：空参</p>
</li>
<li><p>给方法加注解@Test</p>
</li>
<li><p>导入包依赖环境</p>
<p>一般使用断言来处理结果</p>
<p>Assert.assertEquals(expect(期望的),actual(实际的));</p>
</li>
</ol>
<p>两个注解：</p>
<ul>
<li><p>@Before：修饰的方法会在测试方法之前被自动执行</p>
<ul>
<li>public void init(){}</li>
</ul>
</li>
<li><p>@After:修饰的方法会在测试方法之后自动执行</p>
<ul>
<li>public void close(){}</li>
</ul>
</li>
<li><p>@Test:不需要main方法就能使用</p>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>框架设计的灵魂</p>
<ul>
<li>框架：半成品软件。科一在框架的基础上进行一些软件开发，简化编码</li>
<li>反射：将类的各个组成部分封装为其他对象，这就是反射机制</li>
</ul>
<p>好处：</p>
<ol>
<li>可以在程序有运行中操作这些对象</li>
<li>可以解藕，提高程序的可操作性</li>
</ol>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240724114249906.png" alt="image-20240724114249906"></p>
<h4 id="获取class方式"><a href="#获取class方式" class="headerlink" title="获取class方式"></a>获取class方式</h4><ol>
<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象<ul>
<li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类（字符串）</li>
</ul>
</li>
<li>类名.class:通过类名的属性获取<ul>
<li>多用于参数的传递</li>
</ul>
</li>
<li>对象.getClass()：getClass()方法在Object类中定义<ul>
<li>多用于对象的获取字节码方式</li>
</ul>
</li>
</ol>
<ul>
<li>结论：同一个字节码文件在一次运行国政中，只会被加载一次，不论通过哪一种方式</li>
</ul>
<h4 id="使用class"><a href="#使用class" class="headerlink" title="使用class"></a>使用class</h4><ol>
<li>获取成员变量<ul>
<li>Field[] getFields()</li>
<li>Field getField(String name)</li>
<li>Field[] getDeclaredFields()</li>
<li>Field getDeclaredField(String name)</li>
</ul>
</li>
<li>获取构造方法<ul>
<li>Constructor&lt;?&gt;[] getConstructors()</li>
<li>Constructor&lt; &gt; getConstructors(类&lt;?&gt;…parameterTypes)</li>
<li></li>
<li></li>
</ul>
</li>
<li>获取成员方法</li>
<li>获取类名</li>
</ol>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240724145029430.png" alt="image-20240724145029430"></p>
<h5 id="Field-成员变量"><a href="#Field-成员变量" class="headerlink" title="Field:成员变量"></a>Field:成员变量</h5><ul>
<li><p>操作</p>
<ol>
<li><p>设置值</p>
<p>void set(Object obj,Object value)  ，obj为类的对象，value为修改值</p>
</li>
<li><p>获取值</p>
<p>get(Object obj)  ,obj为类的对象</p>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<p>srtAccessible(true):暴力反射</p>
</li>
</ol>
</li>
</ul>
<h5 id="Constructor-构造方法"><a href="#Constructor-构造方法" class="headerlink" title="Constructor:构造方法"></a>Constructor:构造方法</h5><ul>
<li>创建对象：<ul>
<li>T newInstance(Object…initargs)初始化</li>
<li>用空参创建对象Class对象的newInstance方法</li>
</ul>
</li>
</ul>
<h5 id="Method-执行方法"><a href="#Method-执行方法" class="headerlink" title="Method :执行方法"></a>Method :执行方法</h5><ul>
<li><p>执行方法：</p>
<ul>
<li>invoke</li>
</ul>
</li>
<li><p>获取方法名，类名</p>
<p>String getName:获取方法名</p>
<p>类名从Class中获取</p>
</li>
</ul>
<h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><p>需求：写一个“框架”，在不改变代码的情况下，创还能任意类的对象，并能执行任意方法</p>
<ul>
<li><p>实现：</p>
<ol>
<li>配置文件</li>
<li>反射</li>
</ol>
</li>
<li><p>步骤：</p>
<ol>
<li>将需要创建的对象的全类名和执行方法定义在配置文件中</li>
<li>在程序中加载读取配置文件</li>
<li>使用反射技术带加载类文件进内存</li>
<li>创建对象</li>
<li>执行方法</li>
</ol>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>分类</p>
<ul>
<li>编写文档：通过代码里的标识的注解生成文档【生成文档doc文档】</li>
<li>代码分析：通过代码里的标识的注解对代码进行分析【使用反射】</li>
<li>编译检查：通过代码里的标识的注解让编译器实现基本的编译检查【@Override】</li>
</ul>
<p>使用注解@注解名称</p>
<ul>
<li>JDK中预定义的一些注解<ul>
<li>@Override:检测是重写的方法</li>
<li>@Deprecated:表明已过时</li>
<li>@SuppressWarning：压制警告</li>
</ul>
</li>
</ul>
<p>自定义注解</p>
<ul>
<li><p>格式：</p>
<p>元注解</p>
<p>public @interface 注解名称{}</p>
</li>
<li><p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p>
<ul>
<li>public interface MyAnno extends java.lang.annotation.Annotation{}</li>
</ul>
</li>
<li><p>属性：接口中可以定义的成员方法</p>
<p>要求：</p>
<ol>
<li><p>属性的返回值类型：基本数据类型，String 枚举，注解和以上类型的数组</p>
</li>
<li><p>定义了属性，在使用时需要给属性赋值：</p>
<p>在定义属性时，使用default关键字修饰不用赋值</p>
<p>若只有一个属性则可以省略名称</p>
</li>
</ol>
</li>
<li><p>元注解：用于描述注解的注解</p>
<p>@Target:用于描述注解能够作用的位置</p>
<ul>
<li><p>ElementType的值：</p>
<p>TYPE:作用与类上</p>
<p>METHOD:作用于方法</p>
<p>FIELD：作用与成员变量</p>
</li>
</ul>
<p>@Retrntion:描述注解被保留的阶段</p>
<ul>
<li>@Retention(RetentonPolicy.RUNTIME                                            ):当前被描述的注解，会保留到class字节码文件中，并为JVM读取</li>
</ul>
<p>@Documented:描述注解是否被抽取到api文档中</p>
<p>@Inherited:描述注解是否被子类继承</p>
</li>
</ul>
<p>在程序中使用注解：获取注解中定义的属性值 </p>
<ol>
<li><p>获取注解定义的位置的对象（Class,Method,Field）</p>
</li>
<li><p>获取指定的注解</p>
<p>getAnnotation(Class)</p>
</li>
<li><p>调用注解中的抽象方法获取配置的属性值</p>
</li>
</ol>
<p>简单的测试框架：</p>
<p>当主方法执行，会自动检查所有方法，并判断是否有异常，记录到文件中</p>
<ol>
<li>获取注解中定义的属性值，测试类地址</li>
<li>创建测试类的对象</li>
<li>获取字节码文件对象</li>
<li>获取所有方法</li>
<li>判断方法是否有Ckeck注解，有就执行  if(method.isAnnotationPresent(Check.class))</li>
<li>捕获异常</li>
</ol>
<p>小结：</p>
<ol>
<li>会使用注解不定义</li>
<li>给编译器用，给解析程序用</li>
<li>注解不是程序，是程序的一个标签</li>
</ol>
<h1 id="web基础知识"><a href="#web基础知识" class="headerlink" title="web基础知识"></a>web基础知识</h1><p>web是互联网项目，使用java语言开发网站</p>
<p>数据库（5），网页前端（5），web核心技术（15），旅游管理系统（5）</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>基本概念，MySQL软件，SQL的使用</p>
<h4 id="基本概念-DataBase-简称DB"><a href="#基本概念-DataBase-简称DB" class="headerlink" title="基本概念:DataBase,简称DB"></a>基本概念:DataBase,简称DB</h4><ul>
<li>用于存储和管理数据的仓库</li>
</ul>
<p>特点：</p>
<ol>
<li>持久化存储数据的，数据库就是一个文件系统</li>
<li>方便存储和管理数据</li>
<li>使用了统一的方式操作数据库–SQL</li>
</ol>
<p>常见数据库软件：</p>
<ul>
<li>MySQL</li>
<li>Or</li>
</ul>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ol>
<li><p>安装</p>
</li>
<li><p>卸载</p>
<p>去mysqld 安装目录下找到my.ini文件，复制daradir&#x3D;”c&#x2F;programDate&#x2F;Mysql&#x2F;Mtsql Server 9&#x2F;Data&#x2F;“</p>
<p>卸载</p>
<p>删除c&#x2F;programData&#x2F;MySQL</p>
</li>
<li><p>配置</p>
<p>要配置环境</p>
<p>服务启动：</p>
<ol>
<li><p>手动</p>
</li>
<li><p>cmd–&gt;services.msc打开服务的窗口</p>
</li>
<li><p>使用管理员打开cmd</p>
<p>net start mysql:启动mysql服务</p>
<p>net stop mysql:关闭mysql服务</p>
</li>
</ol>
</li>
</ol>
<ul>
<li><p>mySQL登录</p>
<p>mysql -uroot -p</p>
<p>mysql -hip -uroot -p</p>
<p>mysql –host&#x3D;ip –user&#x3D;root –password&#x3D;</p>
</li>
<li><p>退出</p>
<p>exit </p>
<p>quit</p>
</li>
</ul>
<h5 id="MySQL的目录："><a href="#MySQL的目录：" class="headerlink" title="MySQL的目录："></a>MySQL的目录：</h5><p>MySQL的安装目录</p>
<p>MySQL的数据目录</p>
<p>配置文件 my.ini</p>
<p>数据库：文件夹</p>
<p>表：文件</p>
<p>数据：数据</p>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>Structured Query Language:结构化查询语言</p>
<p>就是定义了操作所有关系型数据库的规则，每一种数据库的操作方式存在不一样的地方，称为方言</p>
<p>通用语法</p>
<ol>
<li><p>SQL语句可以单行或多行书写，以分号结尾</p>
</li>
<li><p>使用空格和缩进</p>
</li>
<li><p>数据库不区分大小写，但关键字建议使用大写</p>
</li>
<li><p>3种注释</p>
<p>单行注释：– 注释内容（有一个空格）或# 注释内容（mysql特有的）</p>
<p>多行注释：&#x2F;*   注释   *&#x2F;</p>
</li>
</ol>
<h2 id="书写语句"><a href="#书写语句" class="headerlink" title="书写语句"></a>书写语句</h2><ol>
<li>DDL：操作数据库和表的</li>
<li>DML：增删改表中的数据</li>
<li>DQL：查询表中的数据</li>
<li>DCL：授权</li>
</ol>
<h2 id="DDL操作库和表"><a href="#DDL操作库和表" class="headerlink" title="DDL操作库和表"></a>DDL操作库和表</h2><h5 id="操作数据库和表的"><a href="#操作数据库和表的" class="headerlink" title="操作数据库和表的"></a>操作数据库和表的</h5><h5 id="1操作数据库：CRUD"><a href="#1操作数据库：CRUD" class="headerlink" title="1操作数据库：CRUD"></a>1操作数据库：CRUD</h5><ol>
<li><p>C(Create):创建</p>
<p>创建数据库：create database 数据库名称;</p>
<p>创建数据库判断是否存在：create database if not exists 数据库名称;</p>
<p>创建db4数据库，并判断是否存在，并指定字符集为gbk：</p>
<p>create database if not exists bd4  character set gbk;</p>
</li>
<li><p>R(Retrieve):查询</p>
<p>查询所有的数据库：show databases;</p>
<p>查询某个数据库的创建语句：show create database 数据库名称；</p>
</li>
<li><p>U(Update):修改</p>
<p>修改数据库的字符集：alter database db3(数据库) character set 字符集名称</p>
</li>
<li><p>D(Delete):删除</p>
<p>删除数据库：drop database db3(数据库)；</p>
<p>判断数据库存在：drop database if exists dbs(数据库名称)</p>
</li>
<li><p>使用数据库</p>
<p>查询当前正在使用的数据库：select database();</p>
<p>使用数据库：use db1(数据库名称)</p>
</li>
</ol>
<h5 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h5><ol>
<li><p>C(Create):创建</p>
<p>创建表：create table 表名(</p>
<p>列名1 数据类型1，</p>
<p>列名2 数据类型2，</p>
<p>列名n 数据类型n</p>
<p>);</p>
<p>复制表：create table 新的表名 like 表名(被复制的表)</p>
</li>
<li><p>R(Retrieve):查询</p>
<p>查询所有数据库中的所有的表名称：show tables；</p>
<p>查询表达结构：desc 表名；</p>
</li>
<li><p>U(Update):修改</p>
<p>修改表名：alter table 表名 remane to 新的表名</p>
<p>修改表字符集：alter table 表名 character set 字符集名称</p>
<p>添加一列：alter table 表名 add 列名 数据类型</p>
<p>修改列名：alter table 表名 change 列名 新列名 新数据类型</p>
<p>​                 alter table 表名 modify 列名 新数据类型；</p>
<p>删除列：alter table 表名 drop 列名</p>
</li>
<li><p>D(Delete):删除</p>
<p>使用数据库</p>
<p>删除表：drop table if exists 表名</p>
</li>
</ol>
<p>数据类型：</p>
<ol>
<li><p>int：整数类型  ,  age int,</p>
</li>
<li><p>double:小数类型  ,  score double(5(几位),2(小数点后几位))</p>
</li>
<li><p>date:日期，包含年月日   ，  yyyy-MM-dd</p>
</li>
<li><p>datetimr:日期，包含年月日时分秒   ，  yyyy-MM-dd,HH:mm:ss</p>
</li>
<li><p>timestamp:时间错，包含年月日时分秒   ，  yyyy-MM-dd,HH:mm:ss</p>
<p>若不赋值或赋值为null,则默认使用当前的时间自动赋值</p>
</li>
<li><p>varchar:字符串</p>
<p>name varchar(20):姓名最大20个字符</p>
<p>zhangsan 8个字符 张三 2个字符</p>
</li>
</ol>
<p>创建表：</p>
<p>create table student(</p>
<p>id int ,</p>
<p>name varchar(32),</p>
<p>age int,</p>
<p>score double(4,1),</p>
<p>birthday date,</p>
<p>insert_time timestamp</p>
<p>);</p>
<h2 id="DML：添改删数据"><a href="#DML：添改删数据" class="headerlink" title="DML：添改删数据"></a>DML：添改删数据</h2><p>1.添加数据：</p>
<p>insert into 表名（列名1，列名2，…列名n) values(值1，值2，值3,…值n)</p>
<p>insert into student(id,name，age) values(1,’张三丰’,77);</p>
<ul>
<li>注意：</li>
<li><ol>
<li>列名一一对应</li>
</ol>
</li>
<li><ol start="2">
<li>若给所有列添加就不用写列名</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>删除数据：</p>
<p>语法：</p>
<ul>
<li>delete from 表名 [where 条件]</li>
</ul>
<p>注意：</p>
<ol>
<li><p>如果不加条件，就会删除表中的所有记录</p>
</li>
<li><p>若要删除所有记录</p>
<p>delete from 表名 ；有多少条记录就会执行多少次，效率低</p>
<p>truncate table 表名；显删除表再创建一张一摸一样的表</p>
</li>
</ol>
</li>
<li><p>修改数据：</p>
<p>语法：</p>
<ul>
<li>update 表名 set 列名1 &#x3D; 修改的数值1，列名2 &#x3D; 修改的数值2 … where(条件)</li>
</ul>
<p>注意</p>
<ul>
<li>不加条件就会全部修改</li>
</ul>
</li>
</ol>
<h2 id="DQL-查询表中的记录"><a href="#DQL-查询表中的记录" class="headerlink" title="DQL:查询表中的记录"></a>DQL:查询表中的记录</h2><ul>
<li>select * from 表名；</li>
</ul>
<h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><ol>
<li><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>select<br>   字段列表<br>from<br>   表名列表<br>where<br>   条件列表<br>group by<br>   分组字段<br>order by<br>   排序<br>limit<br>   分页限定</p>
</li>
<li><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><ol>
<li><p>多个字段的查询<br>select 字段名… from 表名<br>查询所有可以用*代替</p>
<p>select name,age from stu;</p>
<p>select * from stu;</p>
</li>
<li><p>去除重复<br>distinct</p>
<p>select distinct * from stu;</p>
</li>
<li><p>计算列<br>一般可以使用四则运算计算一些列的值，直接加（一般只进行数值的计算 ）</p>
<p>select      math,english,math+ifnull(english,0) from student</p>
<p>ifnull(表达式1，表达式2)：null参与的计算都为null<br>  表达式1：那个字段可能出现null<br>  表达式2：若出现null后的替换值</p>
</li>
<li><p>起别名</p>
<p>在要起别名的列名后加as或空字符</p>
<p>select math,english,math+ifnull(english,0)  as 总分  from student</p>
</li>
</ol>
</li>
<li><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ol>
<li><p>where字句后跟条件</p>
</li>
<li><p>运算符<br>&lt;, &gt; ,&lt;&#x3D;, &gt;&#x3D;,&#x3D;,&lt; &gt;(&#x3D;是等于没有赋值)<br>between …and<br>in(集合)（in(18,22,34,33))<br>like<br>   占位符：<br> _:表示了单个任意字符<br> %：多个任意字符<br> select *from stu where name like ‘马%’;（姓马，马任意）<br> select *from stu where name like ‘_马%’;第二个字为马<br>is null(null 不能使用&#x3D;)(math is null)<br>and 或 &amp;&amp;<br>or 或 ||<br>not 或！</p>
</li>
</ol>
</li>
</ol>
<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul>
<li>语法：order by 字句<br>order by 排序字段1 排序方式1,排序字段2 排序方式2,…<br>排序方式：<ol>
<li>ASC升序</li>
<li>DESC降序<br>select * from student order by math desc,english asc;(若有一样的就会按english的方式排序)</li>
</ol>
</li>
</ul>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体，进行纵向计算</p>
<ol>
<li><p>count:计算个数<br>一般选择非空的列：主键<br>count(*)(只要有一个不为空就算)</p>
</li>
<li><p>max:计算最大值<br>max(math)</p>
</li>
<li><p>min:计算最小值<br>min(math)</p>
</li>
<li><p>avg:计算平均值<br>avg(math)<br> 聚合函数排除了null</p>
<p> select count(name) from stu;</p>
</li>
</ol>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ol>
<li>语法：group by 分组字段</li>
<li>注意<br>分组之后查询的字段：分组字段，聚合函数<br>select sex,avg(math),count(id) from  where math&gt;70 student group by sex having count(id)&gt;2;<br>where和having的区别<br>where:在分组之前对条件限制，不参与分组。后不能跟聚合函数<br>having:在分组之后对条件限制，不被查询出来。能跟聚合函数</li>
</ol>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ol>
<li>语法：limit开始的索引，每页查询的条数；<br>select * from student limit 0,3;<br>开始的索引&#x3D;(当前的页码-1)*每页的条数<br>limit是mysql的方言</li>
</ol>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul>
<li>是对表中的数据进行限定，保证数据的正确性，有效性和完整性</li>
<li>分类：</li>
</ul>
<ol>
<li>主键约束：primary key</li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>
</ol>
<h4 id="非空约束：not-null"><a href="#非空约束：not-null" class="headerlink" title="非空约束：not null"></a>非空约束：not null</h4><p>某一列的值不能为null</p>
<ol>
<li>创建表时加约束<br>create table test(id int,name varchar(20) not null);</li>
<li>创建表后添加非空约束<br>alter table stu modify name varchar(20) not null;</li>
<li>删除非空约束<br>alter table stu modify name varchar(20);</li>
</ol>
<h4 id="唯一约束：unique"><a href="#唯一约束：unique" class="headerlink" title="唯一约束：unique"></a>唯一约束：unique</h4><p>某一列的值不能重复<br>注意：<br>   唯一约束可以有null值，但只能有一个</p>
<ol>
<li>创建表时添加唯一约束：<br>create table stu (id int phone_number varchar(20) unique)    </li>
<li>创建表后添加非空约束<br>alter table stu modify phone_number varchar(20) unique;</li>
<li>删除唯一约束<br>alter table stu drop index phone_number;</li>
</ol>
<h4 id="主键约束：primary-key"><a href="#主键约束：primary-key" class="headerlink" title="主键约束：primary key"></a>主键约束：primary key</h4><ol>
<li>注意：<ol>
<li>含义：非空且唯一</li>
<li>一张表就能有一个字段为主键</li>
<li>主键就是表中记录的唯一标识</li>
</ol>
</li>
<li>在创建表时添加主键约束<br>create table stu(id int primary key,<br>name varchar(20));</li>
<li>添加主键<br>alter table stu modify id primary key;</li>
<li>删除主键<br>alter table stu drop primary key;</li>
<li>自动增长<ol>
<li>概念：如果某一列是数值类型的，使用auto_increment 可以完成自动增长</li>
<li>在创建表时，添加主键约束，并且完成自动增长<br>create table stu(id int primary key auto_increment,phone_number varchar(20));<br>insert into stu values(10,’ccc’)；<br>insert into stu values(null,’ccc’);(null的位置会是11)；</li>
<li>删除自动增长<br>alter table stu modify id int;(主键删除不了就只能删除自动增长)</li>
<li>ALTER TABLE phone MODIFY id INT</li>
</ol>
</li>
</ol>
<h4 id="外键约束：foreign-key"><a href="#外键约束：foreign-key" class="headerlink" title="外键约束：foreign key"></a>外键约束：foreign key</h4><ol>
<li>在创建表时可以添加外键<ul>
<li>语法：<br>create table 表名(<br>…<br>外键列,<br>constraint 外键名称 foreign key (外键列的名称) references 主表名称(主列表名称));</li>
</ul>
</li>
<li>删除外键：</li>
</ol>
<ul>
<li>alter table stu drop foreign ket 外键的名称;</li>
</ul>
<ol start="3">
<li>添加外键：</li>
</ol>
<ul>
<li>alter table stu add constraint 外键的名称 foreign key refercences 主表名称(主表列名称)；</li>
</ul>
<ol start="4">
<li>级联：<ul>
<li>再添加外键的时候，在最后加上级联更新，级联删除<br>alter table stu add constraint 外键的名称 foreign key refercences 主表名称(主表列名称) on update cascade on delete cascade;</li>
<li>级联更新：on update cascade</li>
<li>级联删除：on delete cascade</li>
</ul>
</li>
</ol>
<h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><ol>
<li>多表之间的关系</li>
<li>数据库设计的范式</li>
</ol>
<h3 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h3><ol>
<li><p>分类：</p>
<ol>
<li>一对一：</li>
</ol>
<ul>
<li>如：身份证对人</li>
</ul>
<ol start="2">
<li>一对多（多对一）</li>
</ol>
<ul>
<li>部门和员工：一个部门有多个员工，一个员工只能对应一个部门</li>
</ul>
<ol start="3">
<li>多对多</li>
</ol>
<ul>
<li>学生和课程：一个学生可以选许多课程，一个课程也有许多学生</li>
</ul>
</li>
<li><p>实现关系：</p>
<ol>
<li>一对多（多对一）</li>
</ol>
<ul>
<li>在多的一方建立外键，来指向一的一方</li>
</ul>
<ol start="2">
<li>多对多</li>
</ol>
<ul>
<li>多对多的关系实现需要借助第三张中间表，中间表至少包含两个字段作为第三张表的外键，分别指向两张表主键</li>
</ul>
<ol start="3">
<li>一对一</li>
</ol>
<ul>
<li>可以在任意一方添加唯一外键指向另一方的主键</li>
</ul>
</li>
</ol>
<h6 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h6><p>旅游线路分类，旅游线路，用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tap_categroy(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment</span><br><span class="line">,cate <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">no</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>线路分类表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tap_route(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">no</span> <span class="keyword">null</span>,</span><br><span class="line">cate_id <span class="type">int</span>,</span><br><span class="line"><span class="keyword">foreign</span> key (cate_id) <span class="keyword">references</span> tap_categroy(id) <span class="keyword">on</span> <span class="keyword">update</span> cascade);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>线路表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">no</span> <span class="keyword">null</span>,</span><br><span class="line">phone <span class="type">int</span> <span class="keyword">no</span> <span class="keyword">null</span> <span class="keyword">unique</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>用户表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user_route(</span><br><span class="line">user_id <span class="type">int</span>,</span><br><span class="line">route_id <span class="type">int</span>,</span><br><span class="line"><span class="keyword">primary</span> key(user_id,route_id),</span><br><span class="line"><span class="keyword">foreign</span> key (user_id) <span class="keyword">references</span> <span class="keyword">user</span>(id),</span><br><span class="line"><span class="keyword">foreign</span> key (route_id) <span class="keyword">references</span> tap_route(id));</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>联合表</span><br></pre></td></tr></table></figure>

<h3 id="设计数据库的范式"><a href="#设计数据库的范式" class="headerlink" title="设计数据库的范式"></a>设计数据库的范式</h3><ol>
<li>分类：</li>
</ol>
<ul>
<li>第一范式(1NF)：每一列都是不可分割的原子数据项</li>
<li>第二范式(2NF)：在1NF的基础上，非码属性必须完全依赖于候选码(在1NF基础上消除非主属性对主码的部分函数依赖)<ol>
<li>函数依赖：A–&gt;B,通过A属性的值，可以确定唯一B属性的值，则称B依赖A<br>例如：学号–&gt;学生，(学号，课程)–&gt;成绩</li>
<li>完全函数依赖：A–&gt;B，如果A是一个属性组，则B属性值的确定依赖于A组所有的属性值<br>例如：(学号，课程)–&gt;成绩</li>
<li>部分函数依赖：A–&gt;B,A是一个属性组，B的确定需要A组的部分属性值来确定即可<br>例如：(学号，课程)–&gt;姓名</li>
<li>传递函数依赖：A–&gt;B,B–&gt;C,通过A确定唯一B，在通过B确定唯一C，则C传递函数依赖于A</li>
<li>码：如果一个属性或一个属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<br>例如：通过(学号，课程)能确定所有的其他属性，故(学号，课程)为该表的码<ul>
<li>主属性：码属性组中的所有属性</li>
<li>非主属性：其他属性组的属性</li>
</ul>
</li>
</ol>
</li>
<li>第三范式(3NF)：在2NF的基础上，任何非主属性不依赖于其他非主属性(2NF的记住上消除传递依赖)</li>
</ul>
<h3 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h3><ol>
<li>命令行：<ul>
<li>语法：mysqldump -u用户名 -p密码 数据库名称&gt;保存路径</li>
<li>还原：<ol>
<li>登录，创建，使用</li>
<li>执行文件。source 文件路径</li>
</ol>
</li>
</ul>
</li>
</ol>
<h5 id="注意编码要一致"><a href="#注意编码要一致" class="headerlink" title="注意编码要一致"></a>注意编码要一致</h5><ol start="2">
<li>使用Navicat Premium手动备份</li>
</ol>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul>
<li>查询语法：<br>select<br>   列名列表<br>from<br>   表名列表<br>where…</li>
<li>多表查询的分类</li>
<li>笛卡尔积：<ul>
<li>有两个集合A,B，取两个集合的所有情况组合</li>
<li>要完成多表查询，就要消除无用的情况</li>
</ul>
</li>
<li>分类：<ol>
<li>内连接查询：<ol>
<li>隐式的内连接：使用where条件消除无用的信息<br>select<br>t1.name,t2.name<br>from<br>t1,t2<br>where t1.’id’&#x3D;t2.’id’;</li>
<li>显式的内连接:<br>语法：select 字段列表 from 表名1 【inner】 join 表名2 on 条件<br>select * from<br>emp join dept<br>on emp.’id’&#x3D;dept.’id’;</li>
<li>内连接查询：<br>从哪些表中查询数据<br>条件是什么<br>查询哪些字段</li>
</ol>
</li>
<li>外连接查询：<ol>
<li>左外连接：<br>语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；<br>查询的是左表所有数据以及其交集</li>
<li>右外连接：select 字段列表 from 表1 right [outer] join 表2 on 条件；<br>查询的是右表所有数据以及其交集</li>
</ol>
</li>
<li>子查询：<ul>
<li>嵌套的查询就是子查询</li>
<li>select * from emp where emp.’salary’ &#x3D;(select MAX(salary) from emp); </li>
<li>子查询的情况：<ol>
<li>子查询的结果是单行单列的：<br>子查询可以作为条件，使用运算符去判断 &lt;,&gt;,&lt;&#x3D;等</li>
<li>子查询的结果是多行单列的：<br>子查询可以作为条件：使用in来判断</li>
<li>子查询的结果是多行多列的：<br>子查询可以作为一张虚拟表参与查询<br>select * from t1,(select id from t2 where id in(2,3)) t3 where t3.’id’&#x3D;t1.’id’</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h6 id="多表练习"><a href="#多表练习" class="headerlink" title="多表练习"></a>多表练习</h6><ol>
<li>查询所有员工信息。查询员工编号，姓名，工资，职务名称，职务描述</li>
<li>查询员工编号，姓名，工资，职务名称，职务描述，部门位置</li>
<li>查询员工姓名，工资，工资等级</li>
<li>查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工作等级</li>
<li>查询出部门编号，部门名称，部门位置，部门人数</li>
<li>查询出所有员工的姓名及其直接上级的姓名，没有领导的员工也要查询</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">select </span><br><span class="line">    employee.emname,</span><br><span class="line">    employee.salary,</span><br><span class="line">    job.jobname,</span><br><span class="line">    job.description,</span><br><span class="line">    department.demane, </span><br><span class="line">    department.address,</span><br><span class="line">    salary_grade.id</span><br><span class="line">from</span><br><span class="line">    employee,</span><br><span class="line">    job,department,salary_grade</span><br><span class="line">WHERE</span><br><span class="line">    employee.job_id=job.id AND     </span><br><span class="line">    employee.depart_id=department.id AND</span><br><span class="line">    employee.salary </span><br><span class="line">between </span><br><span class="line">    salary_grade.losalary </span><br><span class="line">and </span><br><span class="line">    salary_grade.hisalary;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">select </span><br><span class="line">    t1.emname,</span><br><span class="line">    t1.MGR,</span><br><span class="line">    t2.emname</span><br><span class="line">FROM</span><br><span class="line">employee t1</span><br><span class="line">left JOIN</span><br><span class="line">employee t2</span><br><span class="line">ON</span><br><span class="line">t1.MGR=t2.id</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的基本介绍"><a href="#事务的基本介绍" class="headerlink" title="事务的基本介绍"></a>事务的基本介绍</h3><ol>
<li><p>概念：<br>如果一个包含多个步骤的业务操作，被事务管理，要么同时成功，要么同时失败</p>
</li>
<li><p>操作;</p>
<ol>
<li><p>开启事务：start transcartion</p>
</li>
<li><p>回滚：rollback</p>
</li>
<li><p>提交事务：commit<br>start transaction;<br>commit;<br>rollback;</p>
</li>
<li><p>Mysql数据库中的事务默认自动提交<br>事务提交的两种方式：</p>
<ul>
<li>自动提交：一条DML(增删改)语句会自动提交一次事务</li>
<li>手动提交：需要先开启事务，在手动提交</li>
</ul>
<p>修改事务的默认提交方式：</p>
<ul>
<li>查看事务的默认提交方式：select @@autocommit;1–代表自动提交</li>
<li>修改事务的默认提交方式：set @@autocommit&#x3D;0;0–代表手动提交 oracle数据库默认手动提交</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="事务的四大基本特征"><a href="#事务的四大基本特征" class="headerlink" title="事务的四大基本特征"></a>事务的四大基本特征</h3><ol>
<li>原子性：不可分割的最小操作单位，要么同时成功，要么同时失败</li>
<li>持久性：事务结束后，数据库会持久的保存数据</li>
<li>隔离性：多个事务之间，相互独立</li>
<li>一致性：事务操作前后，数据总量不变</li>
</ol>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li><p>概念：多个事务之间操作同一批事务，则会引发一些问题，设置不同的隔离级别就能解决问题</p>
</li>
<li><p>问题：</p>
<ol>
<li>脏读：一个事务没有提交的数据</li>
<li>不可重复读(虚读)：在同一个事务中两次读取的数据不一样</li>
<li>幻读：一个事务操作数据表中的所有记录，另一个添加数据，则第一个事务查询不到自己的修改</li>
</ol>
</li>
<li><p>隔离级别：</p>
<ol>
<li>read uncommmitted:读未提交的<br>产生的问题：脏读，不可重复读，幻读</li>
<li>read committed:读已提交的（Oracle默认的）<br>产生的问题：不可重复读，幻读</li>
<li>repeatable read:可重复的（Myqsl默认的）<br>产生的问题：幻读</li>
<li>serializable:串行化（上锁）<br>可解决所有问题</li>
</ol>
<p>隔离级别从小到大安全性越高，效率越低<br>数据库查询隔离级别：<br>select @@tx_isolation;<br>数据库设置隔离级别：<br>set global transaction isolation level 级别字符串</p>
</li>
</ul>
<p>演示</p>
<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p>管理用户，授权</p>
<h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><ol>
<li>添加用户：create user ‘用户名‘@’主机名’ identified by ‘密码’;</li>
<li>删除用户:drop user ‘用户名‘@’主机名’</li>
<li>修改用户密码<ol>
<li>update user set password &#x3D;password(‘新密码’) where user &#x3D;’用户名’</li>
<li>set password for ‘用户名‘@’主机名’&#x3D;password(‘新密码’);</li>
</ol>
</li>
<li>查询用户：<br>切换到mysql：use mysql;<br>查询user表：select * from user;<ul>
<li>通配符：%表示任意用户登录(主机名)<br>忘记了密码</li>
</ul>
</li>
</ol>
<ul>
<li>cmd–&gt;net stop mysql停止服务</li>
<li>使用无验证启动mysql服务：mysqld –skip-grant-tables</li>
<li>打开新的cmd窗口，直接输入mysql命令，就能登录</li>
<li>use mysql;update user set password &#x3D; password(‘新的密码’) where user &#x3D;’root’;</li>
<li>关闭那两个窗口，打开任务管理器，手动结束mysql，exe服务</li>
<li>启动mysql服务</li>
<li>使用新密码登录</li>
</ul>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><ol>
<li>查询权限：show grants for ‘用户名‘@’主机名’；</li>
<li>授予权限：grand 权限列表 on 数据库名，表名 to ‘用户名‘@’主机名’<br>grand select on db1.stu to ‘root‘@’%’;<br>grand all on <em>.</em> to ‘root‘@’%’;</li>
<li>撤销权限：revoke 权限列表 on 数据库名.表名 from ‘用户名‘@’主机名’</li>
</ol>
<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ol>
<li><ul>
<li>概念：java database connectivity java数据库连接，java语言操作数据库</li>
<li>本质：官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这接口编程，真正执行这套代码的是驱动jar包的实现类</li>
</ul>
</li>
</ol>
<h2 id="2-快速入门："><a href="#2-快速入门：" class="headerlink" title="2. 快速入门："></a>2. 快速入门：</h2><p>   步骤：</p>
<pre><code>  1. 导入驱动jar包
     复制到某个目录下：mysql-connector-j-8.4.0.jar
     右键---&gt;add as library
  2. 注册驱动
     Class.forName(&quot;com.mtsql.jdbc.Driver&quot;);
  3. 获取数据库连接对象Connection
     Connection conn=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db1&quot;,&quot;root&quot;,&quot;ROOT&quot;);
  4. 定义sql
     String sql=&quot;update stu set name=&quot;王五&quot; where id=1&quot;;
  5. 获取执行sql语句的对象Statement
     Statement stmt=conn.createStatement();
  6. 执行sql,接受返回结果
     int count = stmt(sql);
  7. 处理结果
     System.out.println(count);
  8. 释放资源
     stat.close();
     conn.close();
</code></pre>
<h2 id="3-详解各个对象"><a href="#3-详解各个对象" class="headerlink" title="3.详解各个对象"></a>3.详解各个对象</h2><h4 id="DriverManager-驱动管理对象"><a href="#DriverManager-驱动管理对象" class="headerlink" title="DriverManager:驱动管理对象"></a>DriverManager:驱动管理对象</h4><p>功能：</p>
<ol>
<li><p>注册驱动：告诉程序要用什么接口</p>
<ul>
<li>state void registerDriver(Driver driver):注册与给定的驱动程序DriverManager</li>
<li>写Class.forName(“com.mysql.jdbc.Driver”);有静态代码块帮助其注册</li>
<li>注意：jar有注册驱动的，可不写</li>
</ul>
</li>
<li><p>获取数据库的连接：</p>
<ul>
<li>方法：state Connection getConnection(String url,String user,String password)</li>
<li>参数：指定链接线</li>
<li>jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称</li>
<li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db2</li>
<li>若是本机可简写：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称</li>
<li>user:用户名</li>
<li>password：密码</li>
</ul>
</li>
</ol>
<h4 id="Connection-数据库连接对象"><a href="#Connection-数据库连接对象" class="headerlink" title="Connection:数据库连接对象"></a>Connection:数据库连接对象</h4><p>功能：</p>
<ol>
<li>获取执行sql的对象<br>Statement createStatement()<br>PreparedStatement prepareStatement(String sql)</li>
<li>管理事务：<br>开启事务：setAutoCommit(boolean autoCommit):调用该方法设置参数为false,即开启事务<br>提交事务：commit()<br>回滚事务：rollback()</li>
</ol>
<h4 id="Statement-执行sql的对象"><a href="#Statement-执行sql的对象" class="headerlink" title="Statement:执行sql的对象"></a>Statement:执行sql的对象</h4><ol>
<li>用于执行静态sql<ul>
<li>booolean execute(String sql)</li>
<li>int executeUpdate(String sql)：执行DML语句(insert Update,delete)语句,DDL语句(create,alter,drop)语句<br>返回值：影响的行数，可以判断DML语句是否执行成功，DDL语句无返回值</li>
<li>ResultSet executeQuery(String sql):执行DQL(select)语句</li>
</ul>
</li>
</ol>
<h4 id="ResultSet-结果集对象"><a href="#ResultSet-结果集对象" class="headerlink" title="ResultSet:结果集对象"></a>ResultSet:结果集对象</h4><ul>
<li>next():游标向下移动一行，判断当前行是否是最后一行，返回false,则是最后一行</li>
<li>getxxx(参数):获取数据<br>xxx代表数据类型 如int i&#x3D;c.getint();<br>参数<ul>
<li>int:列的编号，从1开始。getString(1);</li>
<li>String:代表列的名称。getString(“name”);</li>
</ul>
</li>
<li>注意：<ol>
<li>游标向下移动一行</li>
<li>判断是否有数据</li>
<li>获取数据</li>
</ol>
</li>
</ul>
<h6 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h6><ol>
<li>定义一个Emp类</li>
<li>定义方法<code> public List&lt;Emp&gt; findAll()&#123;&#125;</code></li>
<li>实现方法 select * from emp;</li>
</ol>
<h6 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h6><p>需求：</p>
<ol>
<li><p>通过键盘录入用户名和方法</p>
</li>
<li><p>判断是否登录成功</p>
<p>select * from user where username&#x3D;””and password””;</p>
<p>若sql的查询有结果，则成功</p>
</li>
</ol>
<p>步骤：</p>
<ol>
<li>创建数据库表user</li>
<li></li>
</ol>
<h4 id="PreparedStatement-执行sql的对象"><a href="#PreparedStatement-执行sql的对象" class="headerlink" title="PreparedStatement:执行sql的对象"></a>PreparedStatement:执行sql的对象</h4><p>SQL注入问题：在拼接sql时，有一些特殊的关键字参与字符串的拼接，会造成安全性问题</p>
<pre><code>  1. 用户名随便，密码：a&#39; or &#39;a&#39;=&#39;a&#39;
  2. sql: select * from user where username=&#39;www&#39; and password = &#39;a&#39; or &#39;a&#39;=&#39;a&#39;
</code></pre>
<ul>
<li><p>使用preparedStatement对象来解决问题</p>
</li>
<li><p>预编译的sql：参数使用？作为占位符</p>
</li>
<li><p>PreparedStatement pre&#x3D;Connection.PrepareStatement(stl);</p>
</li>
<li><p>给?赋值：<br>setXxx(参数1，参数2)<br>参数1：？的位置编号<br>参数2：？的值<br>执行时就不用赋值了<br>pstmt.setString(1,username)<br>pstmt.setString(2,password)</p>
</li>
</ul>
<h5 id="最终步骤："><a href="#最终步骤：" class="headerlink" title="最终步骤："></a>最终步骤：</h5><ol>
<li><p>导入驱动jar包</p>
</li>
<li><p>注册驱动</p>
</li>
<li><p>获取数据库连接对象Connection</p>
</li>
<li><p>定义sql</p>
<p>注意：select * from user where username&#x3D;? and password &#x3D;?</p>
</li>
<li><p>获取执行sql语句的对象，PreparedStatement stmt&#x3D;conn.PrepareStatement(sql);</p>
</li>
<li><p>给？赋值<br>prep.setString(1,username)</p>
<p>prep.setString(2,password)</p>
</li>
<li><p>执行sql不再传sql语句</p>
</li>
<li><p>处理结果</p>
</li>
<li><p>释放资源</p>
</li>
</ol>
<h3 id="抽取JDBC工具类：JDBCUtils"><a href="#抽取JDBC工具类：JDBCUtils" class="headerlink" title="抽取JDBC工具类：JDBCUtils"></a>抽取JDBC工具类：JDBCUtils</h3><ol>
<li>注册驱动也抽取</li>
<li>抽取方法获取连接对象<br>public static Connection getConnection(){}<br>public static void close(Statement stmt,Connection conn){}</li>
</ol>
<h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><p>使用Connection对象来管理事务</p>
<ol>
<li>开始事务：setAutoCommetion(boolean aUtoCommit):调用方法设置参数为false 即开启事务</li>
</ol>
<ul>
<li>在sql执行之前开启事务</li>
</ul>
<ol start="2">
<li>回滚：rollback()</li>
</ol>
<ul>
<li>在异常中回滚事务</li>
</ul>
<ol start="3">
<li>提交事务:commit()</li>
</ol>
<ul>
<li>当所有sql执行完后提交事务</li>
</ul>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>概念：是一个容器(集合)，存放数据库连接的容器<br>   当系统初始化好后，容器会申请一些连接对象，当用户来访问数据库时，从容器中链接对象，用户访问完成之后，会将连接对象归还给容器<br>好处：节约资源，用户访问高效<br>实现：</p>
<ol>
<li>标准接口：DateSource javax.sql包下的<br>方法：<ol>
<li>获取连接：getConnection()</li>
<li>归还连接：如果链接对象是从连接池中获取的，那么connection.close()方法则不会关闭连接，而是归还</li>
</ol>
</li>
<li>一般我们不去实现它，有数据厂商去实现<ol>
<li>C3P0：数据库连接池技术</li>
<li>Druid:数据库连接池实现技术，阿里巴巴提供</li>
</ol>
</li>
</ol>
<p>C3P0连接池技术</p>
<ol>
<li>导入jar包两个：c3p0-0.9.5.5.jar和mchange-commons-java-0.2.19.jar</li>
<li>定义配置文件</li>
</ol>
<ul>
<li>名称：c3p0.properties或c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下<br>3.创建核心对象：数据库连接池对象ComboPooledDataSource<br>4.获取连接：getConnection</li>
</ul>
<p>druid连接池技术<br>步骤：<br> 1.导入jar包druid.jar<br> 2.定义配置文件：<br>    是properties的形式<br>    可以叫任意名称，放在任意目录下</p>
<ol start="3">
<li><p>获取数据库连接池对象：通过工厂来获</p>
<p>DruidDataSourceFactory<br>DataSource ds&#x3D;DruidDataSourceFactory.createDataSource(pro)</p>
</li>
<li><p>获取连接：getConnection()<br>定义一个工具类</p>
</li>
<li><p>定义一个类 JDBCUtils</p>
</li>
<li><p>提供静态代码块加载配置文件，初始化连接池对象</p>
</li>
<li><p>提供方法</p>
<ol>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>
<li>获取连接池的方法</li>
</ol>
</li>
</ol>
<h2 id="Spring-JDBC：JDBC-Template"><a href="#Spring-JDBC：JDBC-Template" class="headerlink" title="Spring  JDBC：JDBC  Template"></a>Spring  JDBC：JDBC  Template</h2><ul>
<li><p>Spring框架对JDBC的简单封装，提供了一个JDBCTemplated对象简化JDBC的开发</p>
</li>
<li><p>步骤：</p>
<ol>
<li>导入jar包</li>
<li>创建jdbcTemplate对象,依赖于数据源DataSource<br>JdbcTemplate template&#x3D;new JdbcTemplate(DataSource ds)</li>
<li>调用JdbcTemplate的方法来实现CRUD的操作</li>
</ol>
<ul>
<li><p>update():执行DML语句。增删改</p>
</li>
<li><p>queryForMap():查询结果将结果集封装为map集合</p>
</li>
<li><p>queryForList():查询结果将结果封装为List集合</p>
</li>
<li><p>query():查询结果，将结果封装为JavaBean对象</p>
</li>
<li><p>queryForObject(sql,Object):查询结果，将结果封装为对象<br>练习：<br>需求</p>
<ol>
<li>添加一号数据的salary 为10000</li>
<li>添加一条记录</li>
<li>删除刚才的记录</li>
<li>查询di为1的记录，将其封装为Map集合</li>
<li>查询所有记录，将其封装为List集合</li>
<li>查询所有记录将其封装为Emp对象的List集合</li>
<li>查询总记录数</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Web概念概述"><a href="#Web概念概述" class="headerlink" title="Web概念概述"></a>Web概念概述</h2><ul>
<li><p>javaweb</p>
</li>
<li><p>软件架构：<br>1.c&#x2F;s架构：Client&#x2F;Server 客户端&#x2F;服务器端</p>
<ul>
<li>在用户本地有一个客户端，在远程有一个服务器端程序</li>
<li>如qq…</li>
<li>优点：用户体验好</li>
<li>缺点：开发，安装，部署，维护麻烦</li>
</ul>
<ol start="2">
<li>B&#x2F;S:Browser&#x2F;Server 浏览器&#x2F;服务器端</li>
</ol>
<ul>
<li>只需要一个浏览器，用户就可以访问不同的网址</li>
<li>优点：开发，安装，部署，维护简单</li>
<li>缺点：应用过大，用户体验可能受到影响，对硬件要求过高</li>
</ul>
</li>
</ul>
<p>B&#x2F;S架构详解</p>
<ul>
<li><p>资源分类：<br>1.静态资源<br>使用静态资源开发的网页<br>特点：</p>
<ul>
<li>所有用户访问的结果一样</li>
<li>如：文本，图片，HTML，CSS,JavaScript</li>
<li>如果用户请求静态资源服务器会直接将静态资源发送给浏览器。浏览器内置了解析引擎，可以展示静态资源</li>
</ul>
<ol start="2">
<li>动态资源<br>使用动态网页及时发布的资源<br>特点：</li>
</ol>
<ul>
<li>所有用户访问的结果可能不一样</li>
<li>如：jsp&#x2F;servlet,php,asp…</li>
<li>如果用户请求的是动态资源，那么服务器会执行动态资源，再转换成静态资源，发送给浏览器</li>
</ul>
</li>
<li><p>静态资源：</p>
</li>
<li><p>HTML:用于搭建基础网页，展示页面的内容</p>
</li>
<li><p>CSS:用于美化页面，布局页面</p>
</li>
<li><p>JavaScript:控制页面的元素，额那个页面有一些动态的效果</p>
</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>是最基础的网页编程语言</p>
<ul>
<li>Hyper Text Markup Language 超文本标记语言<br>超文本：使用超链接的方法来，将不同空间的文字信息组织到一起的网状文本<br>标记语言：由标签构成的语言。&lt;标签名称&gt;如html,xml<br>标记语言不是编程语言<br>*** 快速入门</li>
</ul>
<ol>
<li>语法</li>
<li>html文档后缀名.html或.htm</li>
<li>标签分为：</li>
</ol>
<pre><code>* 围堵标签：有开始和结束标签。如&lt;html&gt;&lt;/html&gt;
* 自闭和标签：开始标签和结束标签在一起。如&lt;br/&gt;

3. 标签可以嵌套：

* 需要正确的嵌套，不能你中有我，我中有你
* 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;
* 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;

4. 在开始标签中可以自定义属性。属性有键值对构成，只需要用引号(单双都可以)引起来
5. 在html中不区别大小写，但建议小写
</code></pre>
<ol start="6">
<li>标签学习<br>7. 文件标签：构成html最基本的标签</li>
</ol>
<pre><code>* html：html文档的根标签
* head:头标签。用于指定hrml文档的一些属性。引入外部类
* title:标题标签
* body:体标签
* &lt;!DOCTYPE&gt;?

2. 文本标签：和文本有关的

* 注释：&lt;!-- 内容--&gt;
* &lt;h1&gt; to &lt;h6&gt;：标题标签 h1字体最大
* &lt;br&gt;:换行
* &lt;p&gt;:段落标签
* &lt;hr&gt;:显示一条水平线
* &lt;hr color=&quot;red&quot;,width(宽度)=&quot;200&quot;,size(高度)=&quot;10&quot;,align(对齐方式)=&quot;center(居中)&quot;&gt;
* &lt;b&gt;:字体加粗
* &lt;i&gt;:字体斜体
* &lt;font&gt;:字体标签
  属性：
  * color:颜色
  * size:大小
  * face:字体
  属性定义：
  * color:
    英文单词：red,green,blue
    三原色（红绿蓝）rgb*(值1，值2，值3)：0~255,rgb(1,1,232)
    #值1值2值3:00~FF,如#00FFFF
  * width:
    1. 数值：width=&#39;20&#39;,数值的单位默认是px(像素)
    2. 数值%：占比父元素的比例

3. 图片标签：

* img标签
   src:指定图片的位置
   相对路径
   * 以.开头
   * ./:代表当前目录
   * ../:代表退一个目录

4. 列表标签

* 有序列表：
  ol:定义有序列表
  li:项
* 无序列表：
  ul:定义无序列表
  li:项

5. 链接标签

a:定义一个超链接
* 属性：
  href:能指定访问资源的URL(统一资源定位符)
  target:制定打开资源的方式
  1. _self:在本页面内打开
  2. —blank:在空白页面打开

6. div和span

div:会换行，每一个div占满一整行，块级标签
span:文本信息在一行展示，行内标签 内联标签

7. 语义化标签
   1. header2. footer
8. 表格标签

&lt;table&gt;:定义表格
属性：
  borde:边框
  width:宽度
  cellpadding:定义内容和单元格之间的距离
  cellspacing:定义单元格之间的距离，若为0则单元格的线会合为一条
  bgcolor:背景色
  align:对齐方式
&lt;tr&gt;:定义行
* bgcolor
* align:所有文本的对其方式
&lt;td&gt;:定义单元格
* colspan:合并列
* rowspan:合并行
&lt;th&gt;:定义表头单元格
&lt;caption&gt;:表格标题
&lt;thead&gt;:表示表格的头
&lt;tbody&gt;表示表格的体
&lt;tfoot&gt;:表示表格的脚

9. 表单标签

概念：用于采集用户输入的数据的用于和服务器用于交互
使用的标签：
* form:用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围
* 属性：
 * action:指定提交数据的URL
 * method:指定提交方式
   get:
   1. 请求参数会在地址栏中显示
   2. 请求参数的大小有限制
   3. 不太安全
   post:
   1. 请求参数不会再地址栏中显示，会封装在请求体中(HTTP)协议中
   2. 请求参数大小没有限制
   3. 安全

 表单项中的数据要想被提交，要指定其name属性
 
表单项：
* input:可以通过type的属性值，来改变元素样式
 label:指定输入项的文字描述信息
* type:
  * for属性一般会会和input的ID对应，则点击lable会让input输入框获取焦点
  text:文本输入框,默认值
  * placeholder:指定输入框的内容，当输入框发生变化会自动清空提示信息
  password:密码输入框
  radio：单选框
  * 注意：要想让多个单选框实现单选的效果，则多个单选框的name属性值要一样
  * 一般会给每一个单选框一个value值，来提交
  checkbox:复选框 
  * checked:可以指定默认值
  * 一般会给每一个多选框一个value值，来提交
  file:文件选择框
  hidden:隐藏域，用于提交一些信息
  submit:按钮，可以提交表单
  button:按钮普通
  image:图片提交按钮
  * src可以指定图片
  date:日期
  emlie：电子邮件
  number：数字
* select:下拉列表
  option:指定列表项
* textarea:文本域
  cols:每行的字符，列数
  rows:几行，行数
</code></pre>
<h6 id="旅游网站的首页"><a href="#旅游网站的首页" class="headerlink" title="旅游网站的首页"></a>旅游网站的首页</h6><ol>
<li>确定布局，table</li>
<li>如果某一行只有一个单元格，则使用<br><code>&lt;td&gt;&lt;tr&gt;&lt;/td&gt;&lt;/tr&gt; </code></li>
<li>如果某一行有多个单元格，则使用表格嵌套</li>
</ol>
<p><code>&lt;tr&gt;&lt;td&gt; &lt;table&gt;&lt;/table&gt;&lt;tr&gt;&lt;td&gt;</code></p>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>页面美化和布局控制</p>
<ol>
<li><p>概念：cascadiong style sheets 层叠样式表<br> 层叠：多个样式可以作用在同一个html上，同时生效</p>
</li>
<li><p>好处：<br>功能强大，将内容的展示和样式控制分离<br>  降低耦合度，可以提高工作效率，可以协调分工</p>
</li>
<li><p>css的使用：css与 html的结合</p>
<p>内联样式： 在标签内使用style属性指定css代码</p>
<p>内部样式：在head标签内定义style标签，style的标签体内容就是css代码<br><code>&lt;style&gt; div&#123; color:blue&#125;&lt;style&gt;&lt;div&gt;hellow css&lt;div&gt;</code></p>
<p>外部样式:</p>
<p>定义css资源标签</p>
<p>在head标签内定义link标签，引入外部的资源文件<br>a.css文件：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">div&#123;color:green;&#125;</span><br><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;css/a.css&quot;</span></span><br><span class="line"></span><br><span class="line">div hellow&lt;div&gt;</span><br><span class="line">   style&gt;<span class="meta">@import</span> <span class="string">&quot;css/a.css&quot;</span>;&lt;style&gt;</span><br><span class="line">      <span class="comment">//注意：1,2,3种方式作用范围越来越大</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>语法：</li>
</ol>
</li>
</ol>
<p>​    格式：选择器{<br>属性名1：属性值1;<br>…<br>}<br>​      选择器：筛选具有相似特征的元素<br>注意</p>
<pre><code>  * 每一对属性需要使用；隔开最后一对属性可以不加;
</code></pre>
<ol start="5">
<li><p>选择器</p>
</li>
<li><p>分类：<br> 基本选择器：</p>
<ol>
<li>ID选择器：选择器具体的ID属性值的元素:建议           在一个html中的id是唯一的<br>语法：#id属性值{}</li>
</ol>
<p><code>&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</code></p>
<p><code>&lt;div&gt;hellow&lt;/div&gt;</code></p>
<pre><code>  2. 元素选择器：选择具有相同名称的元素
     标签名称&#123;&#125;
     注意:id选择器比元素选择器级别更高
  3. 类选择器
     语法: .class属性值&#123;&#125;
         注意：类选择器的优先级比元素选择器高
</code></pre>
</li>
<li><p>扩展选择器:</p>
<ol>
<li>选择所有元素 : *{}</li>
<li>并集选择器：选择器1,选择器2{}</li>
<li>子选择器：选择器1 选择器2。筛选1下的2 </li>
<li>父选择器：选择器1&gt;选择器2 筛选2的父选择器1</li>
<li>属性选择器：选择元素名称，属性名&#x3D;属性值的元素<br>元素名称[属性名&#x3D;“属性值”]{}</li>
<li>伪类选择器：选择元素的状态<br>元素：状态<br>如：<code>&lt;a&gt;</code><br>状态：<br>link:初始状态<br>hover：鼠标悬浮<br>active：正在访问<br>visited:被访问过了</li>
</ol>
</li>
<li><p>属性</p>
<ol>
<li>文本，字体<br>font-size:字体大小<br>color:文本颜色<br>text-align:对齐方式<br>line-height:行高</li>
<li>背景<br>background:url color no-repeat center</li>
<li>边框<br>border:</li>
<li>尺寸<br>width:宽度<br>height:高度</li>
<li>盒子模型:控制布局<br>margin:外边距<br>padding:内边距<br>默认情况下内边距会影响盒子的大小<br>box-sizing:border-box;设置盒子的属性，让width和height就是盒子的最终的大小<br> float:浮动<br> left<br> right</li>
</ol>
</li>
</ol>
<h6 id="案例注册页面"><a href="#案例注册页面" class="headerlink" title="案例注册页面"></a>案例注册页面</h6><p>​      </p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>概念:一门客户端脚本语言</p>
<ul>
<li>运行在客户端浏览器中，每一个浏览器都有JavaScript的解析引擎</li>
<li>脚本语言：不需要编译，直接就可以被浏览器解析执行了</li>
</ul>
<p>功能：</p>
<ul>
<li>可以来增强用户和html页面的交互过程，可以来控制元素，让页面有一些动态的效果，增强用户的体验</li>
</ul>
<p>javaScript发展史：</p>
<ol>
<li>1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验，为c–，更名为ScriptEase</li>
<li>1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript.后来请sun公司的人来开发为JavaScript</li>
<li>1996年，微软抄袭JavaScript开发出JScript语言</li>
<li>1997年，ECMA(欧洲计算机制造商协会)，ECMAScript,就是所有客户端脚本语言的标准</li>
</ol>
<p>JavaScript&#x3D;ECMAScript+javaScript自己特有的东西(BOM+DOM)</p>
<h2 id="ECMASricpt"><a href="#ECMASricpt" class="headerlink" title="ECMASricpt:"></a>ECMASricpt:</h2><p>客户端脚本语言标准</p>
<h3 id="1基本语法："><a href="#1基本语法：" class="headerlink" title="1基本语法："></a>1基本语法：</h3><h5 id="与html的结合方式"><a href="#与html的结合方式" class="headerlink" title="与html的结合方式"></a>与html的结合方式</h5><ol>
<li><p>内部JS：<code>&lt;script&gt;</code>script语句的代码《script》 </p>
</li>
<li><p>外部JS：dingyiscript标签通过src引入外部的js文件</p>
<p>注意《script》可一定要在任何的地方，但是定义的位置会影响执行顺序</p>
<p>《script》可以定义多个</p>
</li>
</ol>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><ol>
<li>单行注释：&#x2F;&#x2F;</li>
<li>多行注释:&#x2F;*  *&#x2F;</li>
</ol>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ol>
<li><p>原始数据类型（基本数据类型）：</p>
<p>numder:数字。整数&#x2F;小数&#x2F;NaN(not a number 不是一个数字的数字类型）</p>
<p>string：字符串。”abc”</p>
<p>boolean:true false</p>
<p>null:对象为空</p>
<p>undefined:未定义。若未有初始化，则默认赋值为undefined</p>
</li>
<li><p>引用数据类型：对象</p>
</li>
</ol>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul>
<li><p>变量：一小块存储数据的内存空间</p>
</li>
<li><p>java是强类型的语言，javaScritp是弱类型的语言</p>
<p>在开辟变量存储空间时定不定义数据类型，不定义可存储任意类型的数据</p>
</li>
<li><p>var 变量名&#x3D;值（定义变量都是用这个）</p>
</li>
<li><p>typeof()查看数据类型</p>
</li>
<li><p>document.write():在页面内输出</p>
</li>
<li><p>alert(a):在页面弹出</p>
</li>
</ul>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ol>
<li><p>一元运算符：</p>
<p>++，–，+(正号)</p>
<p>在js中运算数不是运算符所要求的，js引擎会自动进行类型转换</p>
<p>其他类转number:</p>
<ul>
<li>string转number:按照字面值转换，字面值不是数字会转成NaN</li>
<li>boolean转number:true为1，false为0</li>
</ul>
</li>
<li><p>算术运算符</p>
<p>+,-,*,&#x2F;,%</p>
</li>
<li><p>赋值运算符</p>
<p>&#x3D;,+&#x3D; -&#x3D; </p>
</li>
<li><p>比较运算符</p>
<p>&lt; &gt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;(全等)</p>
<p>类型相同：直接比较</p>
<p>  字符串：按照字典顺序比较，按位逐一比较，直到得出大小为止</p>
<p>类型不同：先进行类型转换，再比较</p>
<p>&#x3D;&#x3D;&#x3D;全等。在比较之前先判断类型，若不一样则直接放回false</p>
</li>
<li><p>逻辑运算符</p>
<p>&amp;&amp; || !</p>
<p>其他类型转boolean：</p>
<ol>
<li>number:0或NaN为假，其他为真</li>
<li>string:除了空字符串(“ “)，其他都为true</li>
<li>null&amp;undefined:都是false</li>
<li>对象:都是true</li>
</ol>
</li>
<li><p>三元运算符</p>
<p>? :表达式 a&#x3D;b&gt;c?b:c</p>
</li>
</ol>
<h5 id="流程控制语句："><a href="#流程控制语句：" class="headerlink" title="流程控制语句："></a>流程控制语句：</h5><ol>
<li><p>if…else</p>
</li>
<li><p>switch:</p>
<p>在java中可以接收的数据类型：byte，int,shor,char</p>
<p>在JS中什么都可以接受</p>
</li>
<li><p>while</p>
</li>
<li><p>do…while</p>
</li>
<li><p>for</p>
</li>
</ol>
<h5 id="JS特殊语法："><a href="#JS特殊语法：" class="headerlink" title="JS特殊语法："></a>JS特殊语法：</h5><ol>
<li><p>语句以；结尾，如果一行只有一条语句；可以省略(不建议)</p>
</li>
<li><p>变量定义使用var关键字，也可以不一样</p>
<p>使用：定义的是局部变量</p>
<p>不用：定义的是全局变量(不建议)</p>
</li>
</ol>
<h3 id="2对象"><a href="#2对象" class="headerlink" title="2对象"></a>2对象</h3><h4 id="基本对象："><a href="#基本对象：" class="headerlink" title="基本对象："></a>基本对象：</h4><h5 id="Function-函数（方法）对象"><a href="#Function-函数（方法）对象" class="headerlink" title="Function:函数（方法）对象"></a>Function:函数（方法）对象</h5><ol>
<li><p>创建：</p>
<p>var fun &#x3D; new Function(形参，方法体)；</p>
<p>function 方法名称(形参列表){}</p>
<p>var 方法名 &#x3D; function(形参){}</p>
</li>
<li><p>方法</p>
</li>
<li><p>属性：</p>
<p>length:长度</p>
</li>
<li><p>特点：</p>
<p>方法定义时类型不用写</p>
<p>方法是一个对象，会覆盖</p>
<p>在JS中方法的调用只与方法名称有关，和参数无关</p>
<p>在方法声明中，会有一个内置对象（数组），argument,封装所有的实际参数</p>
</li>
<li><p>调用：</p>
<p>方法名称(实际参数列表)</p>
</li>
</ol>
<h5 id="Array：数组对象"><a href="#Array：数组对象" class="headerlink" title="Array：数组对象"></a>Array：数组对象</h5><ol>
<li><p>创建：</p>
<p>var arr&#x3D;new Array(元素列表)；</p>
<p>var arr &#x3D;new Array(默认长度)；</p>
<p>var arr &#x3D; [元素列表]；</p>
</li>
<li><p>方法</p>
<p>join(拼接的参数，（如，-等）):将数组中的元素拼接成字符串</p>
<p>push(参数):向数组尾部添加元素并返回新的长度</p>
</li>
<li><p>属性</p>
<p>length:长度</p>
</li>
<li><p>特点</p>
<ol>
<li>JS中元素类型可变</li>
<li>JS中数组的长度是可变的</li>
</ol>
</li>
</ol>
<p>Boolean:基本数据类型的包装类</p>
<h5 id="Date-日期对象"><a href="#Date-日期对象" class="headerlink" title="Date:日期对象"></a>Date:日期对象</h5><ol>
<li><p>创建</p>
<p>var date&#x3D;new Date();</p>
</li>
<li><p>方法</p>
<p>toLocaleString():返回当前date对象对应的时间本地字符串格式</p>
<p>getTime():获取毫秒值。返回当前对象描述的时间到1970年1月1日0点的毫秒差</p>
</li>
</ol>
<h5 id="Math-数学对象"><a href="#Math-数学对象" class="headerlink" title="Math:数学对象"></a>Math:数学对象</h5><ol>
<li><p>创建</p>
<ol>
<li>特点：Math不用创建，直接使用 Math.方法名()</li>
</ol>
</li>
<li><p>方法</p>
<p>random():返回0~1的随机数，含0不含1</p>
<p>ceil(x):对数进行上舍入</p>
<p>floor(x):对数进行下舍入</p>
<p>round(x):把数四舍五入为最接近的整数</p>
</li>
<li><p>属性</p>
<ul>
<li>PI：圆周率</li>
</ul>
</li>
<li><p>例：var number&#x3D;Math.floor((Math.random()*100))+1</p>
</li>
</ol>
<p>Number</p>
<p>String</p>
<h5 id="RegExp-正则表达式对象"><a href="#RegExp-正则表达式对象" class="headerlink" title="RegExp:正则表达式对象"></a>RegExp:正则表达式对象</h5><ol>
<li><p>正则表达式：定义字符串的组成规则的</p>
<p>单个字符：[  ] [a] [ab] (a或b) [a-z] (a到z)</p>
<ul>
<li>特殊符号代表特殊含义的单个字符</li>
<li>\d:单个字符[0-9]</li>
<li>\w:单个单词字符[a-zA-Z0-9_]</li>
</ul>
<p>量词符号：\w{8,18}</p>
<ul>
<li><p>?:表示出现0次或1次</p>
</li>
<li><p>*：出现0次或多次</p>
</li>
<li><p>+：出现1次或多次</p>
</li>
<li><p>{m,n}:表示m&lt;&#x3D;数量&lt;&#x3D;n</p>
<p>m如果缺省：{,n}:最多n次</p>
<p>n如果缺省：{m,}：最少m次</p>
</li>
</ul>
</li>
<li><p>创建：</p>
<p>var reg&#x3D;new RegExp(“正则表达式”)；</p>
<p>var reg &#x3D; &#x2F;正则表达式&#x2F;；</p>
<p>var reg&#x3D; &#x2F;^\w{5-56}$&#x2F;</p>
<p>开始结束符号：^开始$结束</p>
</li>
<li><p>方法：</p>
<p>test(参数):验证指定字符串是否符合规则</p>
</li>
</ol>
<h5 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h5><ol>
<li><p>特点：全局对象，不需要对象就可以直接调用 </p>
<p>方法名()</p>
</li>
<li><p>方法：</p>
<p>encodeUPI():url编码</p>
<p>decodeUPI():url解码</p>
<p>encodeUPIComponent():url编码,编码的字符更多</p>
<p>decodeUPIComponent():url解码，编码的字符更多</p>
<p>eval():将JS的字符串作为脚本代码去实现</p>
<p>isNaN():判断是否是NaN</p>
<ul>
<li>NaN六亲不认，NaN参与的&#x3D;&#x3D;比较都为false</li>
</ul>
<p>parsdeInt():将字符串转为数字</p>
<ul>
<li>逐一判断每一个字符是不是数字，直到不是数字停止，将前面的数字转为number</li>
</ul>
</li>
</ol>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><ol>
<li>概念：Borwser Object Model 浏览器对象模型</li>
</ol>
<ul>
<li>将浏览器的各个组成部分封装成各个对象</li>
</ul>
<ol start="2">
<li>组成：</li>
</ol>
<ul>
<li><p>Navigator:浏览器对象</p>
</li>
<li><p>window:窗口对象</p>
<ol>
<li><p>创建：</p>
</li>
<li><p>方法：</p>
<p>与弹出框有关</p>
<ul>
<li><p>alert():显示带有一段消息和一个确认按钮的警告框</p>
</li>
<li><p>confirm():显示带有一段消息以及确定和取消按钮的对话框</p>
<p>点击确认按钮，返回true</p>
<p>点击取消按钮，返回false</p>
</li>
<li><p>prompt(“可写提示的内容”)：显示可提示的输入框</p>
<p>返回值：获取用户输入的值</p>
</li>
</ul>
<p>与打开关闭有关</p>
<ul>
<li><p>open(“网址”):打开一个新窗口</p>
</li>
<li><p>close():关闭窗口</p>
<p>关闭调用的窗口，让open(“”)赋值给一个对象，用它调用close,关闭那个窗口</p>
</li>
</ul>
<p>与定时器有关的方法：</p>
<ul>
<li><p>setTimeout():指定一个时间后执行一个函数，一次性的</p>
<p>参数：</p>
<p>第一个为方法或js代码，</p>
<p>第二个为时间，毫秒值1s&#x3D;1000毫秒</p>
<p>返回值：唯一标识，用于取消定时器</p>
</li>
<li><p>clearTimeout()：取消由setTimeout设定的定时器</p>
</li>
<li><p>setInterval():循环定时器</p>
</li>
<li><p>clearInterval()：取消定时器</p>
</li>
<li><p>案例：var r&#x3D;setTimeout(“alert(“aq”)”,2000)；clearTimeout(r);</p>
</li>
</ul>
</li>
<li><p>属性：</p>
<p>获取其他BOM对象</p>
<ul>
<li>history</li>
<li>screen</li>
<li>location</li>
<li>Navigator</li>
</ul>
<p>获取DOM对象 document.write()</p>
</li>
<li><p>特点：</p>
<p>window对象不用创建直接使用，window.方法名()</p>
<p>window可以不用引用</p>
</li>
</ol>
</li>
<li><p>Screen:显示器屏幕对象</p>
</li>
<li><p>History:历史记录对象</p>
<ol>
<li><p>创建：</p>
<p>window.history</p>
<p>history</p>
</li>
<li><p>方法</p>
<p>back():加载history列表中的前一个URL</p>
<p>forward()：加载history列表中的下一个URL</p>
<p>go(参数)：加载history列表中的某个具体的页面</p>
<p>参数：</p>
<ul>
<li>正数：前进多少个历史记录</li>
<li>负数：后退多少个历史记录</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>lebgth:返回当前窗口的历史浏览记录，中的URL个数</li>
</ul>
</li>
</ol>
</li>
<li><p>Location:地址栏</p>
<ol>
<li><p>创建：</p>
<p>window.location</p>
<p>location</p>
</li>
<li><p>方法</p>
<p>relaod():重新加载，刷新</p>
</li>
<li><p>属性</p>
<p>href:获取当前的地址</p>
<p>var href&#x3D;location.href;</p>
<p>location.href&#x3D;”<a href="https://www.baidu.com/">https://www.baidu.com</a>“</p>
</li>
</ol>
</li>
</ul>
<h6 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h6><p>分析：</p>
<ol>
<li>在页面上使用img展示图片</li>
<li>定义一个方法修改图片的src属性</li>
<li>定义一个定时器，每个三秒调用一次方法</li>
</ol>
<h6 id="自动跳转首页"><a href="#自动跳转首页" class="headerlink" title="自动跳转首页"></a>自动跳转首页</h6><p>分析：</p>
<ol>
<li>显示页面效果 <code>&lt;p&gt;</code></li>
<li>定义一个方法修改时间</li>
<li>倒计时读秒，使用定时器</li>
</ol>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>概念：文档对象模型</p>
<ul>
<li>将标记文档封装为各个对象</li>
</ul>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240801200923321.png" alt="image-20240801200923321"></p>
<p>W3C DO标准 - 分为3部分</p>
<ul>
<li><p>核心DOM针对任何结构化文档的标准模型</p>
<ul>
<li>Document:文档对象</li>
<li>Element:元素对象</li>
<li>Attribute:属性对象</li>
<li>Text:文本对象</li>
<li>Comment：注释对象</li>
<li>Node:节点对象，其他5个父类对象</li>
</ul>
</li>
<li><p>XML DOM- 针对XML文档的标准模型</p>
</li>
<li><p>HTML DOM–针对HTML文档的标准模型</p>
</li>
</ul>
<p>核心DOM模型：</p>
<ul>
<li><p>Document:文档对象</p>
<p>创建：在html中可以使用window对象来获取</p>
<ul>
<li>window.document</li>
<li>document</li>
</ul>
<p>方法:</p>
<ol>
<li><p>获取Element对象</p>
<p>getElementsById():根据id属性获取元素对象</p>
<p>getElementsByTagName():根据(标签名称)元素名称获取元素对象，返回值是一个数组</p>
<p>getElementsByClassName():格局Class属性获取元素对象。返回值是一个数组</p>
<p>getElementsByName():根据name属性获取元素对象们</p>
</li>
<li><p>创建其他DOM对象：</p>
<p>createAttribute(name):属性</p>
<p>createComment()：注释</p>
<p>crteateElement()：元素</p>
<p>createTextNode()：文本</p>
</li>
</ol>
</li>
<li><p>Element:元素对象</p>
<p>获取</p>
<ul>
<li>通过document来获取和创建</li>
</ul>
<p>方法</p>
<ul>
<li>removeAttribute()：删除属性</li>
<li>setAttribute(属性,属性值):设置属性</li>
</ul>
</li>
<li><p>Node:节点对象，其他5个父类对象</p>
<p>特点：所有dom对象都可以作为节点</p>
<p>方法</p>
<p>CRUD dom树</p>
<ul>
<li>appendChild(节点):向节点的子节点添加新的子节点</li>
<li>removeChild(节点):删除当前节点的子节点 div1.removeChild(div2)</li>
<li>replaceChild():用新节点替换子节点</li>
</ul>
<p>属性：</p>
<p>parentNode:返回父类节点</p>
</li>
</ul>
<h6 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h6><p>动态表格</p>
<p>分析：</p>
<ol>
<li><p>给添加按钮绑定单击事件</p>
</li>
<li><p>获取文本框的内容</p>
</li>
<li><p>创建td,设置td的文本为文本框的内容</p>
</li>
<li><p>创建tr</p>
</li>
<li><p>将td添加到tr中</p>
</li>
<li><p>获取table</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:void(0)&quot;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>删除：</p>
<ol>
<li><p>确定是哪个超连接</p>
<p>a href&#x3D;”javascript:void(0)；”onclick &#x3D; “delete(this);”</p>
</li>
<li><p>删除：removeChild();通过父标签parentNode</p>
</li>
</ol>
<p>HTML DOM模型</p>
<ol>
<li><p>标签体的设置和获取：innerHTML</p>
</li>
<li><p>使用html元素对象的属性</p>
</li>
<li><p>设置样式</p>
<p>使用元素的style属性来设置</p>
<ul>
<li>div1.style.border&#x3D;”1px  solic red”</li>
</ul>
<p>提前定义好类选择器的样式，通过元素的className属性来实现设置器的class的属性值</p>
<ul>
<li>div1.classNate&#x3D;”d1”;</li>
</ul>
</li>
</ol>
<p>功能：控制html文档的内容</p>
<p>代码：获取页面标签(元素)对象Element</p>
<ul>
<li>document.getElementByd(“id”):通过元素的id获取元素的对象</li>
</ul>
<p>操作Elment对象</p>
<ol>
<li>修改属性   .属性</li>
<li>修改标签体的内容      .innerHTML</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件的监听机制</p>
<p>事件：某些操作，单击，双击</p>
<p>事件源：组件，按钮 文本输入框</p>
<p>监听器：代码</p>
<p>注册监听：将事件，事件源，监听器集合在一起。当事件源上发生了某个事件，则会触发执行某个监听器代码</p>
<p>功能：某些组件被执行某些操作或，就会出发一些代码的执行</p>
<p>如何绑定事件：</p>
<ol>
<li><p>直接在html标签上，指定某些事件的属性（操作），属性值就是JS代码</p>
<p>事件：</p>
<p>点击事件：</p>
<ol>
<li>onclick—单击事件</li>
<li>ondbclivk–双击事件</li>
</ol>
<p>焦点事件：</p>
<ol>
<li><p>onblur:失去焦点</p>
<p>一般用于表单校验</p>
</li>
<li><p>onfocus:元素获得焦点</p>
</li>
</ol>
<p>加载事件</p>
<ol>
<li><p>onload:一张页面或一副图像完成加载</p>
<p>window.onload&#x3D;function(){}</p>
</li>
</ol>
<p>鼠标事件</p>
<ol>
<li><p>onmousedown:鼠标按钮被按下</p>
<p>定义一个方法时，定义一个形参，event对象</p>
<p>event对象的button属性可以可以获取鼠标按钮被点击了</p>
</li>
<li><p>onmouseup:鼠标按钮被松开</p>
</li>
<li><p>onmousemove:鼠标被移动</p>
</li>
<li><p>onmouseover:鼠标移动到某个元素</p>
</li>
<li><p>onmouseout:鼠标从某元素移开</p>
</li>
</ol>
<p>键盘事件</p>
<ol>
<li>onkeydown:某个键盘按键被按下</li>
<li>onkeyup:某个键盘按键被松开</li>
<li>onkeypress:某个键盘按键被 按下并松开</li>
</ol>
<p>选择和改变</p>
<ol>
<li>onchange:域的内容被选中</li>
<li>onselect:文本被选中</li>
</ol>
<p>表单事件</p>
<ol>
<li><p>onsumbit:确认按钮被点击</p>
<p>可以阻止表单被提交</p>
<ul>
<li>方法返回false则表单被阻止提交</li>
</ul>
</li>
<li><p>onreset:重置按钮被点击</p>
</li>
</ol>
</li>
<li><p>通过js获取属性，指定事件属性，设置一个函数</p>
</li>
</ol>
<h6 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h6><ol>
<li><p>获取图片对象</p>
</li>
<li><p>绑定一个单机事件</p>
</li>
<li><p>每次点击切换图片</p>
</li>
</ol>
<h6 id="表格练习"><a href="#表格练习" class="headerlink" title="表格练习"></a>表格练习</h6><ol>
<li>表格</li>
<li>在页面加载完后绑定事件</li>
<li>给全选绑定单击事件</li>
<li>获取所有checkbox</li>
<li>遍历cb，设置每一个cb的状态为选中 cbs.checked&#x3D;true;</li>
<li>反选：本身为非。第一个cb点击：获取所有的cb设置所有的cb的状态都和第一个一样</li>
<li>给所有tr绑定鼠标移到元素之上和移除的事件：换颜色</li>
</ol>
<p>表单校验</p>
<ol>
<li><p>给表单绑定onsubmit事件。监听器中判断每一个方法校验的结果</p>
<p>若都为true，则返回true</p>
<p>若都为false,则返回false</p>
</li>
<li><p>定义一些方法分别校验各个表单项</p>
<p>获取用户名的值，定义正则表达式</p>
<p>判断值是否符合规范，提示信息</p>
</li>
<li><p>给各个表单项绑定onblure事件</p>
</li>
</ol>
<h1 id="Bootstrap-前端开发的框架"><a href="#Bootstrap-前端开发的框架" class="headerlink" title="Bootstrap:前端开发的框架"></a>Bootstrap:前端开发的框架</h1><p>框架：一个半成品软件，开发人员可以在此基础上进行开发</p>
<p>好处：开发简洁</p>
<ul>
<li><p>定义了很多的css样式和js插件</p>
</li>
<li><p>响应式布局</p>
<p>可以兼容不同的分辨率尺的</p>
</li>
</ul>
<h2 id="入门："><a href="#入门：" class="headerlink" title="入门："></a>入门：</h2><p>下载bootstrap</p>
<p>在项目中将这两份文件夹复制过来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World with Bootstrap<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.6.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;mt-5&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;lead&quot;</span>&gt;</span>This is a simple example using Bootstrap.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>同一套页面可以兼容不同分辨率的设备</p>
<p>实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子</p>
<p>步骤：</p>
<ol>
<li><p>定义容器：相当于之前的table</p>
<p>容器分类：</p>
<ol>
<li>container:固定宽度，有留白</li>
<li>container-fluid:每一种设备都是100%宽度</li>
</ol>
</li>
<li><p>定义行,相当于之前的tr  样式：row</p>
</li>
<li><p>定义元素，指定该元素在不同设备上所占的格子数目。  样式：col-设备代号-格子数目</p>
<p>设备代号：</p>
<ol>
<li>xs:超小屏幕 手机(&lt;768px):col-xs-12</li>
<li>sm:小屏幕 平板(&gt;768px)</li>
<li>md:中等屏幕 桌面显示器(&gt;&#x3D;992px)</li>
<li>lg:大屏幕 大桌面显示器(&gt;12000px)</li>
</ol>
</li>
</ol>
<p>div calss&#x3D;”col-lg-1 col-sm-2”</p>
<p>注意：</p>
<p>一行中如果格子数目超过12，则超出部分自动换行</p>
<p>栅格类属性可以向上兼容，栅格类适用于屏幕宽度大于或等于的设备</p>
<p>如果正式设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素占满一整行</p>
<h2 id="css和js的插件"><a href="#css和js的插件" class="headerlink" title="css和js的插件"></a>css和js的插件</h2><p>全局css样式：</p>
<ul>
<li><p>按钮：class&#x3D;”btn btn-default”</p>
</li>
<li><p>图片：</p>
<p>class&#x3D;”img-fluid”:图片在任意尺寸都占100%</p>
<p>图片形状：</p>
<ul>
<li>img src&#x3D;”…” alt&#x3D;”…” class&#x3D;”rounded”:方的</li>
<li>img src&#x3D;”…” alt&#x3D;”…” class&#x3D;”rounded-circle”:圆的</li>
<li>img src&#x3D;”…” alt&#x3D;”…” class&#x3D;”img-thumbnail”:相框</li>
</ul>
</li>
<li><p>表格</p>
<p>table </p>
<p>table-bordered</p>
<p>table-hover</p>
</li>
<li><p>表单</p>
<p>给表单添加项：class&#x3D;”from&#x3D;control”</p>
</li>
</ul>
<p>组件：</p>
<ul>
<li>导航条</li>
<li>分页条</li>
</ul>
<p>插件：</p>
<ul>
<li>轮播图</li>
</ul>
<h6 id="案例：黑马旅游网"><a href="#案例：黑马旅游网" class="headerlink" title="案例：黑马旅游网"></a>案例：黑马旅游网</h6><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>可扩展标记语言</p>
<ul>
<li>可扩张：标签都是自定义的《user》</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>存储数据</p>
<ul>
<li>配置文件</li>
<li>在网络中传输</li>
</ul>
<h4 id="xml与html的区别"><a href="#xml与html的区别" class="headerlink" title="xml与html的区别"></a>xml与html的区别</h4><p>w3c：万维网联盟</p>
<ol>
<li>xml标签都是自定义的，html标签都是预定义</li>
<li>xml的语法严格，hrml语法松散</li>
<li>xml是存储数据的，html是展示数据</li>
</ol>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>xml文档的后缀名 .xml</li>
<li>xml第一行必须定义为文档声明</li>
<li>xml文档中有且仅有一个根标签</li>
<li>属性值必须使用引号单双都可以</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ol>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhansan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>22<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol>
<li><p>文档声明</p>
<ol>
<li><p>格式：<code>&lt;?xml 列表属性 ?&gt;</code></p>
</li>
<li><p>属性列表</p>
<ul>
<li><p>version:版本号，必须的属性</p>
</li>
<li><p>encoding：编码方式。告知解析引擎 当前文档使用的字符集，默认值：ISO-8859-1</p>
</li>
<li><p>standalone:是否独立</p>
<p>取值：</p>
<ul>
<li>yes:不依赖其他文件</li>
<li>no：依赖其他文件</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>指令（了解）：结合css的</p>
<ul>
<li><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot;?&gt;</code></li>
</ul>
</li>
<li><p>标签：自定义的</p>
<p>规则：</p>
<ol>
<li>名称可以包含字母数字及其他字符</li>
<li>名称不可以以数字或标点符号开始</li>
<li>名称不能以字母xml （或XML Xml等）开始</li>
<li>名称不能有空格</li>
</ol>
</li>
<li><p>属性</p>
<p>id属性值唯一</p>
</li>
<li><p>文本</p>
<ul>
<li>CDATA区：在该区中的水会被原样展示</li>
<li>格式：<code>&lt;![CDATA[数据]]&gt;</code></li>
</ul>
</li>
</ol>
<p>谁编写xml?-用户，软件使用者</p>
<p>谁解析xml?-软件</p>
<h2 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h2><h3 id="规定xml文档的书写规则"><a href="#规定xml文档的书写规则" class="headerlink" title="规定xml文档的书写规则"></a>规定xml文档的书写规则</h3><p>作为框架的使用者(程序员)：</p>
<ol>
<li>能够在xml中引入约束文档</li>
<li>能够简单的读懂约束文档</li>
</ol>
<h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ol>
<li>DTD：简单的约束技术</li>
<li>Schema：复杂的约束技术</li>
</ol>
<h5 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h5><ol>
<li><p>引入dtd文档到xml文档中</p>
<p>内部dtd：将看看约束规则定义在xml文档中</p>
<p>外部dtd：将约束的规则定义在外部的dtd文档中</p>
<ul>
<li>本地：&lt;!DOCTYPE 根标签名 SYSTEM “dtd文件的位置”</li>
<li>网络：&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名” “dtd文件的位置URL”</li>
</ul>
</li>
</ol>
<h5 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h5><p>引入：</p>
<ol>
<li>填写xml文档的根元素</li>
<li>引入xsi前缀。xmlns:xsi&#x3D;”<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>“</li>
<li>引入xsd文件命名空间.xsi:schemaLocation&#x3D;”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a> student.xsd”</li>
<li>为每一个xsd约束声明一个前缀，作为标识 xmlns&#x3D;”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a>“</li>
</ol>
<p>&lt;students xmlns:sxi&#x3D;”<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>“</p>
<p>xmlns&#x3D;”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a>“</p>
<p>xsi:schemaLocation&#x3D;”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a> student.xsd” &gt;</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>操作xml文档，将文档中的数据读取得到内存中</p>
<h4 id="操作xml文档"><a href="#操作xml文档" class="headerlink" title="操作xml文档"></a>操作xml文档</h4><ol>
<li>解析（读取）：将文档中的数据读取到内存中</li>
<li>写入：将内存中的数据保存到xml文档中，持久化保存</li>
</ol>
<h4 id="解析xml的方式"><a href="#解析xml的方式" class="headerlink" title="解析xml的方式"></a>解析xml的方式</h4><ol>
<li><p>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树</p>
<ul>
<li>优点：操作方便，可以对文档进行CRUD的所有操作</li>
<li>缺点：占内存</li>
</ul>
</li>
<li><p>SAX:逐行读取，基于事件驱动的</p>
<ul>
<li>优点：不占内存</li>
<li>缺点：只能读取，不能增删改</li>
</ul>
</li>
</ol>
<h4 id="xml常见的解析器"><a href="#xml常见的解析器" class="headerlink" title="xml常见的解析器"></a>xml常见的解析器</h4><ol>
<li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li>
<li>DOM4J：一款非常优秀的解析器</li>
<li>jsoup：是java的解析HTML的解析器，可解析xml</li>
<li>PULL：android(安卓)操作系统内置的解析器，sax方式的</li>
</ol>
<h1 id="JSOUP"><a href="#JSOUP" class="headerlink" title="JSOUP"></a>JSOUP</h1><p>jsoup是一款java的html的解析器，可直接解析URL地址,html文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似与jQuery的操作方法来取出和操作数</p>
<h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><p>步骤：</p>
<ol>
<li>导入jar包</li>
<li>获取Document的对象</li>
<li>获取对应的标签Element对象</li>
<li>获取数据</li>
</ol>
<p>代码：</p>
<ol>
<li><p>获取student.xml的path(地址)</p>
</li>
<li><p>解析xml文档，加载文档进内存，获取dom树—&gt;Document</p>
<p>Document document &#x3D; Jsouip.parse(new File(path),”utf-8”);</p>
</li>
<li><p>获取元素对象Element</p>
<p>Elements elements&#x3D;document.getElementsByTag(“name”);</p>
<p>Syste.out.println(element.size());</p>
</li>
<li><p>获取第一个name的Element对象</p>
<p>Element element&#x3D;element.get(0);</p>
</li>
<li><p>获取数据</p>
<p>string name&#x3D;element.text();</p>
<p>System.oput.println(name);</p>
</li>
</ol>
<h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><h4 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h4><p>:工具类，可以解析html或xml文档，返回Document</p>
<ul>
<li>pares:解析html或xml文档，返回Document<ul>
<li>parse(File in,String charsetName):解析xml或html文件的</li>
<li>parse(String html):解析xml或html字符串的</li>
<li>parse(URL url,int timeoutMillis):通过网络路径获取指定的html或xml的文档对象</li>
</ul>
</li>
</ul>
<h4 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h4><p>：文档对象，代表内存中的dom树</p>
<p>获取Element对象</p>
<ul>
<li>getElementById(String id):根据id属性中获取唯一的element对象</li>
<li>getElementByTag(String tagName):根据标签名获取element对象集合</li>
<li>getElementByAttribute(String key):根据属性名获取的element对象集合</li>
<li>getElementByAttributeValue(String key,String value):根据对应的属性名和属性值获取element对象</li>
</ul>
<h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><p>:元素Element对象的集合，可以当做ArrayList<code>&lt;Element&gt;</code>来使用</p>
<h4 id="Elements-1"><a href="#Elements-1" class="headerlink" title="Elements"></a>Elements</h4><p>:元素对象</p>
<p>获取子元素对象</p>
<ul>
<li><p>getElementById(String id):根据id属性中获取唯一的element对象</p>
<ul>
<li>getElementByTag(String tagName):根据标签名获取element对象集合</li>
<li>getElementByAttribute(String key):根据属性名获取的element对象集合</li>
<li>getElementByAttributeValue(String key,String value):根据对应的属性名和属性值获取element对象</li>
</ul>
</li>
</ul>
<p>获取属性值</p>
<ul>
<li>String attr(String key):根据属性名获取属性值</li>
</ul>
<p>获取文本内容</p>
<ul>
<li>String text():获取所有子标签的纯文本内容</li>
<li>String html():获取标签体的所有内容（包括子标签的字符串内容）</li>
</ul>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>:节点对象</p>
<ul>
<li>是Document和Element的父类</li>
</ul>
<h2 id="快速查询"><a href="#快速查询" class="headerlink" title="快速查询"></a>快速查询</h2><ol>
<li><p>selector:选择器</p>
<p>使用方法:Elements select(String cssQuery)</p>
<ul>
<li>语法参考Selector类中定义的语法</li>
</ul>
<p>Elements elements&#x3D;document.select(“student[number&#x3D;’hema001’]”);</p>
</li>
<li><p>XPath:</p>
<p>即xml路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</p>
<ul>
<li>使用Jsoup的XPath需要额外导入jar包</li>
<li>查询w3cshool参考手册，使用xpath的语法完成查询</li>
<li>List<code>&lt;JXNode&gt; </code>jxNodes2&#x3D;jxDocument.selN(“&#x2F;&#x2F;student&#x2F;name[@id&#x3D;’ithema’]”)</li>
</ul>
</li>
</ol>
<h1 id="web知识回顾"><a href="#web知识回顾" class="headerlink" title="web知识回顾"></a>web知识回顾</h1><p>软件架构</p>
<ol>
<li>C&#x2F;S:客户端&#x2F;服务器端</li>
<li>B&#x2F;S:浏览器&#x2F;服务器端</li>
</ol>
<p>资源分类：</p>
<ol>
<li><p>静态资源:所有用户访问或，得到的结果是一样，称为静态资源.可以直接被浏览器解析</p>
<p>如：html,css,javaScript</p>
</li>
<li><p>动态资源：每个用户访问相同的资源后，得到的结果可能不同，称为动态资源。动态资源被访问后要先转换成静态资源，再返回给浏览器</p>
<p>如：servlet&#x2F;jsp,php,asp…</p>
</li>
</ol>
<p>网络通信三要素：</p>
<ol>
<li><p>ip:电子设备在网络中的唯一标识</p>
</li>
<li><p>端口：应用程序在计算机中的唯一标识。0~65536</p>
</li>
<li><p>传输协议：规定了数据传输的规则</p>
<p>基础协议：</p>
<ol>
<li>tcp:安全协议，三次握手。速度稍慢</li>
<li>udp:不安全协议，速度快</li>
</ol>
</li>
</ol>
<h1 id="web服务器软件：Tomcat"><a href="#web服务器软件：Tomcat" class="headerlink" title="web服务器软件：Tomcat"></a>web服务器软件：Tomcat</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>安装了服务器软件的计算机</p>
<p>服务器软件：接收用户的请求，处理请求，做出回响</p>
<p>web服务器软件：接收用户的请求，处理请求，做出回应</p>
<ul>
<li>在web服务软件中，可以部署web项目，让用户通过浏览器那访问这些项目</li>
<li>web容器</li>
</ul>
<p>常见的java相关的web服务器软件</p>
<ul>
<li>webLoic:oracle公司，大型的javaEE服务器，支持所有的javaEE规范，收费的</li>
<li>webSphere:IBM公司的，大型的javaEE服务器，支持所有的javaEE,收费的</li>
<li>JBOSS:JBOSS公司的，大型的javaEE服务器，支持所有的javaEE规范，收费的</li>
<li>Tomcat:Apache基金组织的，中小型的javaEE服务器，仅仅支持少量的javaEE规范servlet&#x2F;jsp.开源的，免费的</li>
</ul>
<p>javaEE：java语言在企业级开发中使用的技术规范的总和，一共规定了13大的规范</p>
<p>Tomact:web服务器软件</p>
<ol>
<li><p>下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p>
</li>
<li><p>安装</p>
</li>
<li><p>卸载</p>
</li>
<li><p>启动：bin&#x2F;startup.bat,运行</p>
<p>访问：在浏览器输入：<a href="http://loaclhost:8080/">http://loaclhost:8080</a> 回车访问自己，http:&#x2F;&#x2F;别人的id:8080 回车访问别人</p>
<p>可能遇到的问题：</p>
<ol>
<li><p>黑窗口：没有正确配置JAVA_HOME环境变量</p>
</li>
<li><p>启动报错：端口号被占用在.cdm终端中输入netstat -ano找到端口号用任务管理器来结束进程</p>
<p>修改自身端口号：</p>
<p>conf&#x2F;server.xml</p>
<p>&lt;Connect port&#x3D;”8888”</p>
<p>一般默认将tomcat的默认端口修改为80.80是http协议的默认端口</p>
</li>
</ol>
</li>
<li><p>关闭：</p>
<ol>
<li><p>正常关闭：</p>
<p>bin&#x2F;.shutdown.bat</p>
<p>ctrl+c</p>
</li>
<li><p>强制关闭：关闭启动窗口</p>
</li>
</ol>
</li>
<li><p>配置：</p>
<p>部署项目的方式：</p>
<ol>
<li><p>直接将目录放到webapps中</p>
<p>&#x2F;hellow:项目的访问路径–&gt;虚拟目录</p>
<p>简化部署：将项目打成一个war包，再将war部署到</p>
</li>
<li><p>配置conf&#x2F;server.xml文件</p>
<p>在<code>&lt;HOST&gt;</code>标签体中配置</p>
<p><code>&lt;Context docBase=&quot;D:\hellow&quot; path=&quot;/hehe&quot;/&gt;</code></p>
<p>docBase:项目存放的目录</p>
<p>path:虚拟目录</p>
</li>
<li><p>在conf\Catalina\locahost创建任意名称的xml文件，在文件中编写<code>&lt;Context docBase=&quot;D:\hellow&quot;/&gt;</code></p>
<p>虚拟目录：xml文件的名称</p>
</li>
</ol>
</li>
</ol>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240805085914956.png" alt="image-20240805085914956"></p>
<p>bin:可执行文件</p>
<p>conf:配置文件</p>
<p>lib:依赖jar包</p>
<p>logs:日志文件</p>
<p>temp:临时文件</p>
<p>webapps:存放web项目</p>
<p>work:存放运行时的数据</p>
<p>静态项目和动态项目</p>
<ul>
<li><p>目录结构</p>
<p>java动态项目的目录结构</p>
<ul>
<li><p>项目目录</p>
<p>WEB-INF</p>
<ul>
<li>web.xml:该目录的核心配置文件</li>
<li>Classes目录：放置字节码文件</li>
<li>lib目录：放置项目依赖的jar包</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>将Tomcat集成到idea</p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet:"></a>Servlet:</h1><p>运行在浏览器中的小程序</p>
<h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>servlet就是一个接口，定义了java类被浏览器访问到(tomcat识别)的规则</p>
<p>将来我们定义一个类，实现Servlet接口，复写方法</p>
<h2 id="快速入门-2"><a href="#快速入门-2" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li><p>创建javaEE的项目</p>
</li>
<li><p>定义一个类，实现Servlet接口</p>
<p>public class ServletDemo1 implements Servlet</p>
</li>
<li><p>实现接口中的抽象方法</p>
</li>
<li><p>配置Servlet</p>
<p>在web.xml中配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1(路径名)&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240805200843409.png" alt="image-20240805200843409"></p>
<h3 id="Servlet中的生命周期："><a href="#Servlet中的生命周期：" class="headerlink" title="Servlet中的生命周期："></a>Servlet中的生命周期：</h3><ol>
<li><p>被创建：执行init方法，只执行一次</p>
<p>Servlet什么时候被创建，默认情况只在第一次访问被创建</p>
<ul>
<li>可以配置执行Servlet的创建时机</li>
<li>在<code>&lt;servlet&gt;</code>标签下配置</li>
<li>第一次被访问时创建：<code>&lt;load-on-startup&gt;</code>的值为负数</li>
<li>在服务器启动时创建：<code>&lt;load-on-startup&gt;</code>的值为0或为正整数</li>
</ul>
<p>Servlet的方法，只执行一次说明一个Servlet在内存中值存在一个对象，Servlet是单例的</p>
<ul>
<li>多个用户同时访问时，可能存在线程安全问题</li>
<li>解决：尽量不要在Servlet中定义成员变量，及时定义了也要对其值进行修改</li>
</ul>
</li>
<li><p>提供服务：执行servlet方法，执行多次</p>
<p>每次访问Servlet时，Servlet方法都会执行一次</p>
</li>
<li><p>被销毁：执行destroy方法，值执行一次</p>
<p>Servlet被销毁前执行，服务器关闭前执行</p>
<p>只有服务器正常关闭，才会执行destory方法</p>
</li>
</ol>
<h3 id="Servlat3-0："><a href="#Servlat3-0：" class="headerlink" title="Servlat3.0："></a>Servlat3.0：</h3><p>好处：支持注解配置，可以不需要web.xml了</p>
<p>步骤：</p>
<ol>
<li><p>创建javaEE项目，选择servlet的版本3.0以上，不创建web.xml</p>
</li>
<li><p>定义一个类，实现Servlet接口</p>
</li>
<li><p>复写方法</p>
</li>
<li><p>在类上使用@webServlet注解，进行配置</p>
<p>@webServlet(“资源路径”)</p>
</li>
</ol>
<h4 id="在idea上创建javaEE"><a href="#在idea上创建javaEE" class="headerlink" title="在idea上创建javaEE"></a>在idea上创建javaEE</h4><h4 id="idea与Tomcat的配置"><a href="#idea与Tomcat的配置" class="headerlink" title="idea与Tomcat的配置"></a>idea与Tomcat的配置</h4><p>idea会为每一个项目单独建立一份配置文件</p>
<ul>
<li>查看控制台的log：Using CATALINA_BASE:”\Users\xiaoxin\AppData\Local\JetBrains\IntelliJIdea2024.1\tomcat\8f4ca39d-150c-4247-858d-4451ff19700b”</li>
</ul>
<p>工作空间项目    和    tomcat部署的web项目</p>
<ul>
<li>tomcat真正访问的是“tomcat部署的web项目”，”tomcat部署的web项目”对应这”工作空间项目”的web目录下的所有资源</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问</li>
<li>断点调试：使用小虫子启动dubug启动</li>
</ul>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Servlaet —接口</p>
<p>​     |</p>
<p>GenericServlet — 抽象类</p>
<p>​     |</p>
<p>HttpServlet  —- 抽象类</p>
<p>GenericServlet：将Servlet接口中的其他方法作了默认空处理，只剩Servlet()方法作为抽象方法</p>
<ul>
<li>将来定义Servlet类时，可以继承GenericServlet,实现servlet()方法即可</li>
</ul>
<p>HttpServlet:对http协议的一种封装，简化操作</p>
<ol>
<li>定义类继承HttpServlet</li>
<li>复写doGet和doPost方法</li>
<li>可以在from中定义action&#x3D;资源路径，method&#x3D;”get”或”post”</li>
</ol>
<h4 id="Servlet相关配置"><a href="#Servlet相关配置" class="headerlink" title="Servlet相关配置"></a>Servlet相关配置</h4><ol>
<li><p>urlpartten:Servlet访问路径</p>
<p>一个Servlet可以定义多个访问路径：@webServlet({“&#x2F;d4”,”&#x2F;dd4”,”&#x2F;ddd4”})</p>
<p>路径定义规则：</p>
<ol>
<li>&#x2F;xxx</li>
<li>&#x2F;xxx&#x2F;xxx:多层路径，目录结构</li>
<li>*.do:  *是任意字符优先度较低</li>
</ol>
</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>超文本传输协议</p>
<p>传输协议：定义了，客户端和服务器端通信时发送数据的格式</p>
<p>特点：</p>
<ol>
<li>基于TCP&#x2F;IP的高级协议</li>
<li>默认端口：80</li>
<li>基于请求&#x2F;响应模型的：一次请求一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
<p>历史版本：</p>
<ul>
<li>1.0：每一次请求响应都会建立新的连接</li>
<li>1.1：复用连接，等一会若还有数据传输，就会仍使用这个连接</li>
</ul>
<h3 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h3><ol>
<li><p>请求行</p>
<p>请求方式  请求url  请求协议&#x2F;版本</p>
<p>GET  &#x2F;topost和toget.html(资源路径)  HTTP&#x2F;1.1</p>
<p>请求方式：HTTP协议有7种方式，常用的有两种</p>
<ul>
<li>GET:<ol>
<li>请求参数在请求行中，在uil后</li>
<li>请求的uil长度有限制的</li>
<li>不太安全</li>
</ol>
</li>
<li>POST：<ol>
<li>请求参数在请求体中</li>
<li>请求的uil长度没有限制</li>
<li>相对安全</li>
</ol>
</li>
</ul>
</li>
<li><p>请求头：客户端告诉浏览器一些信息</p>
<p>请求头名称：请求头值</p>
<p>常见的请求头：</p>
<ol>
<li><p>User-Agent:浏览器告诉服务器，我访问你使用的浏览器版本信息</p>
<p>可以服务器端获取该头的信息，解决浏览器兼容性的问题</p>
</li>
<li><p>Referer:<a href="http://localhost/login.html">http://localhost/login.html</a></p>
<p>告诉服务器，我(当前请求)从哪里来？</p>
<ul>
<li><p>作用</p>
<p>防盗链：放置被盗去超链接</p>
<p>统计工作：统计从各处请求来这的个数</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>请求空行</p>
<p>空行，就是用来分割POST请求头和请求体的</p>
</li>
<li><p>请求体(正文)</p>
<ul>
<li>用来封装POST请求消息的请求参数的</li>
<li>get没有请求体</li>
</ul>
</li>
</ol>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240806113612664.png" alt="image-20240806113612664"></p>
<h4 id="Request对象和Response对象的原理"><a href="#Request对象和Response对象的原理" class="headerlink" title="Request对象和Response对象的原理"></a>Request对象和Response对象的原理</h4><ol>
<li>request和response对象是由服务器创建的，我们只是使用它</li>
<li>request对象是来获取请求消息的，response对象是来设置响应消息的</li>
</ol>
<h4 id="resquest对象继承体系结构"><a href="#resquest对象继承体系结构" class="headerlink" title="resquest对象继承体系结构"></a>resquest对象继承体系结构</h4><p>ServletRequest  —  接口</p>
<p>​    |      继承</p>
<p>HttpServletRequest  —   接口</p>
<p>   |     实现</p>
<p>org.apache.catalina.connector.ResquestFacade 类(tomcat 创建这个类的对象来传递给它)</p>
<h4 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a>request功能</h4><ol>
<li><h5 id="获取请求消息数据"><a href="#获取请求消息数据" class="headerlink" title="获取请求消息数据"></a>获取请求消息数据</h5><p>获取数据请求行数据</p>
<p>GET &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1</p>
<p>方法：</p>
<ol>
<li><p>获取请求方式：GET</p>
<p>String getMethod()</p>
</li>
<li><p>(*)<strong>获取虚拟目录</strong>:&#x2F;day14</p>
<p>String getContextPath()</p>
<p>动态获取虚拟目录</p>
</li>
<li><p>获取Servlet路径：&#x2F;demo1</p>
<p>String getServletPath()</p>
</li>
<li><p>获取get方式的参数：name&#x3D;zhangsan</p>
<p>String getQueryString()</p>
</li>
<li><p>(*)<strong>获取请求URI：&#x2F;day14&#x2F;demo1</strong></p>
<p>String getRequestURI():&#x2F;day14&#x2F;demo1</p>
<p>URL:统一资源定位符：<a href="http://loaclhost/day14/demo1">http://loaclhost/day14/demo1</a>   （中华人民共和国）</p>
<p>String getRequestURL():hppt:&#x2F;localhost&#x2F;day14&#x2F;demo1</p>
<p>URI:统一资源标识符：&#x2F;day14&#x2F;demo1  （共和国）</p>
</li>
<li><p>获取协议及版本：HTTP&#x2F;1.1</p>
<p>String getProtocol()</p>
</li>
<li><p>获取客户机的IP地址</p>
<p>String getRemoteAddr()</p>
</li>
</ol>
</li>
<li><h5 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取请求头数据</h5><p>方法：</p>
<ul>
<li>(*)String getheader(String name):通过请求头的名称获取请求头的值</li>
<li>Eumeration<code>&lt;String&gt; </code>getHeaderNames():获取所有的请求头名称</li>
</ul>
</li>
<li><h5 id="获取请求体数据："><a href="#获取请求体数据：" class="headerlink" title="获取请求体数据："></a>获取请求体数据：</h5><p>请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p>
<ol>
<li><p>获取流对象</p>
<p>BufferedReader getReader():获取字符输入流，只能操作字符数据</p>
<p>ServletInputStream getInputStream():获取字节输入流，可操作所有数据</p>
</li>
<li><p>在从流中拿数据</p>
<p>while((reader&#x3D;br.readline())!&#x3D;null){</p>
<p>System.out.println(reader);}</p>
</li>
</ol>
</li>
</ol>
<h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><h5 id="获取请求参数通用方式"><a href="#获取请求参数通用方式" class="headerlink" title="获取请求参数通用方式"></a>获取请求参数通用方式</h5><p>不论get还是post方式，都能使用</p>
<p>this.dopost(request,response)</p>
<ol>
<li><p>String getParamater(String name): 根据参数名称获取参数值   username&#x3D;zs&amp;password&#x3D;123</p>
</li>
<li><p>String[] getParameterValues(String name):根据参数名称获取参数值数组  hobby&#x3D;xx&amp;hobby&#x3D;game</p>
</li>
<li><p>Enumeration<code>&lt;String&gt;</code> getParameterNames():获取所有的请求的参数名称</p>
</li>
<li><p>Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合</p>
</li>
<li><p>中文乱码问题</p>
<p>get方式：tomcat 8 已经将乱码解决了</p>
<p>post方式：解决：在获取参数前，设置request.setCharacterEncoding(“utf-8”);</p>
</li>
</ol>
<h5 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h5><p>一种在服务器内部的资源跳转的方式</p>
<p>步骤：</p>
<ol>
<li>通过request对象获取请求转发器对象：RequestDispatcher   getRequestDispatcher(String path)</li>
<li>使用RequestDispatcher 对象进行转发：forward(ServletRequest request,SrevletRespone response)</li>
<li>req.getRequestDispatcher (&#x2F;test1_6).forward(req,res);</li>
</ol>
<p> 特点：</p>
<ol>
<li>浏览器地址栏路径不会发生改变</li>
<li>只能转到当前服务器内部资源</li>
<li>转发是一次请求</li>
</ol>
<h5 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h5><p>域对象：一个有范围的对象，可以在范围内共享数据</p>
<p>request域：代表一次请求，一般用于请求转发的多个资源中共享数据</p>
<p>方法：</p>
<ol>
<li>void setAttribute(String name,Object obj):存储数据</li>
<li>Object getAttitude(String name):通过键获取值</li>
<li>void removeAttribute(String name):通过键移除键值对</li>
</ol>
<h5 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h5><p>ServletContext getServletContext()</p>
<h6 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h6><p>需求：</p>
<ol>
<li><p>编写login.html登录页面</p>
<p>username&amp;password 两个输入框</p>
</li>
<li><p>使用Druid数据库连接池技术，操作mysql,day14数据库中的user表</p>
</li>
<li><p>使用JDBCTemplate技术封装JDBC</p>
</li>
<li><p>登录成功跳转到SuccessServlet展示：登录成功！用户名欢迎你</p>
</li>
<li><p>登录失败跳转到FailServlet展示：登录失败，用户名或密码错误</p>
</li>
</ol>
<p>分析：</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240806195221938.png" alt="image-20240806195221938"></p>
<p>开发步骤：</p>
<ol>
<li>创建项目，导入html页面，配置文件，jar包</li>
<li>创建数据库环境</li>
<li>创建包cn.itcast,domain,创建User类</li>
<li>创建UserDao,提供login方法，操作User表的类</li>
</ol>
<p>BeanUtils工具类，简化数据封装</p>
<p>用于封装JavaBean的</p>
<ol>
<li><p>javaBean:标准的java类</p>
<p>要求：</p>
<ol>
<li>类必须被public修饰</li>
<li>必须提供空参的架构器</li>
<li>成员变量必须使用private修饰</li>
<li>提供公共setter和getter方法</li>
</ol>
<p>功能：封装数据</p>
</li>
<li><p>概念：</p>
<p>成员变量：</p>
<p>属性：setter和getter方法截取或的产物</p>
<p>例如：getUsername() —&gt;Username —–&gt;username</p>
</li>
<li><p>方法：</p>
<ol>
<li>setProperty()</li>
<li>getProperty()</li>
<li>populate(Object obj,Map map):将map集合的键值对信息，封装到对应的jacaBean对象中</li>
</ol>
</li>
</ol>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h3><p>客户端发送给服务器端的数据</p>
<p>数据格式：</p>
<ol>
<li><p>请求行</p>
</li>
<li><p>请求头</p>
</li>
<li><p>请求空行</p>
</li>
<li><p>请求体</p>
</li>
</ol>
<h3 id="响应消息："><a href="#响应消息：" class="headerlink" title="响应消息："></a>响应消息：</h3><p>服务器端发送给客户端的数据</p>
<h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><h5 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h5><p>组成：协议&#x2F;版本  响应状态码  状态码描述</p>
<p>响应状态码：服务器告诉客户端浏览器本次请求和回响的一个状态</p>
<ol>
<li><p>状态码都是3位数</p>
</li>
<li><p>分类：</p>
<ol>
<li><p>1xx:服务器接收到客户端消息，但还没有接收完成，等待一段时间后，发送1xx多的状态码</p>
</li>
<li><p>2xx:成功，代表：200</p>
</li>
<li><p>3xx:重定向。代表302（重定向（跳转）），304（访问缓存（本地缓存））</p>
</li>
<li><p>4xx:客户端错误</p>
<p>代表：</p>
<p>404（请求路径没有对应的资源）</p>
<p>405：请求方式没有</p>
</li>
<li><p>5xx:服务器端错误。代表500（服务器出现异常）</p>
</li>
</ol>
</li>
</ol>
<h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><ol>
<li>格式：头名称：值</li>
<li>常见的响应头：<ol>
<li>Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式</li>
<li>Content-disposition:服务器告诉客户端以什么格式打开响应体数据<ul>
<li>值：</li>
<li>in-line:默认值，在当前页面内打开</li>
<li>attachment;filename&#x3D;xxx:以附件形式打开响应体。常用于文件下载</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="响应空行"><a href="#响应空行" class="headerlink" title="响应空行"></a>响应空行</h5><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><p>页面代码</p>
<p>响应字符串格式</p>
<p>HTTP&#x2F;2.0 200 OK</p>
<p>Content-type:text&#x2F;html;charser&#x3D;UTF-8</p>
<h2 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h2><p>功能：设置响应消息</p>
<ol>
<li><p>设置响应行</p>
<ol>
<li>格式：HTTP&#x2F;1.1 200 ok</li>
<li>设置状态码：setStatus(int sc)</li>
</ol>
</li>
<li><p>设置响应头：setHeader(String name,String value)</p>
<p>setContentType(“text&#x2F;hrml;charset&#x3D;utf-8”)</p>
</li>
<li><p>设置响应体：</p>
<p>使用步骤：</p>
<ol>
<li><p>获取输出流</p>
<p>字符输出流：PrintWriter()</p>
<p>字节输出流：ServletOutputStream getOutputStream()</p>
</li>
<li><p>使用输出流,将数据输出到客户端浏览器</p>
</li>
</ol>
</li>
</ol>
<p>案例：</p>
<ol>
<li><p>完成重定义</p>
<p>资源跳转的一种方式</p>
<p>代码实现：</p>
<ul>
<li>response.setStatus(302);设置状态码</li>
<li>response.setHeader(“location”,”&#x2F;day18&#x2F;response2”)设置响应头location</li>
<li>response.sendRedirect(“&#x2F;day18&#x2F;response2”);&#x2F;&#x2F;简单的重定义</li>
</ul>
<p>重定向的特点：redirect</p>
<ol>
<li>地址栏发生变化</li>
<li>重定向可以访问其他站点(服务器)的资源</li>
<li>重定向是两次请求，不能使用request对象共享数据</li>
</ol>
<p>转发的特点：forward</p>
<ol>
<li>转发地址栏不变</li>
<li>转发只能访问当前服务器下的资源</li>
<li>转发只是一次请求，可以使用request对象共享数据</li>
</ol>
<p>路径写法：</p>
<ol>
<li><p>路径分类：</p>
<p>相对路径：通过相对路径不可以确定唯一资源</p>
<ul>
<li>如：.&#x2F;index.html</li>
<li>不以&#x2F;开头，以.开头路径</li>
<li>规则：找到当前资源和目标资源之间的相对位置关系</li>
<li>.&#x2F;:表示当前目录</li>
<li>..&#x2F;：后退一级目录</li>
</ul>
<p>绝对路径：通过绝对路径可以确定唯一资源</p>
<ul>
<li>如：<a href="http://location/day18/responseDemo2">http://location/day18/responseDemo2</a>    &#x2F;day18&#x2F;respoonseDemo2</li>
<li>以&#x2F;开头的路径</li>
</ul>
<p>规则：判断定义的路径是给谁用的？判断请求是从哪里发出的</p>
<ul>
<li><p>给客户端浏览器使用：需要加虚拟目录（项目的访问路径）</p>
<p>建议虚拟目录动态获取：request.getContextPath()</p>
<p><code>&lt;a&gt;,&lt;form&gt;</code>,重定向</p>
</li>
<li><p>给服务器使用：不需要加虚拟目录</p>
<p>转发路径</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>服务器输出字符数据到浏览器：文本</p>
<p>获取字符输出流</p>
<p>PrintWriter pw&#x3D;response.getWriter()</p>
<p>输出数据 </p>
<p>pw.write(“你好啊 response”)</p>
<p>乱码问题：</p>
<ul>
<li>PrintWriter pw &#x3D; response.getWriter();获取的流的默认编码是ISO-8859-1</li>
<li>设置该流的默认编码</li>
<li>告诉浏览器响应体使用的编码</li>
</ul>
<p>都是在获取流之前设置的</p>
<p>response.setContentType(“text&#x2F;html;charset&#x3D;utf-8”)</p>
</li>
<li><p>服务器输出字节数据到浏览器:图片等</p>
<p>获取字节输出流</p>
<p>ServletOutputStream sos&#x3D;response.getOutputStream();</p>
<p>输出数据 </p>
<p>sos.write(“你好”.getBytes(“utf-8”))(中文默认的是GBK)</p>
<p>乱码问题:response.setContentType(“text&#x2F;html;charset&#x3D;utf-8”)</p>
</li>
<li><p>验证码</p>
<p>本质：图片</p>
<p>目的：防止恶意表单注册</p>
<p>创建对象，在内存存图片（验证码图片对象）</p>
<p>BufferedImage image&#x3D;new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);</p>
<p>美化图片</p>
<ol>
<li><p>填充背景色</p>
<p>Graphics g&#x3D;image.getGraphics()&#x2F;&#x2F;画笔对象</p>
<p>g.setColor(Color.PINK);&#x2F;&#x2F;设置画笔颜色</p>
<p>g.fillRect(0,0,width,height);</p>
</li>
<li><p>画边框</p>
<p>g.setColor(Color.BLUE);</p>
<p>g.drawRect(0,0,width-1,height-1);</p>
</li>
<li><p>写验证码</p>
<p>String str&#x3D;”qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890”</p>
<p>Random ran&#x3D;new Random();</p>
<p>for(int i&#x3D;1;i&lt;&#x3D;4;i++){</p>
<p>int index &#x3D; ran.nextInt(str.length());&#x2F;&#x2F;获取随机字符索引</p>
<p>char ch&#x3D;str.charAt(index);&#x2F;&#x2F;获取字符</p>
<p>g.drawString(ch+””,width&#x2F;5*i,height&#x2F;2);&#x2F;&#x2F;写验证码}</p>
</li>
<li><p>画干扰线</p>
<p>g.setColor(color.GREEN)</p>
<p>生成随机坐标点</p>
<p>for(int i&#x3D;0;i&lt;10;i++){</p>
<p>int x1&#x3D;ran.nextInt(width);</p>
<p>int x2&#x3D;ran.nextInt(width);</p>
<p>int y1&#x3D;ran.nextInt(height);</p>
<p>int y2&#x3D;ran.nextInt(height);</p>
<p>g.drawLine(x1,y1,x2,y2);</p>
<p>}</p>
</li>
</ol>
<p>将图片输出到页面</p>
<p>ImageIO.write(image,”jpg”,response.getOutputStream())</p>
</li>
</ol>
<p>分析：点击图片或超链接更换</p>
<ol>
<li>给超链接和图片绑定单击事件</li>
<li>重新设置图片的src属性值</li>
</ol>
<p>img src&#x3D;”” id&#x3D;cher</p>
<p>window.onload&#x3D;function(){</p>
<p>var img&#x3D;document.getElement(“cher”);</p>
<p>img.onclick&#x3D;function(){</p>
<p>var date &#x3D; new Date().getTime(); </p>
<p>img.src&#x3D;”xxxx?”+date;}}</p>
<h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>代表整个web应用 ，可以和程序的容器(服务器)来通信</p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>通过request对象获取</p>
<p>request.getServletContext();</p>
<p>通过HTTPServlet获取</p>
<p>this.getServletContext();</p>
<h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><h4 id="获取MIME类型"><a href="#获取MIME类型" class="headerlink" title="获取MIME类型"></a>获取MIME类型</h4><p>MIME类型：在互联网通信过程中定义的一种文件数据类型</p>
<ul>
<li>格式：大类型&#x2F;小类型 text&#x2F;html   image&#x2F;jpeg</li>
</ul>
<p>获取：String getMineType(String file)&#x2F;&#x2F;文件名</p>
<h4 id="域对象"><a href="#域对象" class="headerlink" title="域对象"></a>域对象</h4><p>共享数据</p>
<ol>
<li>setAttribute(String name,Object value)</li>
<li>getAttribute(String name)</li>
<li>removeAttribute(String name)</li>
</ol>
<p>ServletContext对象范围：所有用户所有请求的数据</p>
<h4 id="获取文件的真实（服务器）路径"><a href="#获取文件的真实（服务器）路径" class="headerlink" title="获取文件的真实（服务器）路径"></a>获取文件的真实（服务器）路径</h4><p> 方法：</p>
<p>String b&#x3D;context.getRealPath(“&#x2F;b.txt”);&#x2F;&#x2F;web目录下资源访问</p>
<p>String c&#x3D;context.getRealPath(“&#x2F;WEB-INF&#x2F;b.txt”);&#x2F;&#x2F;WEB-INF目录下的资源访问</p>
<p>String a&#x3D;context.getRealPath(“&#x2F;WEB-INF&#x2F;classes&#x2F;a.txt”)</p>
<h6 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h6><p>文件下载：</p>
<ol>
<li>页面显示超链接 </li>
<li>点击超链接后弹出下载提示框</li>
<li>完成图片文件下载</li>
</ol>
<p>分析：</p>
<ol>
<li><p>超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析则弹出下载提示框，不能满足需求</p>
</li>
<li><p>任何资源都必须弹出下载提示框</p>
</li>
<li><p>使用响应头设置资源的打开方式</p>
<p>content-disposition:attachment;filename&#x3D;xxx</p>
</li>
</ol>
<p>步骤：</p>
<ol>
<li>定义页面，编辑超链接href属性，指向Servlet,(?)传递资源名称filename</li>
<li>定义Servlet<ol>
<li>获取文件名称</li>
<li>使用字节输入流加载文件进内存</li>
<li>指定response的响应头：content-disposition:attachment(以附件的形式打开);filename&#x3D;xxx</li>
<li>将数据写出到response</li>
</ol>
</li>
</ol>
<p>问题：</p>
<p>中文文件名问题</p>
<ul>
<li><p>解决思路：</p>
<p>获取客户端使用的浏览器版本信息</p>
<p>根据不同版本信息，设置filename的编码方式不同</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String file=req.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">    String path=context.getRealPath(<span class="string">&quot;/picture/&quot;</span>+file);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">    BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path));</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">    <span class="type">String</span> <span class="variable">mine</span> <span class="operator">=</span> context.getMimeType(file);</span><br><span class="line">    resp.setHeader(<span class="string">&quot;content-Type&quot;</span>, mine);</span><br><span class="line">    resp.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment; filename=\&quot;&quot;</span>+file+<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>((length=bis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        out.write(buffer,<span class="number">0</span>,length);</span><br><span class="line">    &#125;</span><br><span class="line">    bis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><ol>
<li>会话： 一次会话中包含多次请求和响应</li>
</ol>
<ul>
<li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li>
</ul>
<ol start="2">
<li>功能：在一次会话的范围内的多次请求间，共享数据</li>
<li>方式：</li>
</ol>
<ul>
<li>客户端会话技术：Cookie</li>
<li>服务器端会话技术：Session</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>概念：客户端会话技术，将数据保存到客户端</p>
<p>快速入门：</p>
<ol>
<li>创建Cookie对象，绑定数据<ul>
<li>new Cookie(String name,String value)</li>
</ul>
</li>
<li>发送Cookie对象<ul>
<li>response.addCookie(Cookie cookie)</li>
</ul>
</li>
<li>获取Cookie,拿到数据<ul>
<li>Cokkkie[] request.getCookies()</li>
</ul>
</li>
</ol>
<p>实现原理：</p>
<ul>
<li>基于响应头set-cookie和请求头cookie实现</li>
</ul>
<p>cookie的细节</p>
<ol>
<li><p>一次可以发送多个Cookie对象，使用response调用多次addCookie方法发送Cookie即可</p>
</li>
<li><p>cookie在浏览器中的保存时间</p>
<p>默认情况下，当浏览器关闭或，cookie数据被销毁</p>
<p>持久化存储：</p>
<ul>
<li>setMaxAge(int seconds)<ol>
<li>正数：将cookie数据写到硬盘的文件中。持久化存储，cookie的存活时间</li>
<li>负数：默认值</li>
<li>零：删除cookie信息</li>
</ol>
</li>
</ul>
</li>
<li><p>cookie能不能存中文</p>
<p>在tomcat8之前cookie中不能直接存储中文数据</p>
<ul>
<li>需要将中文数据转码—-一般采用URL编码(%E3)</li>
</ul>
<p>在tomcat之后，cookie支持中文数据</p>
</li>
<li><p>cookie共享问题</p>
<p>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享</p>
<ul>
<li>默认情况不能共享</li>
</ul>
<p>setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录</p>
<ul>
<li>如果要共享，则可以将path设置为”&#x2F;“</li>
</ul>
<p>不同的tomcat服务器之间cookie共享</p>
<p>setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享</p>
<ul>
<li>setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</li>
</ul>
</li>
</ol>
<p>Cookie的特点</p>
<ol>
<li>cookie存储数据在客户端浏览器</li>
<li>浏览器对于单个cookie的大小有限制(4kb)以及对同一个域名下的总cookie数量也有限制（20个）</li>
</ol>
<p>作用：</p>
<ol>
<li>cookie一般用于储存少量的不太敏感的数据</li>
<li>在不登录的情况下，完成服务器对客户端的身份识别</li>
</ol>
<h6 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h6><p>记住上一次访问时间</p>
<p>需求：</p>
<ol>
<li>访问一个Servlet,如果是第一次访问，则提示：您好，欢迎您首次访问</li>
<li>如果不是第一次访问，则提示：欢迎回来，您上次访问的时间为：显示时间字符串</li>
</ol>
<p>分析：</p>
<ol>
<li><p>可以采用cookie来完成</p>
</li>
<li><p>在服务器中的Srevlet判断是否有一个名为lastTime的cookie</p>
<ol>
<li><p>有：不是第一次访问</p>
<p>响应数据：欢迎回来，您上次访问的时间为：2018年6月10日8:50:01</p>
<p>写回Cookie:lastTime&#x3D;2018年6月10日11:50:01</p>
</li>
<li><p>没有：是第一次访问</p>
<p>响应数据：你好，欢迎您首次访问</p>
<p>写回Cookie:lastTime&#x3D;2018年6月10日11:50:01</p>
</li>
</ol>
</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>概念：在服务器端会话技术，在一次会话中的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
<h5 id="快速入门-3"><a href="#快速入门-3" class="headerlink" title="快速入门"></a>快速入门</h5><ol>
<li><p>获取HttpSession对象</p>
<p>HttpSession session &#x3D; request.getSession();</p>
</li>
<li><p>使用HttpSession对象</p>
<p>Object getAttribute(String name)</p>
<p>void setAttribute(String name,Object value)</p>
<p>void removeAttribute(String name)</p>
<p>session.getId()</p>
</li>
</ol>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>Session的实现是依赖于Cookie的</p>
<p>会在第一次响应中给响应头一个Session的id，之后会一直在请求头中携带，通过id来找到这个Session</p>
<h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>当客户端关闭后，服务器不关闭，两次获取session是否为同一个</p>
<ul>
<li><p>默认情况下不是</p>
</li>
<li><p>如果需要相同，可以创建cookie,键为JSESSIONID,设置最大存活时间，让cookie持久化保存</p>
<p>Cookie c&#x3D;new Cookie(“JSESSIONID”,session.getId())</p>
<p>c.setMaxAge(60*60);</p>
<p>response.addCookie(c)</p>
</li>
</ul>
<p>当客户端不关闭，服务器关闭后，两次获取的session是同一个吗</p>
<ul>
<li>不是同一个，但是要确保数据丢失</li>
<li>session的钝化：在服务器正常关闭之前，将session对象系列化到硬盘上</li>
<li>session的活化：在服务器启动后，将session文件转化为内存中的session对象即可</li>
<li>tomcat会自动完成这个，但idea不会</li>
</ul>
<p> session什么时候被销毁</p>
<ol>
<li><p>服务器关闭</p>
</li>
<li><p>session对象调用invalidate()</p>
</li>
<li><p>session默认失效时间 30分钟</p>
<p>选择性配置修改</p>
<p><code>&lt;session-config&gt;</code></p>
<p><code>&lt;session-timeout &gt;30&lt;session-timeout&gt;</code></p>
<p><code>&lt;/session-config&gt;</code></p>
</li>
</ol>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>session用于存储一次会话的多次请求的数据，存在服务器端</li>
<li>session可以存储任意类型的没有数据大小限制。Cookie有限制</li>
<li>session数据安全，Cookie相对不安全</li>
</ol>
<h6 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h6><p>验证码：</p>
<ol>
<li>访问带有验证码的登录页面login.jsp</li>
<li>用户输入用户名，密码以及验证码<ul>
<li>如果用户名和密码有误，跳转登录页面，提示：用户名或密码错误</li>
<li>如果验证码输入有误，跳转登录页面，提示验证码错误</li>
<li>如果全部输入正确，这跳转到主页success.jsp，显示：用户名，欢迎你</li>
</ul>
</li>
</ol>
<p>  <img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240809145658525.png" alt="image-20240809145658525"></p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>java Servlet Pages:java服务器端页面</p>
<p>一个特殊页面，其中既可以指定定义html标签，有可以定义java代码</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>jsp本质上就是一个servlet</p>
<h4 id="JSP的脚本"><a href="#JSP的脚本" class="headerlink" title="JSP的脚本"></a>JSP的脚本</h4><p>jsp定义java代码的方式</p>
<ol>
<li>&lt;%  代码  %&gt;:定义的java代码，在sevlet方法中，servlet方法中可以定义什么，脚本中就可以定义什么</li>
<li>&lt;%!   代码   %&gt;:定义的java代码，在jsp转换或的java成员位置</li>
<li>&lt;%&#x3D;    代码   %&gt;:定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本就可以定义什么</li>
</ol>
<h4 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h4><p>在jsp页面中不需要获取和创建，可以直接使用的对象</p>
<p>jsp一共有9个内置对象</p>
<ul>
<li>response</li>
<li>request</li>
<li>out:字符输出流对象，可以将数据输出到页面上</li>
</ul>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>用于配置JSP页面，导入资源文件</p>
<p>格式：&lt;%@ 指令名称 属性名1&#x3D;属性值1 属性名2&#x3D;属性值2…%&gt;</p>
<p>分类：</p>
<ol>
<li><p>page:配置JSP页面的</p>
<p>contentType:等同于response.setContentType()</p>
<ol>
<li>设置响应体的mine类型以及字符集</li>
<li>设置当前jsp页面的编码（只能是高级的IDE才能生效，如果是使用低级工具，这需要设置pageEncoding属性设置当前页面的字符集）</li>
</ol>
<p>import：导包</p>
<p>errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</p>
<p>inErrorPage:标识当前页面是否是错误页面</p>
<ul>
<li>true:是，可以使用内置对象exception</li>
<li>false:否。默认值，不可以使用内置对象exception</li>
</ul>
</li>
<li><p>include:页面包含的，导入页面的资源文件</p>
<ul>
<li>&lt;%@include file&#x3D;”toip.jsp”%&gt;</li>
</ul>
</li>
<li><p>taglib:导入资源</p>
<ul>
<li>&lt;%@ taglib prefix&#x3D;”c” uri&#x3D;”<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ %&gt;</li>
</ul>
</li>
</ol>
<h4 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h4><ol>
<li>html注释：<!--   -->只能注释html代码片段</li>
<li>jsp注释：&lt;%–     –%&gt;:可以注释所有，在源码中都不会显现</li>
</ol>
<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>在jsp页面中不需要创建，直接使用的对象</p>
<p>一共有9个：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>真实类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pageContext</td>
<td>PageContext</td>
<td>当前页面共享数据，还可以获取其他八个内置对象</td>
</tr>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
<td>一次请求访问的多个资源(转发)</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
<td>一次会话的多个请求间</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
<td>所有用户间共享数据</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse</td>
<td>响应对象</td>
</tr>
<tr>
<td>page</td>
<td>Object</td>
<td>当前页面（Servlet)的对象tjis</td>
</tr>
<tr>
<td>out</td>
<td>JspWriter</td>
<td>输出对象，数据输出到页面上</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig</td>
<td>Servlet的配置对象</td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h1 id="MVC开发模式"><a href="#MVC开发模式" class="headerlink" title="MVC开发模式"></a>MVC开发模式</h1><p> <img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240809180230193.png" alt="image-20240809180230193"></p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ol>
<li>M:Model，模型.JavaBean<ul>
<li>完成具体的业务操作，如：查询数据库，封装对象</li>
</ul>
</li>
<li>V：View，视图.JSP<ul>
<li>展示数据</li>
</ul>
</li>
<li>C：Controller，控制器。Servlet<ul>
<li>获取用户的输入</li>
<li>调用模型</li>
<li>将数据交给视图</li>
</ul>
</li>
</ol>
<p>优缺点：</p>
<ol>
<li>优点：<ol>
<li>耦合性低，方便维护，可以利于分工协作</li>
<li>重用性高</li>
</ol>
</li>
<li>缺点：<ol>
<li>使得项目架构复杂，对开发人员要求高</li>
</ol>
</li>
</ol>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>概念：Expression Language 表达式语言</p>
<p>作用：替换和简化jsp页面中java代码的编写</p>
<p>语法：${表达式}</p>
<p>注意：</p>
<ul>
<li>jsp默认支持el表达式的，如果要忽略el表达式</li>
</ul>
<ol>
<li>设置jsp中的page指令中：isELIgnored&#x3D;”true”忽略当前jsp页面中的所有el表达式</li>
<li>\ ${表达式}：忽略当前这个el表达式</li>
</ol>
<p>使用：</p>
<ol>
<li><p>运算：</p>
<ul>
<li><p>运算符：</p>
<p>算术运算符：+，-，*，&#x2F;(div)，%(mod)</p>
<p>比较运算符：&gt;  &lt;  &gt;&#x3D;  &lt;&#x3D;  &#x3D;&#x3D;  !&#x3D;</p>
<p>逻辑运算符：&amp;&amp;(and)  ||(or)  !(not)</p>
<p>空运算符：empty</p>
<ul>
<li>功能：用于判断字符串，集合，数组对象是否为null并且长度是否为0</li>
<li>${emply list}</li>
</ul>
</li>
</ul>
</li>
<li><p>获取值</p>
<p>el表达式只能从域对象中获取值</p>
<p>语法：</p>
<p>${域名.键名}：从指定的域中获取指定键的值</p>
<ul>
<li>域名称：</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th align="left">实际</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>名称</td>
<td align="left">实际</td>
<td>作用</td>
</tr>
<tr>
<td>pageScope</td>
<td align="left">pageContext</td>
<td><code>PageContext</code>代表当前 JSP 页面的上下文环境,生命周期与当前 JSP 页面的执行周期一致</td>
</tr>
<tr>
<td>requestScope</td>
<td align="left">request</td>
<td>代表一次 HTTP 请求的范围。在一个请求处理过程中，多个组件（如 Servlet、Filter、JSP）可以通过这个作用域共享数据。这个作用域的生命周期是整个请求处理过程</td>
</tr>
<tr>
<td>sessionScope</td>
<td align="left">session</td>
<td>代表用户的会话范围。在用户与服务器的一次会话期间，多个请求可以共享数据。</td>
</tr>
</tbody></table>
<p>  举例在resquest域中存储了name&#x3D;张三</p>
<p>  获取：${requsetScope.name}</p>
<p>${键名}：表示依次从最小的域中查询是否有该键对应的值，直到找到为止</p>
<p>   获取对象：List集合的值。Map集合的值</p>
<ol>
<li>对象：${域名称.键名.属性名}</li>
</ol>
<ul>
<li>本质上会去调用对象的getter方法</li>
</ul>
<ol start="2">
<li>List集合：</li>
</ol>
<ul>
<li>${域名称.键名[索引]}</li>
</ul>
<ol start="3">
<li>Map集合</li>
</ol>
<ul>
<li>${域名称.键名称.ket名称}</li>
<li>${域名称.键名称[“ket名称”]}</li>
</ul>
<p>隐式对象：</p>
<ul>
<li><p>el表达式中有11隐式对象</p>
</li>
<li><p>pageContext:</p>
<p>获取jsp其他八个隐式对象</p>
<p>${pageContext.requset.contextPath}:动态获取虚拟目录</p>
</li>
</ul>
<h2 id="JSPL"><a href="#JSPL" class="headerlink" title="JSPL"></a>JSPL</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>jsp标志标签库</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用于简化和简化jsp页面上的jar包</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>导入jstl相关jar包</li>
<li>引入标签库：tablib指令：&lt;%@ taglib %&gt;</li>
<li>使用标签</li>
</ol>
<h3 id="常见的JSTL标签"><a href="#常见的JSTL标签" class="headerlink" title="常见的JSTL标签"></a>常见的JSTL标签</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>相当于java代码的if语句</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>test为必须属性，接受boolean表达式</p>
<ul>
<li>如果表达式为true，则显示if标签体内容。如果为false，这不显示标签体内容</li>
<li>一般情况下test属性值会结合el表达式一起使用</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>c:if 标签没有else情况，想要else情况，则可以定义一个c:if 标签</p>
<h4 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h4><p>相当于java中的Switch语句</p>
<ol>
<li>使用choose标签声明————————相当于Switch</li>
<li>使用when标签声明做判断——————相当于case</li>
<li>使用otherwise标签做其他情况的声明—相当于default</li>
</ol>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>相当于java中的for语句</p>
<ol>
<li><p>完成重复的操作</p>
<p>for(int i&#x3D;0;i&lt;10;i++){}</p>
<p>属性：</p>
<ul>
<li>begin：开始值</li>
<li>end：结束值</li>
<li>var：临时变量</li>
<li>step：步长</li>
<li>varStatus:循环状态对象</li>
<li>index:容器中的元素的索引，从0开始</li>
<li>count：循环次数，从1开始</li>
</ul>
</li>
<li><p>遍历容器</p>
<p><code>List&lt;User&gt; list;</code></p>
<p><code>for(User user:list)&#123;&#125;</code></p>
<p>属性：</p>
<ul>
<li>items:容器对象</li>
<li>var：容器中的临时变量</li>
<li>varStatus:循环状态对象</li>
<li>index:容器中的元素的索引，从0开始</li>
<li>count：循环次数,从1开始</li>
</ul>
</li>
</ol>
<h2 id="三层架构："><a href="#三层架构：" class="headerlink" title="三层架构："></a>三层架构：</h2><ol>
<li>界面层（表示层）：用户看的见的界面，用户可以通过界面上的组件和服务器进行交互</li>
<li>业务逻辑层：处理业务逻辑的</li>
<li>数据访问层：操作数据存储文件的</li>
</ol>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810155639977.png" alt="image-20240810155639977"></p>
<h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>需求：用户信息的查询和修改</p>
</li>
<li><p>设计：</p>
<ol>
<li>技术选型：Servlet+JSP+Mysql+JDBCTempleat+Duird+BeanUtils+tomact</li>
<li>数据库选型：</li>
</ol>
</li>
<li><p>开发：</p>
<ol>
<li>搭建环境<ol>
<li>创建数据库环境</li>
<li>创建项目，导入需要的jar包</li>
</ol>
</li>
<li>编码</li>
</ol>
</li>
<li><p>测试</p>
</li>
<li><p>部署运维</p>
</li>
</ol>
<h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><h5 id="UserListServlet"><a href="#UserListServlet" class="headerlink" title="UserListServlet"></a>UserListServlet</h5><ol>
<li>调用service层的findAll().返回List集合。List<User></li>
<li>将List集合存入requset域中</li>
<li>转发list.jsp页面展示</li>
</ol>
<p>UserService service &#x3D; new UserServiceImpl();</p>
<p>list.jsp</p>
<p>foreach标签遍历list集合生成表格table</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810162644729.png" alt="image-20240810162644729"></p>
<h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810210119148.png" alt="image-20240810210119148"></p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810210042236.png" alt="image-20240810210042236"></p>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810210649513.png" alt="image-20240810210649513"></p>
<h5 id="删除选中"><a href="#删除选中" class="headerlink" title="删除选中"></a>删除选中</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810212452346.png" alt="image-20240810212452346"></p>
<h5 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h5><p> <img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810215556672.png" alt="image-20240810215556672"></p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810220116311.png" alt="image-20240810220116311"></p>
<p>多条件组合加查询</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240810220806503.png" alt="image-20240810220806503"></p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>：过滤器</p>
<p>web中的过滤器：当访问服务器的资源的时候，过滤器可以将请求拦截下来，完成一些特殊的功能</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>：一般用于完成一些同样的操作。如：登录验证，统一编码处理，特殊字符过滤等操作</p>
<h3 id="快速入门-4"><a href="#快速入门-4" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>定义一个类，实现一个接口Filter</p>
</li>
<li><p>复写方法</p>
</li>
<li><p>配置拦截路径</p>
<p>web.xml</p>
<p>注解</p>
</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span><span class="comment">//访问所有资源之前，都会执行该过滤器</span></span><br><span class="line">pulic <span class="keyword">void</span> <span class="title function_">init</span> <span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletExcption&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFiler</span><span class="params">(ServletRequest servletRequest,ServleResponse,FilterChain filterChain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;filterDemo1被执行了...&quot;</span>)；</span><br><span class="line">filterChain.doFilter(servletRequest,servletResponse);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤器细节"><a href="#过滤器细节" class="headerlink" title="过滤器细节"></a>过滤器细节</h3><h4 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;daom1&lt;filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;cn.itcast.web.filter.FilterDome1&lt;/fiilter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping</span></span><br></pre></td></tr></table></figure>

<h4 id="过滤器执行流程"><a href="#过滤器执行流程" class="headerlink" title="过滤器执行流程"></a>过滤器执行流程</h4><p>执行过滤器</p>
<p>执行放行后的资源</p>
<p>回来执行过滤器放行下的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFiler</span><span class="params">(ServletRequest servletRequest,ServleResponse,FilterChain filterChain)</span> <span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line"><span class="comment">//放行之前就会被执行</span></span><br><span class="line">System.out.println(<span class="string">&quot;filterDemo1被执行了...&quot;</span>)；</span><br><span class="line"><span class="comment">//放行</span></span><br><span class="line">filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"><span class="comment">//放行之后被执行</span></span><br><span class="line">System.out.println(<span class="string">&quot;放行了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="过滤器生命周期方法"><a href="#过滤器生命周期方法" class="headerlink" title="过滤器生命周期方法"></a>过滤器生命周期方法</h4><ol>
<li>init:在服务器启动后，会创建Filter对象，然后调用inti方法。只执行一次，用于加载资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pulic <span class="keyword">void</span> <span class="title function_">init</span> <span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletExcption&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>doFilter:每一次请求被拦截资源时会执行，可以执行多次</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFiler</span><span class="params">(ServletRequest servletRequest,ServleResponse,FilterChain filterChain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;filterDemo1被执行了...&quot;</span>)；</span><br><span class="line">filterChain.doFilter(servletRequest,servletResponse);&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>destroy:在服务器关闭后，Filter对象被销毁。如果服务器时正常关闭，则会执行destroy方法，只执行一次。用于释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过滤器配置详解"><a href="#过滤器配置详解" class="headerlink" title="过滤器配置详解"></a>过滤器配置详解</h4><p>拦截资源路径配置：</p>
<ol>
<li><p>具体资源路径：&#x2F;index.jsp 只有访问index.jsp资源时，过滤器在回被执行 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/index.jsp&quot;)</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>拦截目录：&#x2F;user&#x2F;* 访问&#x2F;user下的所有资源时过滤器都会被执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/user/*&quot;)</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>后缀名拦截：*.jsp 不要写&#x2F;   访问所有后缀名为jsp资源时，过滤器都会执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;*.jsp&quot;)</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>拦截所有资源：&#x2F;*    访问所有资源时，过滤器都会执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>拦截方式配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns=&quot;/*&quot;,filterName=&quot;abc&quot;,dispatcherTypes = DispatcherType.REQUEST)</span></span><br><span class="line"><span class="comment">//uripatterns:过滤器拦截的路径</span></span><br><span class="line"><span class="comment">//filterName:过滤器的名称</span></span><br><span class="line"><span class="comment">//dispatcherTypes：过滤器拦截的方式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注解配置：设置dispatcherTypes属性</p>
<p>REQUEST:默认值，浏览器直接请求资源</p>
<ul>
<li>dispatcherTypes&#x3D;DispatcherType.REQUEST</li>
</ul>
<p>FORWAD:转发访问资源</p>
<ul>
<li>dispatcherTypes&#x3D;DispatcherType.FORWAD</li>
</ul>
<p>INCLUDE:包含访问资源</p>
<ul>
<li>dispatcherTypes&#x3D;DispatcherType.INCLUDE</li>
</ul>
<p>ERROR:错误跳转资源</p>
<ul>
<li>dispatcherTypes&#x3D;DispatcherType.ERROR</li>
</ul>
<p>ASYNS:异步访问资源</p>
<ul>
<li>dispatcherTypes&#x3D;DispatcherType.ASYNS</li>
</ul>
</li>
<li><p>web.xml配置</p>
<p>设置<dispther></dispatcher>标签即可</p>
</li>
</ul>
<h4 id="过滤器链（配置多个过滤器）"><a href="#过滤器链（配置多个过滤器）" class="headerlink" title="过滤器链（配置多个过滤器）"></a>过滤器链（配置多个过滤器）</h4><p>过滤器的先后顺序：</p>
<ol>
<li>注解配置：按照类名的字符串比较规则比较，值小的先执行</li>
</ol>
<ul>
<li>如：ADDlter和BDDlter，ADDlter就会先执行，再比如Acl3和Acl17，Acl17会先执行1&lt;3</li>
</ul>
<ol start="2">
<li>web.xml配置：<filter-mapping>谁定义在上边，谁先执行</li>
</ol>
<p>执行顺序:如果有两个过滤器：过滤器1和过滤器2：</p>
<ol>
<li>过滤器1</li>
<li>过滤器2</li>
<li>资源执行</li>
<li>过滤器2</li>
<li>过滤器1</li>
</ol>
<h4 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h4><h5 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h5><p>登录验证：</p>
<p>需求：</p>
<ol>
<li>访问day1_case案例的资源，验证其是否登录</li>
<li>如果登录，则直接放行</li>
<li>如果没有登录就跳转到登录页面，提示“您还未登录请先登录”。</li>
</ol>
<p>分析：</p>
<ol>
<li>判断是否登录相关的资源<ul>
<li>是，直接放行</li>
<li>不是，判断是否登录</li>
</ul>
</li>
<li>判断当前用户是否登录，判断Session中是否会有User<ul>
<li>是，已经登录</li>
<li>没有，有没登录，跳转到登录页面</li>
</ul>
</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req,Servlet resp,FilterChain chain)</span><span class="keyword">throws</span> ServletException&#123;</span><br><span class="line">   <span class="comment">// 强制转换</span></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">    <span class="comment">//获取资源请求路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"> <span class="comment">//判断是否包含登录的相关资源,要注意排查掉css/js/图片/验证码等资源</span></span><br><span class="line">    <span class="keyword">if</span>(uri.contains(<span class="string">&quot;/login.jsp&quot;</span>)||uri.contains(<span class="string">&quot;/loinServlet&quot;</span>）||uri.contains(<span class="string">&quot;/css/&quot;</span>)||uri.contain(<span class="string">&quot;/js/&quot;</span>)||uri.contain(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//包含，用户是想登录，放行</span></span><br><span class="line">        chain.doFilter(req,resp);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//不包含，需要验证用户是否登录</span></span><br><span class="line">    <span class="comment">//从session中获取user</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="literal">null</span>)&#123;</span><br><span class="line">chain.doFilter(req,resp);&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//没有登录，跳转登录页面</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;login_msg&quot;</span>,<span class="string">&quot;您尚未登录，请登录&quot;</span>);</span><br><span class="line">            request.getRequestDispacher(<span class="string">&quot;/login.jsp&quot;</span>).forward(request,resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="敏感词汇过滤"><a href="#敏感词汇过滤" class="headerlink" title="敏感词汇过滤"></a>敏感词汇过滤</h5><p>要想让req中的数据改变：你是坏蛋–&gt;你是**</p>
<p>方法：</p>
<ol>
<li>对req对象的getParameter方法进行增强产生一个新的request对象</li>
<li>放行。将新的request对现场传入</li>
</ol>
<p>chain.doFilter(req,resp);</p>
<h6 id="增强对象的功能："><a href="#增强对象的功能：" class="headerlink" title="增强对象的功能："></a>增强对象的功能：</h6><p>设计模式：一些通用的解决固定问题的方式</p>
<ol>
<li><p>装饰模式</p>
</li>
<li><p>代理模式</p>
<p>概念：</p>
<ol>
<li>真实对象：被代理的对象</li>
<li>代理对象：</li>
<li>代理模式：代理对象代理真是对象，达到增强真实对象的目的</li>
</ol>
<p>实现方式：</p>
<ol>
<li>静态代理：有一个类文件描述代理模式</li>
<li>动态代理：在内存中形成代理类</li>
</ol>
<p>实现步骤：</p>
<ol>
<li>代理对象和真实对象实现相同的接口</li>
<li>代理对象 &#x3D; Proxy.newProxyInstance();</li>
<li>实现代理对象调用方法</li>
<li>增强方法</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTestP</span>&#123;</span><br><span class="line">    <span class="comment">//创建真实对象</span></span><br><span class="line">    <span class="type">Lenovo</span> <span class="variable">lenovo</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Lenovo</span>();</span><br><span class="line">    <span class="comment">//动态代理增强lenovo对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    三个参数：</span></span><br><span class="line"><span class="comment">    1. 类处理器，真实对象.getClass().getClassLoader()</span></span><br><span class="line"><span class="comment">    2. 接口数组，真实对象.getClass(),getInterfaces()</span></span><br><span class="line"><span class="comment">    3. 处理器：new InvocationHandle()&#123;&#125;匿名内部类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Proxy.newProxyInstance(lenovo.getClass.getClassLoader(),lenovo.getClass(),getInterfaces(),<span class="keyword">new</span> <span class="title class_">InvocationHandle</span>()&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        代理逻辑编写的方法：代理对象调用的所有方法都会触发该方法的执行</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">        1. proxy：代理对象</span></span><br><span class="line"><span class="comment">        2. method：代理对象调用的方法，被封装为的对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span><span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;该方法执行了.....&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">String</span> <span class="variable">computer</span> <span class="operator">=</span> lenovo.sale(<span class="number">8000</span>);</span><br><span class="line">    System,out.println(computer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><p>：web的三大组件之一</p>
<p>事件监听机制</p>
<ul>
<li>事件：一件事情</li>
<li>事件源:事件发生的地方</li>
<li>监听器：将事件,事件源,监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码</li>
</ul>
<p>监听器对象：</p>
<p>ServletConrtextListener:监听ServletContext对象的创建和销毁</p>
<p>方法：</p>
<ul>
<li>void contextDestroyed(ServletContextEvent sce): SerletContext对象被销毁之前会调用该方法</li>
<li>void ContextInitialized(ServletContextEvent sce):ServletContext对象创建后会调用该方法</li>
</ul>
<p>步骤：</p>
<ol>
<li>定义一个类，实现ServletContextListener接口</li>
<li>复写方法</li>
<li>配置<ol>
<li>web.xml</li>
<li>注解</li>
</ol>
</li>
</ol>
<p>先在web.xml配置文件配置键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;6.0&quot;</span>&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        <span class="comment">//键的名称</span></span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        <span class="comment">//资源文件的地址在classes下的地址</span></span><br><span class="line">        &lt;param-value&gt;/WEB-INF/classes/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ContextListent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletContextListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">contextListent</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听ServletContext对象创建的。ServletContext对象服务器启动后自动创建</span></span><br><span class="line"><span class="comment">     * 在服务器启动后自动调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sce</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//加载资源文件</span></span><br><span class="line">        <span class="comment">//1. 获取SwevletCOntext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        <span class="comment">//2加载资源文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextConfigLocation</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;contextConfigLocation&quot;</span>);</span><br><span class="line">        <span class="comment">//3获取真实路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(contextConfigLocation);</span><br><span class="line">        <span class="comment">//加载进内存</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletContext被创建。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在服务器关闭后，ServletContext对象被销毁，服务器正常关闭后该方法被调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sce</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletContext对象被销毁了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><p>一个javaScript框架。简化js开发</p>
<p>优化了HTML文档操作，事件处理，动画设计和Ajax交互</p>
<h3 id="快速入门-5"><a href="#快速入门-5" class="headerlink" title="快速入门"></a>快速入门</h3><h3 id="JQuery对象和JS对象区别与转换"><a href="#JQuery对象和JS对象区别与转换" class="headerlink" title="JQuery对象和JS对象区别与转换"></a>JQuery对象和JS对象区别与转换</h3><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><h3 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h3><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>概念：异步的javaScript和xml</p>
<p>异步和同步：客户端和服务器端相互通信的基础上</p>
<ul>
<li>同步：客户端必须等待服务器端的响应不能做其他操作</li>
<li>异步：客户端不需要等待服务器端的响应，在服务器处理请求的过程中，客户端可以进行其他的操作</li>
</ul>
<p>Ajax是一种在无需重新加载整个页面的情况下，能更新部分页面的技术，提升用户体验</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240926160956129.png" alt="image-20240926160956129"></p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JavaScript对象表示法</p>
<p>在java中的对象表示使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">p.setAge(<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> p=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;23&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>json现在多用于存储和交换文本信息的语法</p>
<p>进行数据的传输</p>
<p>json比xml更小，更快，更易解析。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>数据在名称&#x2F;值对中：json数据是由键值对构成的</p>
<p>键用引号引起来，也可以不使用引号</p>
<p>键值对类型：</p>
<ol>
<li>数字(整数或浮点数)</li>
<li>字符串：(在双引号中)</li>
<li>逻辑值(true或false)</li>
<li>数组(在方括号中) {“persons”:[{},{}]}</li>
<li>对象(在花括号中){“address”:{“procince”:”陕西”….}}</li>
<li>null</li>
</ol>
<p>数据由逗号分隔：多个键值对由逗号分隔</p>
<p>花括号保存对象：使用{}定义json格式</p>
<p>方括号保存数组：[]</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h2><p>redis是一款高性能的NOSQL系列的非关系型数据库</p>
<p>NOSQL泛指非关系型数据库各个数据之间没有关系</p>
]]></content>
  </entry>
</search>
