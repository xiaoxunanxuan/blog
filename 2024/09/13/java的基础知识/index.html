<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java的基础知识 | study的记录</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1：使用的是java11.0。java.8公司使用的最多的 java跨windows等操作平台操作。java有jam（翻译）java虚拟机从而进行跨平台操作。 JRE：java的运行环境包含JVM要运行java安装JRE就可以了 JDK：包含JRE和开发环境 bin：JDK的各种工具命令。java和javac就在。 conf：JDK的相关配置文件 jmods：JDK的各种模块 include：一些">
<meta property="og:type" content="article">
<meta property="og:title" content="java的基础知识">
<meta property="og:url" content="http://example.com/2024/09/13/java%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="study的记录">
<meta property="og:description" content="1：使用的是java11.0。java.8公司使用的最多的 java跨windows等操作平台操作。java有jam（翻译）java虚拟机从而进行跨平台操作。 JRE：java的运行环境包含JVM要运行java安装JRE就可以了 JDK：包含JRE和开发环境 bin：JDK的各种工具命令。java和javac就在。 conf：JDK的相关配置文件 jmods：JDK的各种模块 include：一些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-09-13T12:14:58.000Z">
<meta property="article:modified_time" content="2024-10-10T07:34:20.777Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/friend_404.gif"><link rel="canonical" href="http://example.com/2024/09/13/java%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java的基础知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-10 15:34:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="study的记录"><span class="site-name">study的记录</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java的基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-13T12:14:58.000Z" title="发表于 2024-09-13 20:14:58">2024-09-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-10T07:34:20.777Z" title="更新于 2024-10-10 15:34:20">2024-10-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java的基础知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/top1.jpg');"></div><article class="post-content" id="article-container"><p>1：使用的是java11.0。java.8公司使用的最多的</p>
<p>java跨windows等操作平台操作。java有jam（翻译）java虚拟机从而进行跨平台操作。</p>
<p>JRE：java的运行环境包含JVM要运行java安装JRE就可以了</p>
<p>JDK：包含JRE和开发环境</p>
<p>bin：JDK的各种工具命令。java和javac就在。</p>
<p>conf：JDK的相关配置文件</p>
<p>jmods：JDK的各种模块</p>
<p>include：一些头文件</p>
<p>legal：模块的授权文档</p>
<p>lib：补充JAR包。</p>
<p>2：DOS命令，运行cmd</p>
<p>盘符：回车（切换盘）。dir（查看现路径下的内容。cd目录（进入目录）。cd..（退回上级目录）。cd目录\目录。cd\ 。cls(清屏)。exit(退出)。</p>
<h2 id="这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。"><a href="#这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。" class="headerlink" title="这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。"></a>这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。</h2><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h5 id="1注释："><a href="#1注释：" class="headerlink" title="1注释："></a>1注释：</h5><p>说明。单行注释//   .多行注释/*  <em>/.文本注释/</em>*    */.</p>
<p>java中最基本的组成单位是类。类的定义格式： public class 类名{}。mian方法是入口</p>
<h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>字母全部小写。有特殊颜色标记。</p>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>固定不变的。</p>
<p>字符串，整数，小数，字符，布尔，空(null)</p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>字节B位(比特位)b</p>
<p>byte 1.short 2.int 4(默认).long 8.float 4.double 8(默认).char 2. boolean 1(布尔).</p>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>暂存位置。int a=19；a=10；</p>
<p>一定要给值。不是默认类型要加L(long)，F(float).</p>
<h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p>由数字，字母，下划线()和美元符()组成</p>
<p>不以数字开头，不是关键字，区分大小写。</p>
<p>小驼峰命名法(方法，变量)：一个单词首字母小写，多个单词的时候第一单词首小写其他首大写</p>
<p>大驼峰命名法(类)：一个单词首字母大写，多个单词的时候每个首字母大写  </p>
<p>类型转换</p>
<p>自动类型转换：表示数据范围小的变成数据表示范围大的 从大到小类型不兼容int k=(int)88.8。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h6 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h6><p>+-*/% （byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double）</p>
<p>字符加操作：会用字母的ASKNA值（’A’=65,’a’=97,’0’=48)  会自动提升类型</p>
<p>字符串的加操作：将两个拼接，1+99+“王”=100王；王+1+99=王199；</p>
<h6 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h6><p>在赋值时要转换类型   扩装的赋值预算符隐含强制类型转换</p>
<h6 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h6><p>i++ ；++i； –i；i–；单独使用和参与操作使用；</p>
<h6 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h6><p>值只为为ture或false;</p>
<h6 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h6><p>&amp;：有false则为false（和）全运行；</p>
<p>|：有true则true（或）；</p>
<p>^:同为false,不同为true；</p>
<p>！：相反；</p>
<h6 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h6><p>&amp;&amp;：有false则为false（和）若第一个为false则右边不执行；</p>
<p>||：有true则true（或）若第一个为false则右边不执行；</p>
<h6 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h6><p>a&gt;b?a:b：对为a错为b；</p>
<h6 id="两只老虎"><a href="#两只老虎" class="headerlink" title="两只老虎"></a>两只老虎</h6><p>判断其体重是否相同</p>
<p>有三元运算符</p>
<h6 id="三个和尚"><a href="#三个和尚" class="headerlink" title="三个和尚"></a>三个和尚</h6><p>求三个身高的最高值</p>
<p>也用三元运算符</p>
<h3 id="数据输入Scanner"><a href="#数据输入Scanner" class="headerlink" title="数据输入Scanner:"></a>数据输入Scanner:</h3><p><code>import java.util.Scanner;</code>(导包的动作必须在类定义的上边)</p>
<p><code>Scanner sc=new Scanner(System.in);</code>(sc为变量名可变)创建对象</p>
<p><code>int i=sc.nextInt();</code>(i是变量名可变，sc与上面对应)；接收数据</p>
<h6 id="三个和尚-1"><a href="#三个和尚-1" class="headerlink" title="三个和尚"></a>三个和尚</h6><p>录入三个身高再求最大值</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>顺序结构</p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>1if（关系表达式）{</p>
<p>语句体；}关系表达式为true就执行语句；</p>
<p>2 if（）{</p>
<p>语句体1}else{</p>
<p>语句体2}</p>
<p>3 if（）{</p>
<p>语句1；}else if（）{</p>
<p>语句体2；}else if（）{</p>
<p>语句体3；}—else if（）{</p>
<p>语句体n-1；}</p>
<h6 id="判断是奇偶数"><a href="#判断是奇偶数" class="headerlink" title="判断是奇偶数"></a>判断是奇偶数</h6><p>用if语句</p>
<h6 id="考试奖励"><a href="#考试奖励" class="headerlink" title="考试奖励"></a>考试奖励</h6><p>不同的分有不同的奖励95<del>100山地自行车；90</del>94游乐场80~89变形金刚；80以下竹笋炒肉一顿</p>
<h6 id="数据测试：正确数据，边界数据，错误数据"><a href="#数据测试：正确数据，边界数据，错误数据" class="headerlink" title="数据测试：正确数据，边界数据，错误数据"></a>数据测试：正确数据，边界数据，错误数据</h6><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>switch(表达式){</p>
<p>case值1：语句体1；</p>
<p>​                  break；</p>
<p>case值2：</p>
<p>​                语句体2；</p>
<p>​                 break；……</p>
<p>default：语句体n+1；</p>
<p>break;</p>
<p>}把表达式的值与case比较相同运行其语句遇到break退出</p>
<p>case穿透：无break会向下走直到遇到break退出</p>
<h6 id="春夏秋冬"><a href="#春夏秋冬" class="headerlink" title="春夏秋冬"></a>春夏秋冬</h6><p>输入一个月份输出季节；</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><p>for（初始化语句；条件判断语句；条件控制语句）{</p>
<p>循环体语句}</p>
<p>先初始化再判断语句之后循环语句最后控制语句</p>
<h6 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h6><p>输出9*9乘法表；</p>
<h6 id="求和-sum；"><a href="#求和-sum；" class="headerlink" title="求和 sum；"></a>求和 sum；</h6><h6 id="求偶数和"><a href="#求偶数和" class="headerlink" title="求偶数和"></a>求偶数和</h6><h6 id="输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）"><a href="#输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）" class="headerlink" title="输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）"></a>输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）</h6><p>对任意数字的指定位置上的值：先整除到个位再求余取出</p>
<h6 id="统计水仙花数输出其数量"><a href="#统计水仙花数输出其数量" class="headerlink" title="统计水仙花数输出其数量"></a>统计水仙花数输出其数量</h6><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>初始化；</p>
<p>while（条件判断语句）</p>
<p>{</p>
<p>循环语句；</p>
<p>条件控制语句；}</p>
<h6 id="珠穆朗玛峰8844-43米用一张厚度为0-1毫米。问折叠几次可折成珠峰高度"><a href="#珠穆朗玛峰8844-43米用一张厚度为0-1毫米。问折叠几次可折成珠峰高度" class="headerlink" title="珠穆朗玛峰8844.43米用一张厚度为0.1毫米。问折叠几次可折成珠峰高度"></a>珠穆朗玛峰8844.43米用一张厚度为0.1毫米。问折叠几次可折成珠峰高度</h6><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h4><p>do {</p>
<p>循环体语句；</p>
<p>条件控制语句；}while（条件判断语句）;</p>
<p>三个循环区别：1do while至少一次</p>
<p>2for可直接在初始化时定义但不能带出循环</p>
<p>死循环格式：<code>for(;;){}</code></p>
<p><code>while(true){}</code></p>
<p><code>do{}while(true);</code></p>
<h4 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h4><p>continue跳过这次循环进行下一次循环</p>
<p>break退出循环不再循环</p>
<h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>循环语句中包含循环语句</p>
<h6 id="输出一天的小时和分钟"><a href="#输出一天的小时和分钟" class="headerlink" title="输出一天的小时和分钟"></a>输出一天的小时和分钟</h6><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>作用：获得一个随机数；</p>
<p>步骤：导包：<code>import java.util.Random:</code></p>
<p>创建对象：<code>Random r=new Random()；</code>（r可以变，其他不能变。）</p>
<p>获得随机数：<code>int number=r.nextInt(10);</code>(获取数据范围为[0~10）number是变量名，可变，数字10可变。)</p>
<h6 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h6><p>大了小了中了都会提示；</p>
<h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a><strong>idea</strong></h2><hr>
<ul>
<li><p><strong>src中有java文件</strong></p>
</li>
<li><p><strong>out中有class文件</strong></p>
</li>
</ul>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a><strong>项目结构</strong></h4><p><strong>项目（project）——&gt;模块（modern）——&gt;包——&gt;类</strong></p>
<h4 id="内容辅助键和快捷键"><a href="#内容辅助键和快捷键" class="headerlink" title="内容辅助键和快捷键"></a>内容辅助键和快捷键</h4><ul>
<li><p>生成main()方法：psvm回车。</p>
</li>
<li><p>生成输出语句：sout回车。</p>
</li>
<li><p>Ctrl+Alt+space(内容提示，代码补全等).</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">单行注释</th>
<th align="center">多行注释</th>
<th align="center">格式化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ctrl+/,再来就是取消</td>
<td align="center">ctrl+shift+/再来就是取消</td>
<td align="center">ctrl+alt+L</td>
</tr>
</tbody></table>
<h4 id="模块操作"><a href="#模块操作" class="headerlink" title="模块操作"></a>模块操作</h4><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>同类型，大量的数据的数据模型。</p>
<ol>
<li><p>数据类型[] 变量名 <code>int[] arr</code>定义了一个int类型的数组，名为arr。</p>
</li>
<li><p>数据类型 变量名[]<code>int arr[]</code>定义了一个int类型的变量，名为arr数组。</p>
</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>分配内存空间，并赋值。</p>
<h5 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h5><p>只指定数组长度，由系统为数组分配初始值</p>
<p>数据类型[] 变量名=new 数据类型[数组长度]；</p>
<p><code>int [] arr = new int[3];</code></p>
<table>
<thead>
<tr>
<th>int</th>
<th>[  ]</th>
<th>arr</th>
<th>new</th>
<th>int</th>
<th>[     ]</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>数组中的元素类型</td>
<td>说明这是数组</td>
<td>数组名</td>
<td>为数组申请空间</td>
<td>数组中的元素类型</td>
<td>说明这是一个数字</td>
<td>数组长度</td>
</tr>
</tbody></table>
<h4 id="数组元素访问"><a href="#数组元素访问" class="headerlink" title="数组元素访问"></a>数组元素访问</h4><ul>
<li>数组变量访问</li>
</ul>
<p>​    格式：数组名</p>
<ul>
<li>数组元素</li>
</ul>
<p>​     格式：数组名[索引]</p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><code>int [] arr = new int[3];</code></p>
<p>会分配两个空间分别储存地址和元素</p>
<ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th>int [] arr</th>
<th>new int[3]</th>
</tr>
</thead>
<tbody><tr>
<td>指向地址(001)(栈内存)</td>
<td>001(地址)0—0  1—0  2—0（堆内存）</td>
</tr>
</tbody></table>
</li>
</ul>
<p>栈内存：是局部变量使用完后会消失</p>
<p>堆内存：new出来的内容（实体，对象）数组在初始化时会为存储空间添加默认值（new出来的东西会在垃圾回收器空闲时被回收）。</p>
<ul>
<li>整数：0；</li>
<li>浮点数：0.0；</li>
<li>布尔：false；</li>
<li>字符：空字符；</li>
<li>引用数据类型：null；</li>
</ul>
<p>int[ ] arr = new int[2];</p>
<p>int[] arr2=new int[3];</p>
<p>System.out.println(arr);(地址)</p>
<p>System.out.println(arr[0]);</p>
<p>System.out.println(arr[1]);</p>
<p>System.out.println(arr2);</p>
<p>System.out.println(arr[0]);</p>
<p>System.out.println(arr[2]);</p>
<h5 id="数组内存多个数组指向一个"><a href="#数组内存多个数组指向一个" class="headerlink" title="数组内存多个数组指向一个"></a>数组内存多个数组指向一个</h5><p><code>int[] arr=new int[3];</code></p>
<p><code>int[] arr2=arr;</code></p>
<h4 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h4><p>初始化时指定数组元素初始值，由系统决定数组长度。</p>
<p>格式：数据类型[] 变量名=new 数据类型[]{数据1，数据2……};</p>
<p><code>int [] arr= new int[]{1,2,3};</code></p>
<p>简化：</p>
<p><code>int[] arr={1,2,3};</code></p>
<h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><p>索引越界：访问了数组中不存在的元素。</p>
<p>空指针异常：访问的数组不再指向堆内存。null（空指针）。</p>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>数组元素个数：<code>arr.lengh</code></p>
<h5 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h5><p>定义变量取数组第一个数再一次比较</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h3><p>方法是将独立的代码块组织成一个整体，使其成为代码集（类似c语言中的函数）</p>
<ul>
<li>方法定义：方法先创建再使用</li>
<li>方法调用：创建后不直接运行，需手动使用。</li>
</ul>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><code>public static void 方法名(数据类型 变量名1...)</code></p>
<p><code>{</code></p>
<p><code>方法体；}</code></p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>格式：方法名(参数)；</p>
<h6 id="一个方法打印最大值"><a href="#一个方法打印最大值" class="headerlink" title="一个方法打印最大值"></a>一个方法打印最大值</h6><p>形参：方法定义中的参数；</p>
<p>实参：方法调用中的参数；</p>
<h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><p><code>public static 返回值类型 变量名（）{</code></p>
<p><code>...</code></p>
<p><code>return 参数；}</code></p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>数据类型 变量名=方法名（参数）；</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><p>不能嵌套定义</p>
</li>
<li><p>void表示无返回值</p>
</li>
</ul>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><ul>
<li>多个方法在同类中</li>
<li>相同的方法名</li>
<li>参数不同，类型不同或数量不同（与返回值无关）</li>
</ul>
<p><code>public static int sun(int a,int b){</code></p>
<p><code>return a+b;}</code></p>
<p>``public ststic doublie sun(doublie a,double b){`</p>
<p><code>return a+b;}</code></p>
<p><code>public ststic int sun(int a,int b int c){</code></p>
<p><code>return a+b+c;}</code></p>
<p>当用public ststic int sun(20,30)时为第一个方法；</p>
<p>通过参数的不同来区别不同方法；</p>
<h6 id="比较两个数使用全整数（byte-short-int-long）并确定是哪个方法。"><a href="#比较两个数使用全整数（byte-short-int-long）并确定是哪个方法。" class="headerlink" title="比较两个数使用全整数（byte short int long）并确定是哪个方法。"></a>比较两个数使用全整数（byte short int long）并确定是哪个方法。</h6><h3 id="方法参数传递"><a href="#方法参数传递" class="headerlink" title="方法参数传递"></a>方法参数传递</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>形参的改变不影响实参的值</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><h4 id="对引用类型的形参影响实参（用地址改变实参）"><a href="#对引用类型的形参影响实参（用地址改变实参）" class="headerlink" title="对引用类型的形参影响实参（用地址改变实参）"></a>对引用类型的形参影响实参（用地址改变实参）</h4><h4 id="其类型为：类，接口，数组，String（字符串）"><a href="#其类型为：类，接口，数组，String（字符串）" class="headerlink" title="其类型为：类，接口，数组，String（字符串）"></a>其类型为：类，接口，数组，String（字符串）</h4><p>ln有换行的作用</p>
<p>System.out.print()——不换行</p>
<h6 id="用方法求数组遍历"><a href="#用方法求数组遍历" class="headerlink" title="用方法求数组遍历"></a>用方法求数组遍历</h6><h6 id="用方法求数组最大值"><a href="#用方法求数组最大值" class="headerlink" title="用方法求数组最大值"></a>用方法求数组最大值</h6><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>概述：查看程序执行流程 ，追踪程序来调试程序</p>
<h4 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h4><p>加断点，运行Debug,按F7继续运行。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h6 id="减肥计划星期1-2-3-4-5-6-7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）"><a href="#减肥计划星期1-2-3-4-5-6-7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）" class="headerlink" title="减肥计划星期1,2,3,4,5,6,7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）"></a>减肥计划星期1,2,3,4,5,6,7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）</h6><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><ul>
<li>手动导包</li>
<li>快捷键：ail+回车</li>
<li>自动导包</li>
</ul>
<h6 id="逢七过包含7或7的倍数"><a href="#逢七过包含7或7的倍数" class="headerlink" title="逢七过包含7或7的倍数"></a>逢七过包含7或7的倍数</h6><h6 id="不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。"><a href="#不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。" class="headerlink" title="不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。"></a>不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。</h6><h6 id="百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。"><a href="#百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。" class="headerlink" title="百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。"></a>百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。</h6><h6 id="数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr-68-27-95-88-171-996-51-210"><a href="#数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr-68-27-95-88-171-996-51-210" class="headerlink" title="数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr[]={68,27,95,88,171,996,51,210}"></a>数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr[]={68,27,95,88,171,996,51,210}</h6><h6 id="数组内容是否相同"><a href="#数组内容是否相同" class="headerlink" title="数组内容是否相同"></a>数组内容是否相同</h6><h6 id="查找找数在数组中的位置"><a href="#查找找数在数组中的位置" class="headerlink" title="查找找数在数组中的位置"></a>查找找数在数组中的位置</h6><p>返回值为索引</p>
<h6 id="反转：把数组反转（借助一个空间）"><a href="#反转：把数组反转（借助一个空间）" class="headerlink" title="反转：把数组反转（借助一个空间）"></a>反转：把数组反转（借助一个空间）</h6><h6 id="评委打分去掉最高分和最低分再算平均分"><a href="#评委打分去掉最高分和最低分再算平均分" class="headerlink" title="评委打分去掉最高分和最低分再算平均分"></a>评委打分去掉最高分和最低分再算平均分</h6><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>类是对现实生活中一类具有共同属性和行为的事物的抽象。</p>
<ul>
<li>类是对象的数据类型</li>
<li>类是具有相同属性和行为的集合</li>
</ul>
<p>属性：对象具有的各种特征，每个对象的每个属性都有特定的值</p>
<p>行为：对象能干什么</p>
<p>对象：是能看到的真实的实体</p>
<p>类是对象的抽象。</p>
<p>类是java的基本组成单位</p>
<p>类的组成：属性和行为</p>
<p>属性和行为在类中的体现：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>成员变量</td>
<td>成员方法</td>
</tr>
</tbody></table>
<p>javabean类不写main方法(不写main方法的类)。</p>
<p>定义步骤：</p>
<ul>
<li>定义类</li>
<li>编写类的成员变量</li>
<li>编写类的成员方法</li>
</ul>
<p><code>public class Phone{</code></p>
<p><code>//成员变量</code></p>
<p><code>String brand;</code></p>
<p><code>int price;</code></p>
<p><code>//成员方法</code></p>
<p><code>public void call(){</code></p>
<p><code>System.out.println("打电话")</code></p>
<p><code>public void sendMessage(){</code></p>
<p><code>System.out.println("发短信");} </code></p>
<h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h4><p>创建</p>
<ul>
<li>格式：类名 对象名=new 类名();</li>
<li>范例：Phone p=new Phone();</li>
</ul>
<p>使用</p>
<p>1:使用成员变量     </p>
<ul>
<li>格式：对象名.变量名</li>
<li>范例：p.brond</li>
</ul>
<p>2:使用成员方法</p>
<ul>
<li>格式：对象名.方法名()</li>
<li>范例：p.call()</li>
</ul>
<h6 id="案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。"><a href="#案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。" class="headerlink" title="案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。"></a>案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。</h6><h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><p>能创建多个对象</p>
<p>使用对象在内存中的流程：</p>
<ul>
<li>在栈内存中创建main方法给对象一个地址</li>
<li>在堆内存中创建成员变量（地址一样），在栈内存中使用成员方法。</li>
<li>若有多个对象，重复上述流程（不同的对象的地址不同）</li>
</ul>
<p>多个对象指向相同（其地址相同）</p>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ul>
<li><p>成员变量：类中方法外的变量</p>
</li>
<li><p>局部变量：方法中的变量</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>区别</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类位置不同</td>
<td>类中方法外</td>
<td>方法内或方法声明上</td>
</tr>
<tr>
<td>内存中位置不同</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期不同</td>
<td>随着对象的存在而存在，随着对象的消失而消失</td>
<td>随着方法的调用而存在，随着方法的完毕而消失</td>
</tr>
<tr>
<td>初始值不同</td>
<td>有默认的初始值</td>
<td>没有默认的初始值，必须定义，赋值</td>
</tr>
</tbody></table>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h4><ul>
<li><p>是一个权限权限修饰符</p>
</li>
<li><p>可以修饰成员（成员方法和成员变量）</p>
</li>
<li><p>作用是保护成员不被别的类使用，被private修饰的成员旨在本类中才能访问</p>
<p>针对private修饰的成员变量，如果需要被其他类使用，则需要提供相应的操作（在本类中设置方法）</p>
<ul>
<li>提供“get变量名（）”方法，用于获取成员变量的值，方法用public修饰</li>
<li>提供“set变量名（参数）“方法，用于设置成员变量的值，方法用public修饰</li>
<li>方法可以加判断</li>
</ul>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在方法中加上get/set方法</p>
<ul>
<li>set方法是改变值</li>
<li>get方法是获取值</li>
</ul>
<p><code>public void setName(String n){</code></p>
<p><code>name=n;}</code></p>
<p><code>public int getName(){</code></p>
<p><code>return name;}</code></p>
<p><code>public void showName(){</code></p>
<p><code>System out.println(name);}</code></p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ol>
<li>this修饰的变量指成员变量</li>
</ol>
<ul>
<li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，不是成员变量</li>
<li>方法的形参没有与成员变量同名，不在this的变量也值成员变量</li>
</ul>
<ol start="2">
<li><p>作用：解决局部变量隐藏成员变量</p>
</li>
<li><p>this：代表所在类的对象引用</p>
</li>
</ol>
<h4 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h4><h4 id="封装概述"><a href="#封装概述" class="headerlink" title="封装概述"></a>封装概述</h4><ul>
<li><p>面向对象的三大特征（封装，继承，多态）</p>
</li>
<li><p>是面向对象语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的</p>
</li>
</ul>
<h4 id="封装原则"><a href="#封装原则" class="headerlink" title="封装原则"></a>封装原则</h4><p>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的getXxx()/setXxx()方法</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>提高了代码的安全性</li>
<li>提高了代码的复用性</li>
</ul>
<h3 id="构造方法。"><a href="#构造方法。" class="headerlink" title="构造方法。"></a>构造方法。</h3><p>一种特殊的方法</p>
<p>格式：</p>
<p>public class 类名{</p>
<p>修饰符 类名(参数){</p>
<p>}}</p>
<p>注意</p>
<ul>
<li>如无构造方法会默认为无参构造方法</li>
<li>若已定义则不再提供默认的构造方法</li>
<li>构造方法可以重载（推荐书写（无参）构造方法不论是否使用）</li>
</ul>
<h4 id="标准类制作"><a href="#标准类制作" class="headerlink" title="标准类制作"></a>标准类制作</h4><ul>
<li>成员变量都使用private修饰</li>
<li>构造方法提供一个无参构造方法和一个带参构造方法</li>
<li>成员方法提供每一个成员对应的setXxx()/getXxx()和显示信息的show()</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>定义：应用程序编程接口（接口类）（类似c语言中的库函数）</p>
<p>java API：JDK中提供的各种功能的java类</p>
<ul>
<li><p>导包：导入附带的软件包（可以使用其中的方法）</p>
</li>
<li><p>创建对象：创建一个具体的事物来接收类</p>
</li>
<li><p>接收数据：用具体的变量来接收对象(具体事物)其中的成员变量</p>
</li>
</ul>
<p>对象调用方法若有返回值用变量接收可用快捷键Ctrl+Alt+v</p>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>String在java.lang包下不需要导包</p>
<p>String在java中是所有“”的字符串文字</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>字符串不可变，它们的值在创建后不能被更改</li>
<li>String的值是不可变的，但可以被共享</li>
<li>字符串效果相当于字符数组(char[]),但底层原理是字节数组（byte[])</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String()</td>
<td>创建一个空白字符串对象</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符串的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] bys)</td>
<td>根据字节数组内容来创建字符串对象</td>
</tr>
<tr>
<td>String s=”abc”</td>
<td>直接赋值的方式来创建字符串对象</td>
</tr>
</tbody></table>
<h4 id="String对象的特点"><a href="#String对象的特点" class="headerlink" title="String对象的特点"></a>String对象的特点</h4><ol>
<li>通过new来创建的字符串对象，每次创建的对象都会创建一个存储空间(地址不同)</li>
<li>直接赋值来创建，只要字符串的大小顺序相同它指的都是同一个存储空间(地址相同)</li>
</ol>
<h4 id="比较equals"><a href="#比较equals" class="headerlink" title="比较equals"></a>比较equals</h4><p>使用==作比较</p>
<ul>
<li>基本类型：比较的是数据值是否相同</li>
<li>引用类型：比较的是地址是否相同</li>
</ul>
<p>方法：equals()</p>
<ul>
<li>public boolean equals(object anobject)</li>
<li>示例：<code>boolean a=s1.equals(s2)</code>s1,s2为比较的字符串</li>
</ul>
<h6 id="用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。"><a href="#用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。" class="headerlink" title="用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。"></a>用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。</h6><h5 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h5><ul>
<li>录入字符串</li>
<li>遍历字符串public char charAt(int index)；</li>
<li>for(int i=0；i&lt;line.length();i++){</li>
<li>System.out.print(line.charAt(i));}</li>
</ul>
<h6 id="统计字符次数"><a href="#统计字符次数" class="headerlink" title="统计字符次数"></a>统计字符次数</h6><ol>
<li>录入一个字符串。</li>
<li>统计三个字符个数，定义三个统计变量初始值都为0</li>
<li>遍历每一个字符</li>
<li>判断该字符是哪种类型对应其统计变量加1；</li>
<li>大写字母：ch&gt;=’A’&amp;&amp;ch&lt;=’z’</li>
</ol>
<h6 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h6><ol>
<li>定义一个int类型的数组，用静态初始化</li>
<li>定义一个方法用于把int数组中的数据按照格式拼成一个字符串返回String s=””;s+=arr[0];arr[0]会强制转换为字符串类型</li>
<li>用变量接收结果(s为形参)</li>
</ol>
<h6 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h6><ol>
<li>录入一个字符串</li>
<li>定义一个方法实现反转返回值类型为S听，参数为String s</li>
<li>在方法中倒着遍历再把字符拼接字符串并返回</li>
</ol>
<h3 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><code>String s="hellow";</code></p>
<p><code>s+="world";</code></p>
<p><code>System.out.println(s);</code></p>
<p>在堆内存中进行：</p>
<ol>
<li>创建一个空间，s存储其地址，其值为hellow</li>
<li>因为没有world的空间所以创建一个空间存储world</li>
<li>最后在创建一个空间存储两个字符串拼接在一起的值，s存储最后空间的地址</li>
</ol>
<p>因为字符串每次拼接都会创造空间，故使用StringBuilder</p>
<p>StringBuilder是可变的字符串类，在其申请的空间中改变值</p>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder()</td>
<td>创建一个空白可变字符串</td>
<td>StringBuilder sb=new StringBuilder();</td>
</tr>
<tr>
<td>public StringBuilder(Srting str)</td>
<td>根据字符串的内容来创建可变字符串对象</td>
<td>StringBuilder sb2=new StringBuilder(“hellow”);</td>
</tr>
</tbody></table>
<h4 id="添加和反转"><a href="#添加和反转" class="headerlink" title="添加和反转"></a>添加和反转</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuiler append()</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public StringBuiler reverse()</td>
<td>返回相反的字符序列</td>
</tr>
</tbody></table>
<p>append:</p>
<ul>
<li>StringBuiler sb2=sb.append(“hellow”)</li>
<li>sb.append(“hellow”)</li>
<li>sb.append(“hellow”).append(“world”).apppend(“java”).append(100)</li>
</ul>
<p>reverse:</p>
<p>sb.reverse()</p>
<h4 id="String与StringBuiler的相互转化"><a href="#String与StringBuiler的相互转化" class="headerlink" title="String与StringBuiler的相互转化"></a>String与StringBuiler的相互转化</h4><p>StringBuiler转换String通过toString();</p>
<p>String s=toString(sb);</p>
<p>String转换为StringBuiler通过构造方法</p>
<p>String s；StringBuiler sb=new StrngBuiler(s)</p>
<h6 id="定义一个方法把int数组用字符串返回"><a href="#定义一个方法把int数组用字符串返回" class="headerlink" title="定义一个方法把int数组用字符串返回"></a>定义一个方法把int数组用字符串返回</h6><ul>
<li>定义一个int类型的数组并初始化</li>
<li>定义一个方法用于把数字中的数据按指定格式拼接成一个字符串返回(用StringBuiler节省空间)</li>
</ul>
<h6 id="字符串反转-用StringBuiler"><a href="#字符串反转-用StringBuiler" class="headerlink" title="字符串反转(用StringBuiler)"></a>字符串反转(用StringBuiler)</h6><ul>
<li>录入字符串，用Scanner实现</li>
<li>定义一个方法，实现字符串反转。返回值类型为String，参数为String类型</li>
<li>在方法中用StringBuiler实现字符串反转并把结果转成String返回</li>
<li>调用方法，用变量接受并输出。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>特点：存储空间可变的存储模型</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ArrayList()</td>
<td>创建一个空的集合对象</td>
</tr>
<tr>
<td>public boolean add(E e)</td>
<td>将指定的元素追加到集合末尾</td>
</tr>
<tr>
<td>public .void add(int index,E element)</td>
<td>在指定的位置加入集合</td>
</tr>
<tr>
<td>pubilc boolean remove(Object o)</td>
<td>删除元素，并返回成功</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定元素，并返回被删除元素</td>
</tr>
<tr>
<td>public E set(int inder,E element)</td>
<td>修改指定处的元素并返回被修改元素</td>
</tr>
<tr>
<td>public E get（int inder）</td>
<td>返回指定索引处的元素</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合元素的个数</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>ArrayList<string> array = new ArrayList&lt;&gt;();</string></p>
</li>
<li><p>array.add(e)</p>
</li>
<li><p>array.add(1,E)</p>
</li>
<li><p>array.remove( Object E)</p>
</li>
<li><p>array.remove(int 2)</p>
</li>
<li><p>array.set(0,A)</p>
</li>
<li><p>array.get(0)</p>
</li>
<li><p>array.size()</p>
</li>
</ul>
<h6 id="存储字符串并遍历"><a href="#存储字符串并遍历" class="headerlink" title="存储字符串并遍历"></a>存储字符串并遍历</h6><ol>
<li>创建一个集合对象</li>
<li>在集合中添加字符串对象</li>
<li>遍历集合，首先要获得集合中的每一个元素用get(i)</li>
<li>遍历要获取集合长度用size()</li>
<li>通用格式</li>
</ol>
<p><code>for(int i;i&lt;array.size();i++){</code></p>
<p><code>String s=array.get(i);</code></p>
<p><code>System.out.println(s);}</code></p>
<h6 id="存储学生对象并遍历"><a href="#存储学生对象并遍历" class="headerlink" title="存储学生对象并遍历"></a>存储学生对象并遍历</h6><ol>
<li><p>定义学生类，成员变量用String</p>
</li>
<li><p>创建集合对象</p>
</li>
<li><p>录入学生数据</p>
</li>
<li><p>创建学生对象并添加学生数据</p>
</li>
<li><p>添加学生对象到集合中</p>
</li>
<li><p>遍历集合</p>
</li>
</ol>
<h5 id="学生管理系统"><a href="#学生管理系统" class="headerlink" title="学生管理系统"></a>学生管理系统</h5><h6 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h6><p>1.添加学生<br>2.删除学生<br>3.修改学生<br>4.查看所有学生<br>5.退出系统</p>
<h6 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h6><p>1.定义学生类{</p>
<ul>
<li>学号</li>
<li>姓名</li>
<li>年龄</li>
<li>居住地<br>标准方法(快捷键alt+insert)<br>}<br>2.用输出语句完成主界面的编写<br>3.用Scanner实现录入数据<br>4.用switch语句选择，使用方法实现<br>5.用循环再会回到主界面(System.exit()退出Java虚拟机)</li>
</ul>
<h6 id="添加学生方法编写："><a href="#添加学生方法编写：" class="headerlink" title="添加学生方法编写："></a>添加学生方法编写：</h6><p>  1.定义一个方法<br>  2.提示信息<br>  3.创建学生对象并把数据赋值给学生对象<br>  4.把学生添加到集合中</p>
<h6 id="查看学生方法"><a href="#查看学生方法" class="headerlink" title="查看学生方法"></a>查看学生方法</h6><ol>
<li>先判断是否有数据</li>
<li>显示表头信息</li>
<li>调出数据</li>
</ol>
<h6 id="删除学生的方法"><a href="#删除学生的方法" class="headerlink" title="删除学生的方法"></a>删除学生的方法</h6><ol>
<li>提示信息</li>
<li>录入要删除的学生的信息</li>
<li>遍历集合删除对象</li>
</ol>
<h6 id="修改学生的方法"><a href="#修改学生的方法" class="headerlink" title="修改学生的方法"></a>修改学生的方法</h6><ol>
<li>录入要修改的学生的信息</li>
<li>创建学生对象</li>
<li>遍历修改对应的学生信息</li>
</ol>
<p>解决删除修改时要判断数据不存在问题</p>
<p>解决添加学生学号重复问题</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>两个类有相同的的特征（变量和方法）</p>
<p>可以使子类继承父类的成员和方法</p>
<p>格式：public class 子类 extends 父类{}</p>
<p>好处：提高了代码的复用性，维护性。</p>
<p>弊端：父类变化子类也变化</p>
<p>继承中的变量访问</p>
<p>在子类中访问一个变量</p>
<ul>
<li>子类局部范围找</li>
<li>子类成员</li>
<li>父类成员</li>
<li>都不有就报错(不考虑父亲的父亲…)</li>
</ul>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>当变量名相同时：</p>
<ul>
<li><p>this关键字是访问本类的成员变量也可访问其方法</p>
</li>
<li><p>super关键字是访问父类的成员变量也可访问其方法</p>
</li>
</ul>
<h4 id="访问子类方法的特点"><a href="#访问子类方法的特点" class="headerlink" title="访问子类方法的特点"></a>访问子类方法的特点</h4><h5 id="子类构造方法"><a href="#子类构造方法" class="headerlink" title="子类构造方法"></a>子类构造方法</h5><p>子类中的构造方法都会默认访问父类的无参构造方法</p>
<p>每个子类的构造方法会默认有supre()(访问父类的无参构造方法)</p>
<p>父类中无无参构造方法：</p>
<ul>
<li>用super访问带参构造方法!</li>
<li>手写一个</li>
</ul>
<h5 id="子类方法"><a href="#子类方法" class="headerlink" title="子类方法"></a>子类方法</h5><ul>
<li>子类有方法调子类的方法</li>
<li>子类没有父类有再调用父类的方法</li>
</ul>
<h5 id="super的内存执行"><a href="#super的内存执行" class="headerlink" title="super的内存执行"></a>super的内存执行</h5><h5 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h5><ul>
<li><p>子类出现与父类一样的方法声明</p>
</li>
<li><p>在子类中加上super.方法(参数)来继承父类的方法</p>
</li>
<li><p>@Override是一个注解可以帮我看看方法重写是否相同</p>
</li>
<li><p>父类中的私有方法子类不能重写(父类私有成员是不能被继承的)</p>
</li>
<li><p>子类方法的访问权限不能比父类低(public&gt;默认&gt;私有)</p>
</li>
</ul>
<h3 id="继承的注意"><a href="#继承的注意" class="headerlink" title="继承的注意"></a>继承的注意</h3><ul>
<li>在java中一个类只能继承一个类，只支持单个继承</li>
<li>类支持多层继承</li>
</ul>
<h6 id="老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码"><a href="#老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码" class="headerlink" title="老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码"></a>老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码</h6><ol>
<li>定义老师类(姓名，年龄，教书())</li>
<li>定义学生类(姓名，年龄，学习())</li>
<li>定义测试类，测试</li>
<li>抽取共性父类，定义人类(姓名，年龄)</li>
<li>用继承改写老师类和学生类并给出各自的特有方法</li>
<li>在测试</li>
</ol>
<h6 id="猫和狗：直接使用继承实现"><a href="#猫和狗：直接使用继承实现" class="headerlink" title="猫和狗：直接使用继承实现"></a>猫和狗：直接使用继承实现</h6><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>就是文件夹，对类进行分类管理</p>
<h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>package 包名；</p>
<p><code>package com.ithema;</code></p>
<p>手动建包和自动建包</p>
<h3 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h3><p>使用不同包：</p>
<ul>
<li>需要写全路径</li>
<li>导包(简化带包操作)</li>
<li>import 包名.类名；</li>
<li>improt java.util.Scanner;</li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类中</th>
<th>同包不同类中子类无关类</th>
<th>不同包的子类</th>
<th>不同包的无关类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>能</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认</td>
<td>能</td>
<td>能</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>能</td>
<td>能</td>
<td>能</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>能</td>
<td>能</td>
<td>能</td>
<td>能</td>
</tr>
</tbody></table>
<h3 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h3><ul>
<li>修饰变量：表示该变量为常量，不能再次被赋值</li>
<li>修饰方法：表示该方法为最终方法，不能再次被重写</li>
<li>修饰类：表明该类为最终类，不能被继承</li>
</ul>
<p>修饰局部变量</p>
<p>final修饰基本类型变量为常数，数据值不能变</p>
<p>修饰引用类型变量，地址值不能变，但其内容可以改变。</p>
<h3 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h3><h6 id="static关键字是静态的意思"><a href="#static关键字是静态的意思" class="headerlink" title="static关键字是静态的意思"></a>static关键字是静态的意思</h6><h6 id="无需创建实例就可以被调动"><a href="#无需创建实例就可以被调动" class="headerlink" title="无需创建实例就可以被调动"></a>无需创建实例就可以被调动</h6><ul>
<li>被类的所有对象共享</li>
<li>可以使用类名调用也可用对象调用</li>
</ul>
<p>静态成员方法只能访问静态成员</p>
<p>静态方法和静态成员属于类本身，在类加载时就存在</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个对象，在不同时刻表现出来的不同形态</p>
<h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><ol>
<li><p>继承或实现</p>
</li>
<li><p>方法重写</p>
</li>
<li><p>有父类引用指向子类对象</p>
<p>fu f=new zi();</p>
<p>当用a调用成员时</p>
<ul>
<li>成员对象：编译看左边，执行看左边</li>
<li>成员方法：编译看左边，执行看右边</li>
<li>因为成员方法有重写</li>
</ul>
</li>
</ol>
<p>好处：定义方法的时候，使用父类型作为参数，将来在使用的时候使用具体的子类型参与操作</p>
<p>弊端：不能使用子类特有功能</p>
<h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><p>在操作类中用：public void 方法名(fu a){</p>
<p>重写的方法(必须是重写的方法别的方法不行)</p>
<p>}在操作中就是使用子类重写之后的方法，都会跳转到子类方法。</p>
<p>当多子类继承父类的时候可以少写代码到达复用性</p>
<h4 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h4><p>向上转型：(上面的那个实例</p>
<ul>
<li>从子类到父类</li>
<li>父类引用指向子类对象</li>
</ul>
<p>向下转型：(调用子类特殊方法)</p>
<ul>
<li>从父类到子类</li>
<li>父类引用转为子类对象</li>
<li>zi z=(zi)f;把父类引用强转为子类</li>
</ul>
<p>![](C:\Users\xiaoxin\Pictures\Screenshots\屏幕截图 2024-07-12 154117.png)</p>
<p>![](C:\Users\xiaoxin\Pictures\Screenshots\屏幕截图 2024-07-12 154434.png)</p>
<p>当运行到Cat cc=(Cat) a;时会报错cat类型不能强转为dog类型（父类可以强转为子类但cat和dog不为子父类关系）</p>
<h6 id="猫和狗案例（变量姓名，年龄，方法-标准类，构造方法有无参，eat方法）多态"><a href="#猫和狗案例（变量姓名，年龄，方法-标准类，构造方法有无参，eat方法）多态" class="headerlink" title="猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）多态"></a>猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）多态</h6><h3 id="抽象类概述"><a href="#抽象类概述" class="headerlink" title="抽象类概述"></a>抽象类概述</h3><ul>
<li><p>没有方法体的方法被称为抽象方法，有抽象方法的类被称为抽象类</p>
</li>
<li><p>用abstract来修饰</p>
<p>public abstract class 类名{}</p>
<p>public abstract void 方法名();</p>
</li>
<li><p>抽象方法一定是抽象类，抽象类中可以有非抽象方法，抽象类中可以没有抽象方法</p>
</li>
<li><p>抽象类中无法创建对象（不能实体化），可以参照多态的使用，通过建立子类对象实例化，这叫抽象类多态</p>
</li>
<li><p>抽象类的子类</p>
<p>要么重写抽象类中的所有抽象对象</p>
<p>要么是抽象类</p>
</li>
</ul>
<h4 id="抽象类中的成员特点"><a href="#抽象类中的成员特点" class="headerlink" title="抽象类中的成员特点"></a>抽象类中的成员特点</h4><ul>
<li>抽象类中是包含成员方法，构造方法成员方法</li>
<li>成员变量：可以是变量，也可以是常量</li>
<li>构造方法：不能实体化，用于子类访问父类数据的初始化</li>
<li>成员方法： 可以是抽象方法，必须限定子类完成某些动作，也可是非抽象方法，来提高代码的复用性</li>
</ul>
<h6 id="猫和狗案例（变量姓名，年龄，方法-标准类，构造方法有无参，eat方法）抽象思想"><a href="#猫和狗案例（变量姓名，年龄，方法-标准类，构造方法有无参，eat方法）抽象思想" class="headerlink" title="猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）抽象思想"></a>猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）抽象思想</h6><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种公共行为规范，在java中体现在对行为的抽象</p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li><p>接口是抽象的，用interface修饰，public interface 接口名{}</p>
</li>
<li><p>类实现接口，public class 类名 implements 接口名</p>
</li>
<li><p>接口不能实例化，故参照多态</p>
<p>多态形式：具体类多态，抽象类多态，接口多态</p>
<p>前提：有继承或实现关系，有方法重写，有父类\接口指向子类\实现类对象</p>
</li>
<li><p>实现和抽象类一样</p>
</li>
</ul>
<h5 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h5><ul>
<li>接口中的变量只能是常量默认修饰符，public static final</li>
<li>构造方法：没有构造方法，默认继承Object类</li>
<li>成员方法:只能是抽象方法，默认修饰符，public abstract</li>
</ul>
<h6 id="猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成"><a href="#猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成" class="headerlink" title="猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成"></a>猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成</h6><h4 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h4><ul>
<li><p>类和类是继承关系，只能单继承，但可以多层继承</p>
</li>
<li><p>类和接口是实现关系，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
</li>
<li><p>接口和接口是继承关系可以多继承</p>
</li>
</ul>
<h6 id="运动员和教练"><a href="#运动员和教练" class="headerlink" title="运动员和教练"></a>运动员和教练</h6><p>现在有乒乓球运动员和篮球运动员，乒乓球，篮球教练，乒乓球的相关人员要出国需要英语要用具体类，抽象类，和接口</p>
<p>思路:</p>
<ol>
<li>定义说英语的接口</li>
<li>定义抽象人类（吃饭）</li>
<li>定义抽象教练类，继承人类（教）</li>
<li>定义运动员类继承人类（学）</li>
<li>定义具体的篮球运动员，乒乓球运动员，篮球教练，乒乓球教练分别重写吃饭学习教说英语</li>
</ol>
<h4 id="形参和返回值的问题"><a href="#形参和返回值的问题" class="headerlink" title="形参和返回值的问题"></a>形参和返回值的问题</h4><ul>
<li><p>方法的形参作为类名是需要该类的对象</p>
</li>
<li><p>方法的返回值为是类名，返回的是该类的对象</p>
</li>
<li><p>方法的形参是抽象类名需要的是该抽象类的子类对象</p>
</li>
<li><p>方法返回值是抽象类名，需要的是该抽象类的子类对象</p>
</li>
<li><p>方法的形参是接口名，需要的是该接口的实现类对象</p>
</li>
<li><p>方法的返回值是接口名，返回的是该接口的实现类</p>
</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在类中再定义一个类</p>
<p>public class 类名{</p>
<p>修饰符 class 类名{}}</p>
<p>内部类可以直接访问外部类的成员包括私有</p>
<p>外部类要想访问内部类需要创建对象</p>
<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ol>
<li>成员内部类：在类的成员位置</li>
</ol>
<ul>
<li>外部类名.内部类名 对象名=外部类对象.内部类对象</li>
<li>Outerus.inner an=new Outer().inner();</li>
<li>一般使用定义方法来调用内部类</li>
</ul>
<ol start="2">
<li><p>局部内部类：直接写<strong>class 类名</strong></p>
<p>在类的局部位置（在成员方法内）</p>
</li>
</ol>
<ul>
<li><p>需要在方法内部创建对象并使用</p>
</li>
<li><p>该类可以直接访问外部类成员，也可访问方法内部的局部变量</p>
<ol start="3">
<li>匿名内部类：存在一个接口或类</li>
</ol>
</li>
<li><p>new 类名或接口(){</p>
</li>
<li><p>重写方法；}</p>
</li>
<li><p>本质：是一个继承了该类或实现了该接口的子类匿名对象（可以当对象使用）</p>
</li>
<li><p>接口名 i=new 接口名(){重写方法}  这就是一个接口子类对象</p>
</li>
</ul>
<h1 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h1><p>若类没有构造方法，看是否是静态的，若是就可以通过类名直接调用</p>
<p>看方法的源码，选中，ctrl b</p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>无构造方法是静态</p>
<p>直接调用</p>
<p>包含基本数学运算</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>![](C:\Users\xiaoxin\Pictures\Screenshots\屏幕截图 2024-07-13 102817.png)</p>
<p>实例：int b=Math.abs(a);</p>
<p>Math.abs(a);int</p>
<p>Math.ceil(a);double</p>
<p>Math.floor(a);double</p>
<p>Math.round(a);flaot</p>
<p>Math.max(a,b);int</p>
<p>Math.min(a,b);int</p>
<p>Math.pow(a,b);double幂次方</p>
<p>Math.random();返回值为double类型的随机数[0.0,1.0)</p>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>一些与系统交互和进行基本系统操作的方法和属性，是无构造方法是静态的类</p>
<p>包含几个常用的方法</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul>
<li><p>System.out.print();</p>
</li>
<li><p>public static void exit(int status)；终止当前运行的java虚拟机，非零表示异常终止</p>
</li>
<li><p>public static long currentTimeMillis();表示返回当前时间（以毫秒为单位）当前时间与1970年之间存在时间</p>
</li>
<li><p>System.exit(0);</p>
</li>
<li><p>System.currentTimeMillis();用两个相减可以得到程序运行时间</p>
</li>
</ul>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>是所有类的祖宗类只有一个无参构造方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>返回对象的字符串表示形式包含地址，重写后是表示内容自动生成</td>
</tr>
<tr>
<td>public boolean equals(Object   obj)</td>
<td>比较对象是否相等，默认比较地址，重写可比较内容自动生成</td>
</tr>
</tbody></table>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序：只要有大的在后面就会交换</p>
<p>简单选择排序：是只与最大的一个交换位置选择交换</p>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>用于查找和排序</p>
<p>直接调用就行</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static String toString(int[] a)</td>
<td>返回指定数组的内容的字符串表示形式</td>
</tr>
<tr>
<td>public static void sort(int[] a)</td>
<td>按照数字顺序排序指定的数组</td>
</tr>
</tbody></table>
<p>Arrays.toString(arr)</p>
<p>Arrays.sort(arr)</p>
<p>工具类的设计思想：</p>
<ul>
<li>构造方法用private修饰</li>
<li>成员用public static修饰</li>
</ul>
<h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><p>将基本数据类型封装为对象的好处是可以在对象中定义更多功能方法操作该数据</p>
<p>常用与基本数据类型与字符串之间的转换</p>
<p>![](C:\Users\xiaoxin\Pictures\Screenshots\屏幕截图 2024-07-13 150439.png)</p>
<h4 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h4><p>Integer包装int类</p>
<h5 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h5><ul>
<li><p>public Integer(int value);public Integer(String s)；【过时了】</p>
</li>
<li><p>public static Integer valueOf (int i);【现在的】</p>
</li>
<li><p>punlic static Integer valueOf(String s);</p>
</li>
</ul>
<p>实例：</p>
<ul>
<li><p>Integer i1=Integer.valueOf(100);</p>
</li>
<li><p>Integer i2=Integer.valueOf(“100”);</p>
</li>
</ul>
<h5 id="int与String的相互转化"><a href="#int与String的相互转化" class="headerlink" title="int与String的相互转化"></a>int与String的相互转化</h5><p>int-&gt;String</p>
<ol>
<li><p>字符串参与加法连接从而变成字符串</p>
<p>String s1=””+number</p>
</li>
<li><p>String s2= String.valueOf(number)</p>
<p>public static String valueOf(int i);</p>
</li>
</ol>
<ul>
<li><p>该方法是String类中的方法是将int转化为String类返回String类</p>
<p>String-&gt;int</p>
</li>
</ul>
<ol>
<li><pre><code>Integer i=new Integer.valueOf(s);

int x=i.intValue();

public int intValue();
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   int y=Integer.parseInt(s);</span><br><span class="line">   </span><br><span class="line">   public static int parseInt(String s);</span><br></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
</ol>
<ul>
<li>该方法是将String类转化为int类返回int</li>
</ul>
<h6 id="字符串数据排序"><a href="#字符串数据排序" class="headerlink" title="字符串数据排序"></a>字符串数据排序</h6><p>思路：</p>
<ol>
<li>定义一个字符串</li>
<li>把字符串遍历取出并转换为int数组</li>
<li>把int数据排序</li>
<li>把int数据拼接成字符串</li>
</ol>
<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>装箱：把基本类型转换为包装类型</p>
<p>拆箱：是把包装类型转换为基本类型</p>
<p>Interger i=100；包含自动装箱</p>
<p>i+=200；//i=i+200;i+200自动拆箱，i=i+200;自动装箱</p>
<p>在使用包装类类型的时候最好先判断是否为nulll，nulllbuneng调用方法</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>代表了一个时间以毫秒为精度单位</p>
<p>public Date();</p>
<p>public Date(long date);</p>
<p>需要导入</p>
<p>public long grtTime();获得的是日期从1970年1月1日0:00到想在的毫秒值</p>
<p>public void setTime(long time);设置时间，给的是毫秒值</p>
<h4 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h4><p>是一个具体类，用于以区域设置敏感的方式格式化和解析日期。格式化日期和解析</p>
<p>日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中，从A到Z以及从a到z引号的字母被解释为日期或时间字符串的组件的模式字母</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SimpleDateFormat()</td>
<td>构造一个SimpleDateFormat，使用默认模式和日期格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat使用给定的模式和默认的日期格式</td>
</tr>
</tbody></table>
<h5 id="格式化和解析日期"><a href="#格式化和解析日期" class="headerlink" title="格式化和解析日期"></a>格式化和解析日期</h5><ul>
<li>格式化：public final String format（Date date）将日期格式化成日期、时间字符串 </li>
<li>解析：public Date parse（String source）从给定的字符串开始解析文本以生成日期</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date d=<span class="keyword">new</span> <span class="title class_">Date</span><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">"yyyy年MM月dd日   HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">String s=sdf.format(d);<span class="comment">//传来的是上面格式的日期</span></span><br></pre></td></tr></tbody></table></figure>

<p>从String到Date</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String ss=<span class="string">"2024年08月09日 11:11:11"</span>；</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf2=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">Date dd=sdf2.parse(ss);<span class="comment">//把字符串解析成日期对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(dd);</span><br></pre></td></tr></tbody></table></figure>

<h6 id="定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类"><a href="#定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类" class="headerlink" title="定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类"></a>定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类</h6><ol>
<li><p>因为是工具类构造方法要私有化，方法静态</p>
</li>
<li><p>第一个方法：参数为要转化的日期和代表格式的字符串，再用format方法转换日期再返回字符串日期 </p>
</li>
<li><p>第二个方法：参数为要解析的字符串和字符串的格式，定义SimpleDateFormat 的对象调用parse方法再返回日期</p>
</li>
</ol>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><p>概述</p>
<ul>
<li><p>为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历提供了方法</p>
</li>
<li><p>用类方法获取Calendar对象 ，期日历字段已使用当前日期和时间初始化：</p>
<p>Calendar c= Calendar.getlnstance();</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>public int get(int field)</th>
<th>返回日历字段的值</th>
<th>int year=c.get(Calendar.YEAR);</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract void add(int filed,int amount)</td>
<td>将给定的时间量添加或减去给定的日历字段</td>
<td>c.add(Calendar.YEAR,-3)三年前的今天</td>
</tr>
<tr>
<td>public final void set (int year,int month,int date)</td>
<td>设置当前日段</td>
<td>c.set(2023,11,11)</td>
</tr>
</tbody></table>
<h6 id="二月天获取任意一年的二月有多少天"><a href="#二月天获取任意一年的二月有多少天" class="headerlink" title="二月天获取任意一年的二月有多少天"></a>二月天获取任意一年的二月有多少天</h6><ol>
<li><p>录入年份</p>
</li>
<li><p>设置日历对象的年月日</p>
<p>年：是录入</p>
<p>月：三月，月份从零开始所以设置的为2</p>
<p>日：设置为1天</p>
</li>
<li><p>三月一日往前推一天即为而与人最后一天</p>
</li>
<li><p>获取这一天输出即可</p>
</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>就是程序出现了不正常情况</p>
<p><img src="/../../themes/butterfl/source/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-15%20104324.png" alt="themes/butterfl/source/img/屏幕截图 2024-07-15 104324.png"></p>
<p>Error:严重问题，不需要处理</p>
<p>Exception:称为异常类，表示程序本身可以处理的问题</p>
<ul>
<li>RuntimeException:在编译期间是不检查的，出问题后修改代码</li>
<li>非RuntimeException:编译期间必须处理，否者不能通过编译（语法问题）</li>
</ul>
<h5 id="JVM的默认处理方案："><a href="#JVM的默认处理方案：" class="headerlink" title="JVM的默认处理方案："></a>JVM的默认处理方案：</h5><ul>
<li>把异常的名称，原因即处理异常出现的位置等信息输出到控制台</li>
<li>程序停止执行</li>
</ul>
<h4 id="异常处理（手动）"><a href="#异常处理（手动）" class="headerlink" title="异常处理（手动）"></a>异常处理（手动）</h4><h5 id="try…catch…"><a href="#try…catch…" class="headerlink" title="try…catch…"></a>try…catch…</h5><p>try{</p>
<p>可能出现异常的代码；}</p>
<p>catch(异常类名 变量名){</p>
<p>异常的处理代码}</p>
<p>程序从try里面的代码开始执行出现异常，会自动生成一个异常类对象，该对象将会被提交给java运行时的系统。当java运行时的系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行处理，执行完毕后程序还会继续往下执行</p>
<h5 id="Throwable的成员方法"><a href="#Throwable的成员方法" class="headerlink" title="Throwable的成员方法"></a>Throwable的成员方法</h5><table>
<thead>
<tr>
<th>public String getMessage()</th>
<th>返回此throwable的详细消息字符串</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>返回此可抛出的简短描述</td>
</tr>
<tr>
<td>public void printStackTrace()</td>
<td>把异常的错误信息输出在控制台上</td>
</tr>
</tbody></table>
<p>java中的异常分为两种：编译时异常和运行时异常，也称为受检异常和非受检异常</p>
<p>编译时异常：必需显示处理</p>
<p>运行时处理：无需显示处理，也可和编译时异常一样处理</p>
<h4 id="throws处理异常"><a href="#throws处理异常" class="headerlink" title="throws处理异常"></a>throws处理异常</h4><p>有时try…catch..处理不了的异常可以用throws处理</p>
<p>throws 异常类名；这个是跟在括号后面的</p>
<p>把异常抛出去了并没有处理只是让调用者来处理</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>继承exception</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 <span class="keyword">extends</span> <span class="title class_">Exception</span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 类名(){}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 类名(String message){</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line"></span><br><span class="line">}}</span><br></pre></td></tr></tbody></table></figure>

<p>还要再设一个使用类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Techer</span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span> <span class="keyword">throws</span> 类名{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(score&lt;<span class="number">0</span>||score&gt;<span class="number">100</span>){</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 类名(<span class="string">"你给的分数有误"</span>)<span class="comment">//在方法体内部抛出异常</span></span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span>{System.out.println(<span class="string">"分数正常"</span>)；</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><table>
<thead>
<tr>
<th>throws</th>
<th>throw</th>
</tr>
</thead>
<tbody><tr>
<td>用在方法后面，跟的是异常名</td>
<td>用在方法体内，跟的是异常对象名</td>
</tr>
<tr>
<td>表示抛出异常，由方法调用者来处理</td>
<td>表示抛出异常由方法体内的语句来处理</td>
</tr>
<tr>
<td>表示有出现异常的可能性，并不一定会发生这些异常</td>
<td>执行throw一定抛出了某些异常</td>
</tr>
</tbody></table>
<h1 id="集合进阶"><a href="#集合进阶" class="headerlink" title="集合进阶"></a>集合进阶</h1><p>集合：是提供了一种存储空间可变的存储模型</p>
<h4 id="集合类体系："><a href="#集合类体系：" class="headerlink" title="集合类体系："></a>集合类体系：</h4><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240715155008658.png" alt="image-20240715155008658"></p>
<h2 id="Collection集合："><a href="#Collection集合：" class="headerlink" title="Collection集合："></a>Collection集合：</h2><p>JDK无具体的实现类，只有更具体的子接口（Set，List）要调用Collection需要自己创建使用多态</p>
<p>是单例集合的顶层接口，表示一组对象，这些对象也称为Collection的元素</p>
<p>创建Collection集合的对象：</p>
<ul>
<li>多态的方式</li>
<li>具体的实现类ArrayList</li>
<li>要导入</li>
</ul>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240715160023274.png" alt="image-20240715160023274"></p>
<h4 id="Collection集合的遍历"><a href="#Collection集合的遍历" class="headerlink" title="Collection集合的遍历"></a>Collection集合的遍历</h4><p>Iterator：迭代器，集合的专用遍历方式</p>
<ul>
<li>Iterator<e> iterator():返回此集合中元素的迭代器，通过集合的iterator()的方法实现的</e></li>
<li>迭代器是通过集合的iterator()方法的到的，故它是依赖于集合存在的</li>
</ul>
<p>常用方法</p>
<ul>
<li>E next():返回迭代中的下一个元素</li>
<li>boolean hasNext():如果迭代具有更多元素，则返回true</li>
</ul>
<p>就是返回下一个元素</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">c.add(<span class="string">"hellow"</span>);</span><br><span class="line"></span><br><span class="line">c.add(<span class="string">"wrold"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it=c.iterator();whle</span><br><span class="line"></span><br><span class="line">System.out.println(it.Next());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it.hasNext){</span><br><span class="line"></span><br><span class="line">System.out.println(it.Next);}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h4><ol>
<li><p>创建集合对象</p>
</li>
<li><p>添加元素</p>
<p>2.1 创建元素</p>
<p>2.2添加元素到集合</p>
</li>
<li><p>遍历集合</p>
<ol>
<li><p>通过结合对象获取迭代器对象</p>
</li>
<li><p>通过迭代器对象的hasNext()方法判断是否还有元素</p>
</li>
<li><p>通过迭代器对象的Next()方法获取下一元素</p>
</li>
</ol>
</li>
</ol>
<h6 id="Collection集合储存学生对象并遍历"><a href="#Collection集合储存学生对象并遍历" class="headerlink" title="Collection集合储存学生对象并遍历"></a>Collection集合储存学生对象并遍历</h6><p>创建一个储存学生对象的集合，储存三个学生对象，遍历该集合</p>
<p>思路：</p>
<ol>
<li>定义学生类</li>
<li>创建Collection集合对象</li>
<li>创建学生对象</li>
<li>把学生添加到集合</li>
<li>遍历集合（迭代器方式）</li>
</ol>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><p>直接创造方法返回的类型：在方法写完后ctrl+alt+v</p>
</li>
<li><p>导入构造方法，getxxx方法，setxxx方法：alt+insert</p>
</li>
<li><p>跟进查看源码：ctrl+b</p>
</li>
<li><p>导包ait+enter(回车)</p>
</li>
</ul>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><ul>
<li>需要导入</li>
<li>有序集合（也称为序列），用户可以精准的控制列表中的每一个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素</li>
<li>与Set集合不同，列表允许重复元素</li>
<li>有序：存储和取出的元素顺序一致</li>
<li>可重复：存储的元素可以重复</li>
</ul>
<table>
<thead>
<tr>
<th>void <strong>add</strong>(int inder,E element)</th>
<th>在此集合中的指定位置插入指定的元素</th>
</tr>
</thead>
<tbody><tr>
<td>E <strong>remove</strong>(int inder)</td>
<td>删除指定索引处的元素，返回被删除元素</td>
</tr>
<tr>
<td>E <strong>set</strong>(int inder,E element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td>E <strong>get</strong>(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody></table>
<h6 id="List集合存储学生对象并遍历"><a href="#List集合存储学生对象并遍历" class="headerlink" title="List集合存储学生对象并遍历"></a>List集合存储学生对象并遍历</h6><ol>
<li>定义学生类</li>
<li>创建List集合对象</li>
<li>创建学生对象</li>
<li>把学生添加到集合</li>
<li>遍历集合（迭代器方式）</li>
</ol>
<h5 id="并发修改异常："><a href="#并发修改异常：" class="headerlink" title="并发修改异常："></a>并发修改异常：</h5><p>用迭代器时使用add等方法就会造成并发修改异常；</p>
<p>改用for循环就不会有问题</p>
<h3 id="listlterator列表迭代器"><a href="#listlterator列表迭代器" class="headerlink" title="listlterator列表迭代器"></a>listlterator列表迭代器</h3><ul>
<li><p>通过List集合的listlerator()方法得到的，所以说它是List集合特有的迭代器</p>
</li>
<li><p>它允许从任意方向遍历集合，在迭代期间膝盖列表，并获得列表中迭代器的当前位置</p>
</li>
</ul>
<h5 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h5><ul>
<li>E <strong>next</strong>()：返回迭代中的下一个元素</li>
<li>boolean <strong>hasNext</strong>():如果迭代具有更多元素，则返回true</li>
<li>E <strong>previous</strong>():返回列表的上一个元素</li>
<li>boolean <strong>hasPrevious</strong>():如果此列表迭代器在<strong>相反</strong>的方向遍历列表是具有更多元素，则返回true</li>
<li><strong>void add(E e):将指定元素插入列表</strong></li>
</ul>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>简化数组和Collecttion集合的遍历</p>
<ul>
<li>实现lterable接口的类允许其对象成为增强型for语句的目标</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li>
</ul>
<p>增强for的格式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素数据类型 变量名：数组或Collection){</span><br><span class="line">    <span class="comment">//在此处使用变量即可，变量就是元素</span></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span>[] arr={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:arr){</span><br><span class="line">        System.out.println(i)</span><br><span class="line">    }</span><br><span class="line">}<span class="comment">//会输出1，2，3，4</span></span><br></pre></td></tr></tbody></table></figure>

<h6 id="List集合储存学生对象用三种方式遍历"><a href="#List集合储存学生对象用三种方式遍历" class="headerlink" title="List集合储存学生对象用三种方式遍历"></a>List集合储存学生对象用三种方式遍历</h6><ol>
<li><p>定义学生类</p>
</li>
<li><p>创建List集合对象</p>
</li>
<li><p>创建学生对象</p>
</li>
<li><p>把学生添加到集合</p>
</li>
<li><p>遍历集合</p>
<p>迭代器：集合特有的方式</p>
<p>for：带有索引的遍历方式</p>
<p>增强for：最方便的遍历方式</p>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈顶元素，栈底元素，先进后出</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队头/前端：出队列</p>
<p>队尾/后端：入队列</p>
<p>先进先出</p>
<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p>查询快，增删慢</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>查询慢，增删快</p>
<h3 id="List集合子类"><a href="#List集合子类" class="headerlink" title="List集合子类"></a>List集合子类</h3><ul>
<li>ArrayList：底层数据结构是数组，查询快，增删慢</li>
<li>LinkedList：底层数据结构是链表，查询慢，增删快</li>
</ul>
<h6 id="分别使用ArrayList和LinkedList完成存储字符串并遍历"><a href="#分别使用ArrayList和LinkedList完成存储字符串并遍历" class="headerlink" title="分别使用ArrayList和LinkedList完成存储字符串并遍历"></a>分别使用ArrayList和LinkedList完成存储字符串并遍历</h6><p>ArrayList的遍历：</p>
<ol>
<li><p>定义学生类</p>
</li>
<li><p>创建ArrayList集合对象</p>
</li>
<li><p>创建学生对象</p>
</li>
<li><p>把学生添加到集合</p>
</li>
<li><p>遍历集合</p>
<p>迭代器：集合特有的方式</p>
<p>for：带有索引的遍历方式</p>
<p>增强for：最方便的遍历方式</p>
</li>
</ol>
<p>LinkedList的遍历</p>
<ol>
<li><p>定义学生类</p>
</li>
<li><p>创建LinkedList集合对象</p>
</li>
<li><p>创建学生对象</p>
</li>
<li><p>把学生添加到集合</p>
</li>
<li><p>遍历集合</p>
<p>迭代器：集合特有的方式</p>
<p>for：带有索引的遍历方式</p>
<p>增强for：最方便的遍历方式</p>
</li>
</ol>
<h5 id="LinkedList集合的特有功能："><a href="#LinkedList集合的特有功能：" class="headerlink" title="LinkedList集合的特有功能："></a>LinkedList集合的特有功能：</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240716195849087.png" alt="image-20240716195849087"></p>
<h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>不包含重复元素的集合，是一个接口，要导入</p>
<p>没有带索引的方法，所以不能使用普通for循环</p>
<p>HashSet:对迭代顺序不作任何保证</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>{</span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">"hellow"</span>);</span><br><span class="line">set.add(<span class="string">"world"</span>);</span><br><span class="line">set.add(<span class="string">"java"</span>);</span><br><span class="line"><span class="keyword">for</span>(String s:set){</span><br><span class="line">System.out.println(s);</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><ul>
<li><p>是JDK 根据对象的地址或字符串或数字算出来的int类型的数组</p>
</li>
<li><p>Object类中有一个方法可以获得对象的哈希值</p>
</li>
<li><p>pubhlic int hashCode():返回对象的哈希值</p>
</li>
<li><p>同一个对象的哈希值是相同的，默认情况下，不同对象的哈希值是不同的</p>
</li>
<li><p>可以重写hashCode()方法，让不同的对象实现相同</p>
</li>
</ul>
<h4 id="HashSet集合概述和特点"><a href="#HashSet集合概述和特点" class="headerlink" title="HashSet集合概述和特点"></a>HashSet集合概述和特点</h4><ul>
<li>底层数据结构是哈希表</li>
<li>对迭代顺序不作任何保证，不保证存入的顺序和取出的顺序一致</li>
<li>没有带索引的方法，所以不能使用普通for循环</li>
<li>是Set集合，不包含重复元素</li>
<li>要保证元素唯一性，就需要重写hashCode()和equals()【在对象中重写这两个方法】</li>
</ul>
<h6 id="用哈希表遍历集合"><a href="#用哈希表遍历集合" class="headerlink" title="用哈希表遍历集合"></a>用哈希表遍历集合</h6><h4 id="数据结构之哈希表"><a href="#数据结构之哈希表" class="headerlink" title="数据结构之哈希表"></a>数据结构之哈希表</h4><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240716211106932.png" alt="image-20240716211106932"></p>
<h6 id="HashSet集合存储学生对象并遍历"><a href="#HashSet集合存储学生对象并遍历" class="headerlink" title="HashSet集合存储学生对象并遍历"></a>HashSet集合存储学生对象并遍历</h6><ol>
<li>定义学生类，在其中重写hashCode和equals()方法</li>
<li>创建HashSet集合对象</li>
<li>创建学生对象</li>
<li>把学生对象添加到集合</li>
<li>遍历集合（增强for）</li>
</ol>
<h4 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h4><ul>
<li>由哈希表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储顺序和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复元素</li>
</ul>
<h6 id="存储字符串并遍历-1"><a href="#存储字符串并遍历-1" class="headerlink" title="存储字符串并遍历"></a>存储字符串并遍历</h6><h3 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h3><ul>
<li><p>元素有序，这里的有序是按照一定的规则进行排序，具体的排序方式取决于构造方法</p>
<p>TreeSet():根据其元素的自然排序进行排序</p>
<p>TreeSet(Comparator comparator):根据指定的比较器进行排序</p>
</li>
<li><p>没有带索引的方法，所以不能使用普通for循环</p>
</li>
<li><p>无重复元素,要导包</p>
</li>
<li><p>创建集合是使用的是包装类类型,会自动装箱</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">TreeSet&lt;Integer&gt; ts=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">    ts.add(<span class="number">10</span>)；</span><br><span class="line">    ts.add(<span class="number">23</span>);</span><br><span class="line">    ts.add(<span class="number">1</span>);</span><br><span class="line">    ts.add(<span class="number">21</span>);</span><br><span class="line">    <span class="keyword">for</span>(Interger i:ts){</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }<span class="comment">//会输出1,10,21,23</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="自然排序Comparable的使用"><a href="#自然排序Comparable的使用" class="headerlink" title="自然排序Comparable的使用"></a>自然排序Comparable的使用</h5><ul>
<li><p>存储学生对象并遍历，创建集合使用无参构造方法</p>
</li>
<li><p>要求：按照年龄从小到大排序，年龄相同时，按照名字字母排序</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">TreeSet&lt;student&gt; ts=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"xishi"</span>,<span class="number">23</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"wangzhuaojun"</span>,<span class="number">18</span>);</span><br><span class="line">ts.add(s1);</span><br><span class="line">ts.add(s2);</span><br><span class="line"><span class="keyword">for</span>(Student s :ts){</span><br><span class="line">System.out.println(s.getName()+<span class="string">","</span>+s.getAge());</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>重写comparaTo方法时：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">comparaTo</span><span class="params">(Student s)</span>{</span><br><span class="line">    <span class="type">int</span> num=<span class="built_in">this</span>.age-s.age;<span class="comment">//this是这个本身的对象，s是上一个的对象</span></span><br><span class="line">    num==<span class="number">0</span>?<span class="built_in">this</span>.name.comparaTo(S.name):num;<span class="comment">//次要条件姓名不相同</span></span><br><span class="line">    <span class="keyword">return</span> num;<span class="comment">//主要条件比较年龄从小到大</span></span><br><span class="line">    <span class="comment">//return 0表示重复就只能存储进第一个对象</span></span><br><span class="line">    <span class="comment">//return 1;正数表示用升序来存储</span></span><br><span class="line">    <span class="comment">//return -1;负数表示用降序来存储</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>结论：	</p>
<ul>
<li><p>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序</p>
</li>
<li><p>使用类的对象时，其类要实现compareTo接口，重写comparaTo(to)方法</p>
</li>
<li><p>自然排序</p>
</li>
<li><p>重写方法时一定要注意排序规则必须按照要求的主要条件和次要条件来重写</p>
</li>
</ul>
<h5 id="比较器排序Comparator"><a href="#比较器排序Comparator" class="headerlink" title="比较器排序Comparator"></a>比较器排序Comparator</h5><p>存储学生对象并遍历使用TreeSet的带参构造方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">TreeSet&lt;Student&gt; ts=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Student&gt;(<span class="keyword">new</span> <span class="title class_">comparator</span>&lt;Student&gt;(){</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Sudent s1,Student s2)</span>{</span><br><span class="line">   <span class="type">int</span> num=s1.age-s2.age;</span><br><span class="line">   num==<span class="number">0</span>?s1.name.comparator(s2.name):num ;</span><br><span class="line">   <span class="keyword">return</span> num</span><br><span class="line">}</span><br><span class="line">})<span class="comment">//用的是匿名内部类它需要一个comparaTo的实现类子接口</span></span><br><span class="line"> Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"xishi"</span>,<span class="number">23</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"wangzhuaojun"</span>,<span class="number">18</span>);</span><br><span class="line">ts.add(s1);</span><br><span class="line">ts.add(s2);</span><br><span class="line"><span class="keyword">for</span>(Student s :ts){</span><br><span class="line">System.out.println(s.getName()+<span class="string">","</span>+s.getAge());   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h6><ol>
<li><p>定义学生类</p>
</li>
<li><p>创建TreeSet集合对象，通过比较器进行排序或自然排序；</p>
</li>
<li><p>创建学生对象</p>
</li>
<li><p>把学生对象添加到集合中</p>
</li>
<li><p>遍历集合</p>
</li>
</ol>
<h6 id="不重复的随机数"><a href="#不重复的随机数" class="headerlink" title="不重复的随机数"></a>不重复的随机数</h6><ol>
<li>创建Set集合对象</li>
<li>创建随机数对象</li>
<li>判断集合的长度是不是小于10</li>
<li>遍历集合</li>
<li>创建随机数方法：Random</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> numbe=r.nextInt(<span class="number">20</span>)+<span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>本质是参数化类型，就是将由原来的具体的类型参数化，然后在使用时传入具体的类型</p>
<p>可以分别应用在类，方法和接口中，分别被称为泛型类，泛型方法和泛型接口</p>
<p>泛型定义格式：</p>
<ul>
<li>&lt;类型&gt;:指定一中类型格式。这里的类型可以看成是形参</li>
<li>&lt;类型1，类型2…&gt;:指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看做是形参</li>
<li>将来具体调用的时候给定的类型可以看作是实参，并且实参的类型只能是引用数据类型</li>
</ul>
<h4 id="泛型类："><a href="#泛型类：" class="headerlink" title="泛型类："></a>泛型类：</h4><ul>
<li>修饰符 class 类名&lt;类型&gt;{}</li>
<li>public class Generic<t>{}//T为随意 的任意标识</t></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gener</span>&lt;T&gt;{</span><br><span class="line"><span class="keyword">private</span> T t;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span>{</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">()</span>{</span><br><span class="line"><span class="built_in">this</span>.t=t;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Gener<string> g=new Gener<string>();</string></string></p>
<p>Gener<int> i=new Gener<int>();</int></int></p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>修饰符&lt;类型&gt; 返回值类型 方法名(类型 变量名){}</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>{</span><br><span class="line"></span><br><span class="line">System.out.println(t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>g.show(“ling”);</p>
<p>g.show(122);</p>
<p>g.show(“124”);</p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>用接口实现的泛型</p>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<ul>
<li>类型通配符：&lt;?&gt;</li>
<li>List&lt;?&gt;:表示元素型未知的List，它的元素可以匹配任何的类型</li>
<li>这种带通配符的List仅表示它是各种泛型类的父类，并不能把元素添加的其中</li>
</ul>
<p>类型通配符的上限，只表示它是代表某一类泛型List的父类</p>
<ul>
<li><!--? extends 类型-->
</li>
<li><p>List&lt;? extends Number&gt;:表示的是Number 或者其子类型</p>
</li>
</ul>
<p>类型通配符的下限</p>
<ul>
<li>类型通配符的下限：&lt;? super 类型&gt;</li>
<li>List&lt;?super Number&gt;:表示的是Number或其父类型</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? &gt; list1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;? &gt; list2=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">List&lt;? &gt; list3=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">System.out.println(<span class="string">"-----------"</span>)</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list4=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list5=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">System.out.println(<span class="string">"-----------"</span>)</span><br><span class="line">List&lt;? <span class="built_in">super</span> Number&gt; list6=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> Number&gt; list7=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br></pre></td></tr></tbody></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>参数个数可变的方法</p>
<p>public static int sum(int b,int… a){}</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>可变参数其实就是一个数组</p>
<p>当包含不变参数时，可变参数要放在最后</p>
<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><ul>
<li><p>Arrays类工具类的静态方法(static)</p>
<p>public static <t> List<t> asList(T…a):放回由指定数组的大小固定的列表</t></t></p>
<p>不能作增删，能修改</p>
</li>
<li><p>List接口中有静态方法：</p>
<p>public static<e> List<e> of(E…e):返回包含任意数量元素的不可变列表</e></e></p>
<p>不能增删改</p>
</li>
<li><p>Set接口中有一个静态方法：</p>
<p>public static<e> Set<e> of(E…e):返回一包含任意数量元素的不可变集合</e></e></p>
<p>元素不能重复，不能增删改</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=Arrays.asList(<span class="string">"hellow"</span>,<span class="string">"world"</span>,<span class="string">"javase"</span>);</span><br><span class="line"><span class="comment">//list.add("javawed");//会报错，是固定大小的数组</span></span><br><span class="line"><span class="comment">//list.remove("javase")://也会报错</span></span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">"java"</span>);</span><br><span class="line">List&lt;<span class="type">int</span>&gt; listt=List.of(<span class="number">12</span>,<span class="number">24</span>,<span class="number">353</span>,<span class="number">4652</span>);</span><br><span class="line"><span class="comment">//listt.add(21);都会报错</span></span><br><span class="line"><span class="comment">//listt.remove(12);都会报错</span></span><br><span class="line"><span class="comment">//listt.set(1,22);都会报错</span></span><br><span class="line">Set&lt;<span class="type">int</span>&gt; se=Set.of(<span class="number">12</span>,<span class="number">23</span>,<span class="number">234</span>,<span class="number">354</span>);<span class="comment">//不能有重复的元素</span></span><br><span class="line"><span class="comment">//se.add(122);//会报错</span></span><br><span class="line"><span class="comment">//se.remove(12会报错</span></span><br><span class="line"><span class="comment">//se.set(1,33);//不能调，没有带索引的方法不存在</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><ul>
<li><p>要导包，是一个接口</p>
</li>
<li><p>Interface Map&lt;K,V&gt;,k是键的类型，v是值的类型</p>
</li>
<li><p>将键映射到值的对象；不能包含重复的键每个键可以映射到最多一个值</p>
</li>
<li><p>多态方式，HashMap是具体实现对象</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V put (k key,v value)</td>
<td>将指定的值与该映射中的指定值相关联，有唯一性，出现重复的会替代，添加元素</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>删除键值对元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除所有键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断是否有指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合中键值对的个数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">"wa"</span>,<span class="string">"zhao"</span>);</span><br><span class="line">map.put(<span class="string">"guo"</span>,<span class="string">"huang"</span>);</span><br><span class="line">map.remove(<span class="string">"guo"</span>);</span><br><span class="line">map.clear();</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>获取方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V get(Object key)</td>
<td>获取键对应的值</td>
</tr>
<tr>
<td>Set<k> keySet()</k></td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td>Collection<v> values()</v></td>
<td>获取所有值的集合</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String inw=map.get(<span class="string">"wa"</span>);</span><br><span class="line">Set&lt;String&gt; key=map.keySet();</span><br><span class="line">Collection&lt;String&gt; values=map.values();</span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt; en=map.entrySet();</span><br></pre></td></tr></tbody></table></figure>

<h6 id="Map集合遍历1"><a href="#Map集合遍历1" class="headerlink" title="Map集合遍历1"></a>Map集合遍历1</h6><ol>
<li>获取所有键的集合</li>
<li>遍历键的集合</li>
<li>根据键去找值</li>
</ol>
<p>2</p>
<ol>
<li>获取键值对对象的集合</li>
<li>遍历其集合</li>
<li>获得键和值</li>
<li>getKey()和getValue()获得键和值</li>
</ol>
<h6 id="HashMap集合存储学生对象并遍历"><a href="#HashMap集合存储学生对象并遍历" class="headerlink" title="HashMap集合存储学生对象并遍历"></a>HashMap集合存储学生对象并遍历</h6><ol>
<li>定义学生类</li>
<li>创建HashMap集合对象</li>
<li>创建学生对象，值是学生对象</li>
<li>把学生对象添加到集合</li>
<li>遍历集合（键找值   或   键值对找键和值）</li>
</ol>
<h6 id="HashMap集合存储学生对象并遍历-1"><a href="#HashMap集合存储学生对象并遍历-1" class="headerlink" title="HashMap集合存储学生对象并遍历"></a>HashMap集合存储学生对象并遍历</h6><p>要求：键是学生对象，值是居住地，存储多个键值对元素，并遍历，要保证键的唯一性</p>
<ol>
<li>定义学生类，重写hashCode()和equals()方法</li>
<li>创建HashMap集合对象</li>
<li>创建学生对象</li>
<li>把学生对象添加到集合</li>
<li>遍历集合（键找值   或   键值对找键和值）</li>
</ol>
<h6 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h6><p>ArrayList集合存储HashMap元素并遍历</p>
<ul>
<li>创建ArrayList集合</li>
<li>创建HashMap集合，并添加键值对元素</li>
<li>把HashMap作为元素添加到ArrayList中</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,String&gt; hum1=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hum1.put(<span class="string">"孙十万"</span>,<span class="string">"大乔"</span>)；</span><br><span class="line">hum1.put(<span class="string">"周瑜"</span>,<span class="string">"小乔"</span>)；</span><br><span class="line">array.add(hum1);</span><br><span class="line">HashMap&lt;String,String&gt; hum2=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hum2.put(<span class="string">"郭靖"</span>,<span class="string">"黄蓉"</span>)；</span><br><span class="line">hum2.put(<span class="string">"演过"</span>,<span class="string">"小龙女"</span>)；</span><br><span class="line">array.add(hum2);</span><br><span class="line"><span class="keyword">for</span>(HashMap&lt;String,String&gt; hm:array){</span><br><span class="line">    Set&lt;String&gt; keySet=hm.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key:keySet){</span><br><span class="line">        String value=hm.get(key);</span><br><span class="line">        System.out.println(key+<span class="string">","</span>+value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>HashMap集合存储ArrayList元素并遍历</p>
<ul>
<li>创建HashMap集合</li>
<li>创建ArrayList集合，并添加元素</li>
<li>把ArrayList作为元素添加到HashMap中</li>
<li>并遍历</li>
</ul>
<h6 id="统计字符串中每个字符出现的次数"><a href="#统计字符串中每个字符出现的次数" class="headerlink" title="统计字符串中每个字符出现的次数"></a>统计字符串中每个字符出现的次数</h6><ol>
<li><p>录入一个字符串</p>
</li>
<li><p>创建HashMap集合,键是Character,值是Intrger</p>
</li>
<li><p>遍历字符串，得到每一个字符</p>
</li>
<li><p>拿得到的每一个字符到HashMap中去找对应的值，看起返回值</p>
<p>若返回值为null说明该字符在HashMap中没有，就把它作为键，1作为值存储</p>
<p>若返回值不为null说明存在，其值加1，然后重新存储该字符和值</p>
</li>
<li><p>遍历HashMap集合，得到键和值，拼接成a()b()c()</p>
</li>
</ol>
<h4 id="Collections的概述"><a href="#Collections的概述" class="headerlink" title="Collections的概述"></a>Collections的概述</h4><p>是针对集合操作的工具类</p>
<ul>
<li>public static &lt;T extends Comparable&lt;?super T&gt;&gt; void sort(List<t> list):将指定的列表按升序排序</t></li>
<li>public static void reverse(List&lt;?&gt; list):反转指定列表中的元素的顺序</li>
<li>public static void shuffle(List&lt;?&gt; list)：使用默认的随机源随机排序列表</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">Collections.sort(list);</span><br><span class="line">Collextions.reverse(list);</span><br><span class="line">Collextions.shuffle(list);</span><br></pre></td></tr></tbody></table></figure>

<h6 id="ArrayList存储大学生并排序使用Collections"><a href="#ArrayList存储大学生并排序使用Collections" class="headerlink" title="ArrayList存储大学生并排序使用Collections"></a>ArrayList存储大学生并排序使用Collections</h6><ol>
<li>定义学生类</li>
<li>创建ArrayList集合对象</li>
<li>创建学生对象</li>
<li>把学生对象添加到集合</li>
<li>使用Collections对ArrayLIst集合进行排序</li>
<li>遍历集合</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(array,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;(){</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compara</span><span class="params">(Student s1,Student s2)</span>{</span><br><span class="line">    <span class="type">int</span> num=s1.getAge-s2.getAge();</span><br><span class="line">    <span class="type">int</span> num2=(num==0s1.getName().compareTo(s2.getName()):num);</span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">}</span><br><span class="line">})<span class="comment">//这是使用匿名内部类创造了一个VComparator(调试器)子接口的具体实现类来对ArrayList进行排序</span></span><br></pre></td></tr></tbody></table></figure>

<h6 id="模拟斗地主的洗牌，发牌和看牌"><a href="#模拟斗地主的洗牌，发牌和看牌" class="headerlink" title="模拟斗地主的洗牌，发牌和看牌"></a>模拟斗地主的洗牌，发牌和看牌</h6><ol>
<li>创建一个牌盒</li>
<li>往牌盒里面装牌</li>
<li>洗牌：把牌打散</li>
<li>发牌：遍历集合，给三个玩家发牌</li>
<li>看牌，就是玩家各自遍历自己的牌</li>
</ol>
<p>升级版：</p>
<ol>
<li>创建HashMap，键是编号，值是牌</li>
<li>创建ArrayList,存储编号</li>
<li>创建花色数组，点数数组</li>
<li>从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList中存储编号</li>
<li>洗牌（洗编号），用Coolections的shuffle()方法实现</li>
<li>发牌（发编号），为了保证编号是排序的，创建TreeSet集合接收</li>
<li>定义看牌的方法（遍历TreeSet集合，获取编号，到HashMap中找对应的牌）</li>
<li>调用看牌的方法</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();<span class="comment">//创建HashMap，键是编号，值是牌</span></span><br><span class="line">ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();<span class="comment">//创建ArrayList,存储编号</span></span><br><span class="line">String[] colors={<span class="string">"♦"</span>,<span class="string">"♣"</span>,<span class="string">"♥"</span>,<span class="string">"♠"</span>};</span><br><span class="line">String[] numbers={<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"10"</span>,<span class="string">"J"</span>,<span class="string">"Q"</span>,<span class="string">"K"</span>,<span class="string">"A"</span>,<span class="string">"2"</span>};</span><br><span class="line"><span class="comment">//创建花色数组，点数数组</span></span><br><span class="line"><span class="type">int</span> inder=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String hu:colors){</span><br><span class="line">    <span class="keyword">for</span>(String mu:numbers){</span><br><span class="line">        hm.put(inder,hu+mu);</span><br><span class="line">        array.add(inder);</span><br><span class="line">        inder++;</span><br><span class="line">    }</span><br><span class="line">}  <span class="comment">//从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList中存储编号</span></span><br><span class="line">hm.put(inder,<span class="string">"小王"</span>);</span><br><span class="line">array.add(inder);</span><br><span class="line">inder++;</span><br><span class="line">hm.put(inder,<span class="string">"大王"</span>);</span><br><span class="line">array.add(inder);<span class="comment">//从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList中存储编号</span></span><br><span class="line">TreeSet&lt;Integer&gt; lqxSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();<span class="comment">//创建角色对象,创建TreeSet集合接收</span></span><br><span class="line">TreeSet&lt;Integer&gt; wtSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">TreeSet&lt;Integer&gt; lySet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">TreeSet&lt;Integer&gt; dpSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">Collections.shuffle(array);<span class="comment">//洗牌（洗编号），用Coolections的shuffle()方法实现</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.size();i++){</span><br><span class="line">    <span class="type">int</span> x=array.get(i);</span><br><span class="line">   <span class="keyword">if</span>(i&gt;=array.size()-<span class="number">3</span>){</span><br><span class="line">       dpSet.add(x);</span><br><span class="line">   } <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>){</span><br><span class="line">       lqxSet.add(x);}</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>){</span><br><span class="line">        wtSet.add(x);</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">2</span>){</span><br><span class="line">        lySet.add(x);</span><br><span class="line">    }</span><br><span class="line">}<span class="comment">// 发牌（发编号），为了保证编号是排序的，创建TreeSet集合接收</span></span><br><span class="line">lookpoker(<span class="string">"林青霞"</span>,lqxSet,hm);</span><br><span class="line">lookpoker(<span class="string">"王涛"</span>,wtSet,hm);</span><br><span class="line">lookpoker(<span class="string">"柳岩"</span>,lySet,hm);</span><br><span class="line">lookpoker(<span class="string">"底牌"</span>,dpSet,hm);<span class="comment">//看牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lookpoker</span><span class="params">(String name,TreeSet&lt;Integer&gt; tt,HashMap hm)</span>{</span><br><span class="line">    System.out.print(name+<span class="string">"的牌是："</span>);</span><br><span class="line">    <span class="keyword">for</span>(TreeSet&lt;Integer&gt; ka:tt){</span><br><span class="line">        String poker=hm.get(ka);</span><br><span class="line">        System.out.print(poker+<span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Io流"><a href="#Io流" class="headerlink" title="Io流"></a>Io流</h1><p>Io:输入/输出(Input/Output)</p>
<p>流：是一种抽象概念，是对数据传输的总称，数据在设备之间的传输称为流</p>
<p>Io流就是用来处理设备之间的传输的问题的，常应用于文件复制，文件下载，文件上传</p>
<p>按数据流向分为;</p>
<p>输入流：读数据</p>
<p>输出流：写数据</p>
<p>按数据类型分：</p>
<p>字节流：字节输入流和字节输出流</p>
<p>字符流：字符输入流和字符输出流</p>
<p>若用记事本打开能看懂就是字符流，是乱码就是字节流，一般使用字节流</p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>file：是文件和目录路径名的抽象表示</p>
<ul>
<li><p>文件和目录是可以通过File封装成对象的</p>
</li>
<li><p>对File来说，封装的并不是一个真正存在的文件，仅仅是一个路径名。他可以存在也可以不存在将来是要通过具体操作来把这个路径的内容转化为具体存在的</p>
</li>
</ul>
<h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><table>
<thead>
<tr>
<th>File(String pathname)</th>
<th>通过给定的路径名字字符串转化为抽象路径名来创建新的File实例</th>
</tr>
</thead>
<tbody><tr>
<td>File(String path,String child)</td>
<td>从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td>File(File parent,String child)</td>
<td>从父抽象路径名和子路径名字符串创建新的File实例</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"E\\ithema\\java.txt"</span>);</span><br><span class="line">System.out.println(f1);<span class="comment">//输出E\\ithema\\java.txt</span></span><br><span class="line">File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"E\\ithema"</span>,<span class="string">"java.txt"</span>);</span><br><span class="line">System.out.println(f2);<span class="comment">//输出E\\ithema\\java.txt</span></span><br><span class="line">File f3=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"E\\ithema"</span>);</span><br><span class="line">File f4=<span class="keyword">new</span> <span class="title class_">File</span>(f3,<span class="string">"java.txt"</span>);</span><br><span class="line">System.out.println(f4);<span class="comment">//输出E\\ithema\\java.txt</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h5><table>
<thead>
<tr>
<th>public boolean createNewFile()</th>
<th>当具有该名称的文件不存在时，创建一个有该抽象路径命名的新文件则返回true</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean mkdir()</td>
<td>创建由此抽象路径命名的目录</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>创建由此抽象路径命名的目录，包含任意必需但不存在的父目录</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"E\\笔记\\java.txt"</span>);<span class="comment">//创建文件，创建成功则返回true</span></span><br><span class="line">System.out.ptintln(f1.createNewFile());</span><br><span class="line">File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"E\\笔记\\javase"</span>);<span class="comment">//创建目录，创建成功则返回true</span></span><br><span class="line">System.out.ptintln(f2.mkdir());</span><br><span class="line">File f3=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"E\\笔记\\javase\\hema"</span>);</span><br><span class="line">System.out.ptintln(f3.mkdirs());<span class="comment">//一键创建多级目录，创建成功则返回true</span></span><br></pre></td></tr></tbody></table></figure>



<h5 id="File的判断和获取"><a href="#File的判断和获取" class="headerlink" title="File的判断和获取"></a>File的判断和获取</h5><table>
<thead>
<tr>
<th>public boolean isDirectory()</th>
<th>看此抽象路径名是否为目录</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isFile()</td>
<td>是否为文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>是否存在</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>返回绝对路径名字符串</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>转化为路径字符串</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回此抽象路径名表示的文件和目录</td>
</tr>
<tr>
<td>public String[] list()</td>
<td>返回此抽象路径名表示的文件和目录的名称的字符串数组</td>
</tr>
<tr>
<td>public File[] listFiles()</td>
<td>返回此抽象路径名表示的文件和目录的File对象数组</td>
</tr>
<tr>
<td>public boolean dalete()</td>
<td>删除此抽象路径表示的文件或目录，一步一步删除要先删除先删除文件</td>
</tr>
</tbody></table>
<p>绝对路径： 完整的路径名，不需要任何其他信息就可以定位</p>
<p>相对路径：必须借用其他路径的信息解释</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>不死神兔</p>
<p><strong>定义一个方法f(n)<strong>，</strong>表示第n个月兔子的对数</strong></p>
<p><strong>那么f(n-1</strong>)，<strong>表示第n-1个月的兔子对数</strong></p>
<p><strong>f(n-2),表示第n-2个月的兔子对数</strong></p>
<p><strong>再加一个出口</strong></p>
<p>递归的出口，且与原问题相似的规模较小的问题</p>
<h6 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">jc</span><span class="params">(<span class="type">int</span> a)</span>{</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> a*jc(a-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240718105820499.png" alt="image-20240718105820499"></p>
<h6 id="用递归遍历该目录下的所有内容"><a href="#用递归遍历该目录下的所有内容" class="headerlink" title="用递归遍历该目录下的所有内容"></a>用递归遍历该目录下的所有内容</h6><p>思路：</p>
<ol>
<li><p>创建一个File对象</p>
</li>
<li><p>定义一个方法，用于获取目录下的所有内容参数为File</p>
</li>
<li><p>获取该目录下的所有文件或目录的File数组</p>
</li>
<li><p>遍历该数组，得到File对象</p>
</li>
<li><p>判断该File对象是否是目录</p>
<p>是递归调用</p>
<p>不是，获取绝对路径输出</p>
</li>
<li><p>调用方法</p>
</li>
</ol>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>InputStream:这个抽象类是表示字节输入流的所有类的超类</p>
<p>OutputStream:这个抽象类是表示字节输出流的所有类的超类</p>
<p>子类名都是以其父类名作为子类名的后缀</p>
<p>FileOutputStream:文件输出流用于将数据写入File</p>
<ul>
<li>FileOutputStream(String name):创建文件输出流以指定的写入文件</li>
<li>创建了字节输出流对象</li>
<li>调动字节输出流方法写入</li>
<li>释放资源</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"developing\\fos.txt"</span>);</span><br><span class="line"><span class="comment">/*调用系统创建了文件</span></span><br><span class="line"><span class="comment">创建了字节输出流对象</span></span><br><span class="line"><span class="comment">让字节输出流对象指向文件*/</span></span><br><span class="line">fos.write(<span class="number">97</span>);<span class="comment">//在fos文件中写入a，用的是ASKMA值</span></span><br><span class="line">fos.close<span class="comment">//Io操作都要释放资源,关闭输出流并释放相关资源</span></span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>void write(int b)</th>
<th>将字节写入文件输出流，一次一个字节数据</th>
</tr>
</thead>
<tbody><tr>
<td>void write(byte[] b)</td>
<td>将b.length字节从指定的字节数组写入此文件输出流，一次一个字节数组</td>
</tr>
<tr>
<td>void write(byte[] b,int off,int len)</td>
<td>从偏移量off开始写入此文件输出流写len个，一次写一个字节数组的部分数据</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"developing\\fos.txt"</span>);</span><br><span class="line">fos.write(<span class="number">33</span>);</span><br><span class="line">fos.write(<span class="number">353</span>);</span><br><span class="line">fos.write(<span class="number">363</span>);</span><br><span class="line"><span class="type">byte</span>[] bys={<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>};</span><br><span class="line"><span class="type">byte</span>[] byy=<span class="string">"abcd"</span>.getBytes();<span class="comment">//和上面的那个写入的是一样的都是abcd</span></span><br><span class="line">fos.write(bys);</span><br><span class="line">fos.write(<span class="string">"hellow"</span>.getBytes());</span><br><span class="line">fos.write(bys,<span class="number">0</span>,bys.length);<span class="comment">//从0开始写入bys.length的字节</span></span><br><span class="line">fos.close();<span class="comment">//释放资源</span></span><br></pre></td></tr></tbody></table></figure>

<p>字节流换行：</p>
<p>window : \r\n</p>
<p>linux : \n</p>
<p>mac : \r</p>
<p>追加写入：</p>
<ul>
<li><p>public FileOutputStream(String name,boolean append)</p>
</li>
<li><p>创建文件输出流以指定的名称写入文件，若第二个参数为true则将写入文件的末尾而不是开头</p>
</li>
</ul>
<h5 id="字节流写数据加异常处理"><a href="#字节流写数据加异常处理" class="headerlink" title="字节流写数据加异常处理"></a>字节流写数据加异常处理</h5><p>finally:在异常处理事提供finally块来执行所有清除操作</p>
<p>finally语句一定执行，除非JVM退出</p>
<p>try{</p>
<p>可能出现异常的代码；</p>
<p>}catch(异常类名 变量名){</p>
<p>异常的处理代码；</p>
<p>}finally{执行所有清除操作；}</p>
<h5 id="字节流读数据"><a href="#字节流读数据" class="headerlink" title="字节流读数据"></a>字节流读数据</h5><p><strong>FileInputStream(String name)</strong>:  通过打开与实际文件的链接来创建一个FileInputStream,该文件由name命名</p>
<ul>
<li>创建了字节输入流对象</li>
<li>调动字节输入流方法写入</li>
<li>释放资源</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> by=fos.read();<span class="comment">//一次只能读一个字节的数据，输出的是ASCII值</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="type">char</span>(by));<span class="comment">//可以强制类型转换，若到达文件末尾值为-1；</span></span><br><span class="line"><span class="type">int</span> gby;</span><br><span class="line"><span class="keyword">while</span>((gny=fos.read())！=-<span class="number">1</span>){</span><br><span class="line">    System.out.print((<span class="type">char</span>)gby);</span><br><span class="line">}<span class="comment">//循环读取全部</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="复制文本文件"><a href="#复制文本文件" class="headerlink" title="复制文本文件"></a>复制文本文件</h5><p>就是把一个文件的内容从一个文件中读取出来（数据源），再写入另一个文件中（目的地）</p>
<p>思路：</p>
<ol>
<li>根据数据源创建字节输入流</li>
<li>根据目的地创建字节输出流</li>
<li>读写数据，复制文本（一次读一个字节，一次写一个字节）</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"developing\\fos.txt"</span>);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"begin\\fos.txt"</span>);</span><br><span class="line"><span class="type">int</span> by;</span><br><span class="line"><span class="keyword">while</span>((by=fis.read())!=-<span class="number">1</span>){</span><br><span class="line">    fos.write(by);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure>

<h5 id="读取一个字节数组"><a href="#读取一个字节数组" class="headerlink" title="读取一个字节数组"></a>读取一个字节数组</h5><p>int read(byte[] b):读取最多为b.length个字节的数据到一个字节数组，并返回实际读取到的长度</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"developing\\fos.txt"</span>);</span><br><span class="line"><span class="type">byte</span>[] bys=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]<span class="comment">//1024及其整数倍</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(<span class="type">byte</span>))!=-<span class="number">1</span>){</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">byte</span>,<span class="number">0</span>,len));<span class="comment">//转换成String</span></span><br><span class="line">}</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure>

<h5 id="复制图片"><a href="#复制图片" class="headerlink" title="复制图片"></a>复制图片</h5><ol>
<li>根据数据源创建字节输入流</li>
<li>根据目的地创建字节输出流</li>
<li>读写数据，复制图片（一次读一个字节数组，一次写一个字节数组）</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"developing\\fos.txt"</span>);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"begin\\fos.txt"</span>);</span><br><span class="line"><span class="type">byte</span>[] by=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(by))!=-<span class="number">1</span>){</span><br><span class="line">    fos.write(by,<span class="number">0</span>,len);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure>

<h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><p>要导包</p>
<p>字节缓冲流：</p>
<ul>
<li>BufferOutputStream:  该类实现缓冲输出流，向底层输出流写入字节，不再调动底层系统</li>
<li>构造方法：BufferedOutputStream(OutputStream out)</li>
<li>BufferInputStream:  创建一个缓冲区，流可以从中读取字节，从而填充，一次可以很多字节</li>
<li>构造方法：BufferedInputStream(InputStream in)</li>
<li>字节缓冲流仅仅提供缓冲区，而真正读写数据还得依靠基本的字节流对象操作</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileOutputStream fos=new FileOutputStream("begin\\fos.txt");</span></span><br><span class="line"><span class="comment">//BufferedOutputStream bos=new BufferedOutputStream(fos);</span></span><br><span class="line">BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"begin\\fos.txt"</span>));<span class="comment">//上面两个二合一</span></span><br><span class="line">bos.write(<span class="string">"hellow"</span>.getBytes());</span><br><span class="line">BufferedInputStream fis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"begin\\fos.txt"</span>));</span><br><span class="line"><span class="type">byte</span>[] by=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(by))!=-<span class="number">1</span>){</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(by,<span class="number">0</span>,len));</span><br><span class="line">}</span><br><span class="line">fis.close;</span><br><span class="line">bos.close;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="复制视频"><a href="#复制视频" class="headerlink" title="复制视频"></a>复制视频</h5><ol>
<li>根据数据源创建字节输入流</li>
<li>根据目的地创建字节输出流</li>
<li>读写数据，复制图片（一次读一个字节数组，一次写一个字节数组）</li>
<li>释放资源</li>
</ol>
<p>分别使用四种方式实现，并记录时间</p>
<ol>
<li>基本字节流，一次读写一个字节       //最慢</li>
<li>基本字节流，一次读写一个字节数组</li>
<li>字节缓冲流，一次读写一个字节</li>
<li>字节缓冲流，一次读写一个字节数    //最快</li>
</ol>
<h4 id="字符流："><a href="#字符流：" class="headerlink" title="字符流："></a>字符流：</h4><p>字符流=字节流+编码表</p>
<p>一个汉字存储：</p>
<p>如果是GBK编码，占用2个字节</p>
<p>如果是UTF-8编码，占用3个字节</p>
<p>第一个字节都是负数</p>
<h4 id="编码表："><a href="#编码表：" class="headerlink" title="编码表："></a>编码表：</h4><ul>
<li>计算机中的信息存储的使用二进制表示的，英文，汉字都是二进制转换而成的</li>
<li>将字符存储到计算机中，为编码。将存储在计算机的数解析显示出来，为解码</li>
</ul>
<p>字符编码是一套自然语言的字符与二进制数之间的对应规则（A,65)</p>
<p>字符集：</p>
<ul>
<li>是一个系统支持的所有字符的集合，包括各个国家的文字，标点，图形，数字等</li>
<li>计算机要准确的存储和识别各种字符集，就要进行字符编码，一套字符集必有一套编码。常见的字符集有ASCII字符集，GBXXX字符集,Unicode字符集</li>
</ul>
<h5 id="ASCII字符集："><a href="#ASCII字符集：" class="headerlink" title="ASCII字符集："></a>ASCII字符集：</h5><p>是美国为英文和各种符号，进退等编写的</p>
<h5 id="GBXXX字符集"><a href="#GBXXX字符集" class="headerlink" title="GBXXX字符集"></a>GBXXX字符集</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240718201314000.png" alt="image-20240718201314000"></p>
<h5 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h5><p>UTF-8编码</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240718201656694.png" alt="image-20240718201656694"></p>
<h5 id="字符串中编码解码"><a href="#字符串中编码解码" class="headerlink" title="字符串中编码解码"></a>字符串中编码解码</h5><p>编码：</p>
<p>byte[] getBytes():使用平台默认的字符集编码</p>
<p>byte[] getBytes(String charsetName):使用指定的字符集编码</p>
<p>String(byte[] byte):使用平台默认的字符集解码，指定的字节数组来郭建新的String</p>
<p>String(byte[] byte，String charsetName):使用指定的字符集解码</p>
<p>字符流抽象基类</p>
<ul>
<li>Reader ：字符输入流的抽象类</li>
<li>Wreter ：字符输出流的抽象类</li>
</ul>
<p>字符流中和编码解码相关的类：</p>
<ul>
<li>InputStreamReader:是从字节流到字符流的桥梁（先读再编，可指定）</li>
<li>InputStreamReader fis=new InputStreamReader(new FileInputStream(“developing\ows.txt”))</li>
<li>OutputStreamWriter：是从字符流到字节流的桥梁（先读再编，可指定）</li>
<li>OutputStreamReader fos=new OutputStreamReader(new FileOutputStream(“developing\ows.txt”))</li>
</ul>
<h5 id="写读数据"><a href="#写读数据" class="headerlink" title="写读数据"></a>写读数据</h5><table>
<thead>
<tr>
<th>void write(int c)</th>
<th>写一个字符</th>
</tr>
</thead>
<tbody><tr>
<td>void write(char[] cbuf)</td>
<td>写一个字符数组</td>
</tr>
<tr>
<td>void write(char[] cbuf,int off,int len)</td>
<td>写入字符数组的一部分</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>写一个字符串</td>
</tr>
<tr>
<td>void write(String str,int off,int len)</td>
<td>写一个字符串的一部分</td>
</tr>
</tbody></table>
<p>字符流有缓冲要刷新，flush()刷新，close()是先刷新再关闭 </p>
<table>
<thead>
<tr>
<th>int read()</th>
<th>一次读一个字符数据</th>
</tr>
</thead>
<tbody><tr>
<td>int read(char[] cbuf)</td>
<td>一次读一个字符数组数据</td>
</tr>
</tbody></table>
<h6 id="复制java文件"><a href="#复制java文件" class="headerlink" title="复制java文件"></a>复制java文件</h6><ol>
<li>根据数据源创建字符输入流</li>
<li>根据目的地创建字符输出流</li>
<li>读写数据，复制文本（一次读一个字符，一次写一个字符）</li>
<li>可以简化InputStreamReader，OutputStreamReader</li>
<li>FileReader(String fileName):用于读取字符文件的便捷类</li>
<li>FileWriter(String FileName)；用于写入文件的便捷类</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputStreamReader fis=new InputStreamReader(new FileInputStream("developing\\ows.txt"))//根据数据源创建字符输入流</span></span><br><span class="line">FileReader fis=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"developing\\ows.txt"</span>)</span><br><span class="line"><span class="comment">//OutputStreamReader fos=new OutputStreamReader(new FileOutputStream("developing\\ows.txt"))//根据目的地创建字符输出流</span></span><br><span class="line">FileWriter fos=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">"developing\\ows.txt"</span>)  </span><br><span class="line"><span class="type">char</span>[] ch=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(ch))!=-<span class="number">1</span>){</span><br><span class="line">    fos.<span class="keyword">while</span>(ch,<span class="number">0</span>,len);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure>

<h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><p>BufferedWriter:将文本写入字符输出流，缓冲字符，可指定缓冲区大小，也可默认</p>
<p>BufferedWriter(Writer out);</p>
<p>BufferedReader:从字符输入流读取文本，可指定缓冲区的大小，也可默认</p>
<p>BufferedReader(Reader in)</p>
<p>BufferedWriter bw=new BufferedWriter(new FileWriter(“”));</p>
<h6 id="复制java文件（字符缓冲流）"><a href="#复制java文件（字符缓冲流）" class="headerlink" title="复制java文件（字符缓冲流）"></a>复制java文件（字符缓冲流）</h6><ol>
<li>根据数据源创建字符缓冲输入流</li>
<li>根据目的地创建字符缓冲输出流</li>
<li>读写数据，复制文本（一次读一个字符，一次写一个字符）</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BuffererdWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">"developing\\ows.txt"</span>));</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BuffereReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"developing\\ows.txt"</span>)) ;  <span class="type">char</span>[] ch=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=br.read(ch))!=-<span class="number">1</span>){</span><br><span class="line">    bw.<span class="keyword">while</span>(ch,<span class="number">0</span>,len);</span><br><span class="line">}</span><br><span class="line">bw.close();</span><br><span class="line">br.close();</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>viod newLine()</th>
<th>写一行行分隔符，分隔符有系统定义</th>
</tr>
</thead>
<tbody><tr>
<td>public String readLine()</td>
<td>读一行文字，结果包含行的内容的字符串，不包括任何终止字符，若到达末尾则为null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BuffererdWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">"developing\\ows.txt"</span>));</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BuffereReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"developing\\ows.txt"</span>)) ; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i;i&lt;<span class="number">10</span>;i++){</span><br><span class="line">bw.write(<span class="string">"hellow"</span>+<span class="number">1</span>);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.flush();}</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>){</span><br><span class="line">    System.out.println(line);</span><br><span class="line">}</span><br><span class="line">bw.close();</span><br><span class="line">br.close();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Io流小结"><a href="#Io流小结" class="headerlink" title="Io流小结"></a>Io流小结</h4><h5 id="字节流小结"><a href="#字节流小结" class="headerlink" title="字节流小结"></a>字节流小结</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240719081409233.png" alt="image-20240719081409233"></p>
<h5 id="字符流小结"><a href="#字符流小结" class="headerlink" title="字符流小结"></a>字符流小结</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240719081610554.png" alt="image-20240719081610554"></p>
<h6 id="把集合中的数据写入文件"><a href="#把集合中的数据写入文件" class="headerlink" title="把集合中的数据写入文件"></a>把集合中的数据写入文件</h6><p>要求：每一个字符串元素作为文件的一行元素</p>
<p>思路：</p>
<ol>
<li>创建ArrayList集合</li>
<li>往集合中存储字符串元素</li>
<li>创建字符缓冲输出流对象</li>
<li>遍历集合，得到每一个字符串数据</li>
<li>调用字符缓冲输出流对象的方法写数据</li>
<li>释放资源</li>
</ol>
<h6 id="把文件中的数据读到集合中"><a href="#把文件中的数据读到集合中" class="headerlink" title="把文件中的数据读到集合中"></a>把文件中的数据读到集合中</h6><ol>
<li>创建字符缓冲输入流对象</li>
<li>创建ArrayList集合</li>
<li>调用字符缓冲输入流对象的方法读数据</li>
<li>那读取的数据存储的到集合中</li>
<li>释放资源</li>
<li>遍历集合</li>
</ol>
<h6 id="点名器"><a href="#点名器" class="headerlink" title="点名器"></a>点名器</h6><p>有一个文件存储了同学的名字，每个姓名占一行，要求实现点名器</p>
<ol>
<li>创建字符缓冲输入流对象</li>
<li>创建ArrayList集合</li>
<li>调用字符缓冲输入流对象的方法读数据</li>
<li>把独到的数据存储到集合中</li>
<li>释放资源</li>
<li>使用Random产生一个随机数范围在【0，集合长度）</li>
<li>把第6产生的的随机数的作为索引获取值</li>
<li>输出数据</li>
</ol>
<h6 id="把集合中的数据写入文件-1"><a href="#把集合中的数据写入文件-1" class="headerlink" title="把集合中的数据写入文件"></a>把集合中的数据写入文件</h6><p>要求：每一个学生对象数据作为文件的一行元素</p>
<p>思路：</p>
<ol>
<li>定义学生类</li>
<li>创建ArrayList集合</li>
<li>创建学生对象</li>
<li>把学生对象添加到集合中</li>
<li>创建字符缓冲输出流对象</li>
<li>遍历集合，得到每一个学生对象</li>
<li>把学生对象拼接成指定格式的字符串</li>
<li>调用字符缓冲输出流对象的方法写数据</li>
<li>释放资源</li>
</ol>
<h6 id="把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值"><a href="#把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值" class="headerlink" title="把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值"></a>把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值</h6><ol>
<li>定义学生类</li>
<li>创建字符缓冲输入流对象</li>
<li>创建ArrayList集合</li>
<li>调用字符缓冲输入流对象的方法读数据</li>
<li>把读到的数据用split()进行分割，得到一个字符串数组</li>
<li>创建学生对象</li>
<li>字符串数组中的每一个元素取出对应的赋值给学生对象的成员变量值</li>
<li>把学生对象添加到集合中</li>
<li>释放资源</li>
<li>遍历集合</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BuffereReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"developing\\ows.txt"</span>)) ; </span><br><span class="line">ArrayList&lt;student&gt; array=<span class="keyword">new</span> <span class="title class_">Array</span>&lt;student&gt;();</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>){</span><br><span class="line">    String[] strArray=line.split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">s.setSid(strArray[<span class="number">0</span>]);</span><br><span class="line">s.setName(strArray[<span class="number">1</span>]);</span><br><span class="line">s.setAge(Integer.parseInt(strArray[<span class="number">2</span>]));</span><br><span class="line">s.setAddress(strArray[<span class="number">3</span>]);</span><br><span class="line">array.add(s)}</span><br><span class="line">br.colse();</span><br><span class="line"><span class="keyword">for</span>(student s:array){</span><br><span class="line">  System.out.println(s.getSid()+<span class="string">","</span>+s.getName+<span class="string">","</span>+s.getAge+<span class="string">","</span>+s.getAddress);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="集合到文件"><a href="#集合到文件" class="headerlink" title="集合到文件"></a>集合到文件</h6><p>键盘录入5个学生信息（姓名，语文成绩，数学成绩，英语成绩）要去按照成绩总分从高到低写入文件</p>
<ol>
<li>定义学生类</li>
<li>创建TreeSett集合，通过比较器比较</li>
<li>键盘录入学生信息</li>
<li>创建学生对象，把信息赋值到学生变量中</li>
<li>把学生对象添加到集合中</li>
<li>创建字符缓冲输出流对象</li>
<li>遍历集合，得到每一个学生对象</li>
<li>把学生对象拼接成指定格式的字符串</li>
<li>调用字符缓冲输出流对象的方法写数据</li>
<li>释放资源</li>
</ol>
<h5 id="复制单级文件夹"><a href="#复制单级文件夹" class="headerlink" title="复制单级文件夹"></a>复制单级文件夹</h5><ol>
<li>创建数据源目录File对象，路径是E:\itcast</li>
<li>获取数据源目录File的名称(itcast)</li>
<li>创建目的地目录File对象，路径名是模块名+itcast组成</li>
<li>判断目的地对应的File是否存在，不存在就创建</li>
<li>获取数据源目录下的所有文件的File数组</li>
<li>遍历File数组，得到每一个File对象，该对象就是数据源文件</li>
<li>获取数据源文件的名称</li>
<li>创建目的地文件File对象，路径名是目的地目录+数据源对象名称组成</li>
<li>复制文件用字节流不光文件还有视频</li>
</ol>
<h5 id="复制多级文件夹"><a href="#复制多级文件夹" class="headerlink" title="复制多级文件夹"></a>复制多级文件夹</h5><ol>
<li><p>创建数据源File对象，路径是E:\itcast</p>
</li>
<li><p>创建目的地File对象，路径是F:\</p>
</li>
<li><p>写方法实现文件夹的复制，参数为数据源Flie对象和目的地File对象</p>
</li>
<li><p>判断数据源Fila是否是目录</p>
<p>是</p>
<p>在目的地下创建和数据源File名称一样的目录</p>
<p>获得数据源File下所有文件或目录File数组</p>
<p>遍历该File数组，得到每一个File对象</p>
<p>把该File作为数据源File对象，递归调用复制文件夹的方法</p>
<p>不是：直接复制</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">srcFile</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"E:\\笔记"</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">desFile</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"F:\\"</span>);</span><br><span class="line">        copyFilder(srcFile,desFile);}</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFilder</span><span class="params">(File srcFile,File desFile)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">            <span class="keyword">if</span>(srcFile.isDirectory()){</span><br><span class="line">                String srcFileName=srcFile.getName();</span><br><span class="line">                <span class="type">File</span> <span class="variable">newFolder</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(desFile,srcFileName);</span><br><span class="line">                <span class="keyword">if</span>(!newFolder.exists()){</span><br><span class="line">                    newFolder.mkdir();</span><br><span class="line">                }</span><br><span class="line">                File[] fileArray = srcFile.listFiles();</span><br><span class="line">                <span class="keyword">for</span>(File file:fileArray){</span><br><span class="line">                    copyFilder(file,newFolder);</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(desFile,srcFile.getName());</span><br><span class="line">                copyFile(srcFile,newFile);</span><br><span class="line">            }   }</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">( File srcFile,File desFile)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">            BufferedOutputStream fos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(desFile));<span class="comment">//上面两个二合一</span></span><br><span class="line">            BufferedInputStream fis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile));</span><br><span class="line">            <span class="type">byte</span>[] str=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len=fis.read(str))!=-<span class="number">1</span>){</span><br><span class="line">                fos.write(str,<span class="number">0</span>,len);</span><br><span class="line">            }</span><br><span class="line">            fos.close();</span><br><span class="line">            fis.close();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="复制文件的异常处理"><a href="#复制文件的异常处理" class="headerlink" title="复制文件的异常处理"></a>复制文件的异常处理</h4><p><strong>之前的：</strong></p>
<p>try{</p>
<p>可能出现异常的代码；</p>
<p>}catch(异常类名 变量名){</p>
<p>异常的处理代码；</p>
<p>}finally{执行所有清除操作；}</p>
<p><strong>JDK7的改进：不用抛异常</strong></p>
<p>try(定义流对象){</p>
<p>可能出现异常的代码；}</p>
<p>catch(异常类名 变量名){</p>
<p>异常的处理代码；}</p>
<p><strong>JDK9的改进：要抛出异常</strong></p>
<p>定义输出流对象；</p>
<p>定义输入流对象；</p>
<p>try(输入流对象；输出流对象){</p>
<p>可能出现异常的代码；}</p>
<p>catch(异常类名 变量名){</p>
<p>异常的处理代码；}</p>
<h2 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h2><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><ul>
<li><p>public static final InputStream in:标准输入流。通常该流对应于键盘输入或主机环境或用户指定 的另一个输入源</p>
</li>
<li><p>public static final PrintStream out:标准输出流。通常该流对应于显示输出或主机环境或用户指定的另一个输出目标</p>
</li>
<li><p><strong>标准输入流 System.in</strong></p>
</li>
<li><p>自己实现键盘录入数据：</p>
<p>BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</p>
</li>
<li><p>这么写太麻烦，java就提供了一个实现键盘录入</p>
</li>
<li><p>Scanner sc=new Scanner(System.in);</p>
</li>
<li><p><strong>标准输出流  :System.out</strong></p>
</li>
<li><p>能够方便的打印各种值</p>
</li>
<li><p>System.out.println();本质是一个标准的输出流</p>
</li>
<li><p>PrintStream ps=System.out;</p>
</li>
<li><p>PrintStream类特有的方法，System.out都可以使用</p>
</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><p>分类：</p>
<p>字节打印流</p>
<p>字符打印流</p>
<p>特点：</p>
<p>只输出数据不读取数据，有自己的特有方法</p>
<h5 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流:"></a>字节打印流:</h5><ul>
<li>PrintStream(String FileName):使用指定文件名创建新的打印流对象</li>
<li>使用继承父类的方法写数据的时候会转码(ps.write())  ,使用自己特有的方法写数据原样输出(ps.print(33);ps.println();)</li>
</ul>
<h5 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流:"></a>字符打印流:</h5><table>
<thead>
<tr>
<th>PrintWriter(String fileName)</th>
<th>使用指定的文件名创建一个新的PrintWriter,而不需要刷新</th>
</tr>
</thead>
<tbody><tr>
<td>PrintWriter(write out,boolean autoFlush)</td>
<td>创建一个新的PrintWrite  ,out:字符输出流   ，autoFlush:一个布尔值，为真则println,printf或format方法刷新缓冲区</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw=<span class="keyword">new</span> <span class="title class_">printWriter</span>(<span class="string">"develop\\pw.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">pw.println(<span class="string">"hellow"</span>);</span><br><span class="line">pw.println(<span class="string">"world"</span>);</span><br><span class="line">pw.close();</span><br></pre></td></tr></tbody></table></figure>

<h6 id="复制java文件（用打印流）"><a href="#复制java文件（用打印流）" class="headerlink" title="复制java文件（用打印流）"></a>复制java文件（用打印流）</h6><ol>
<li>根据数据源创建字符缓冲输入流</li>
<li>根据目的地创建字符打印流</li>
<li>读写数据，复制文本（一次读一个字符，一次写一个字符）</li>
</ol>
<h3 id="对象序列化流"><a href="#对象序列化流" class="headerlink" title="对象序列化流"></a>对象序列化流</h3><p>对象序列化：就是将对象保存到磁盘中，或在网络中传输对象</p>
<p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型，对象的数据和对象中存储的属性等信息</p>
<ul>
<li>对象序列化流：ObjectOutputStream</li>
<li>对象反序列化流：ObjictInputStrream</li>
</ul>
<h5 id="对象序列化流：ObjectOutputStream"><a href="#对象序列化流：ObjectOutputStream" class="headerlink" title="对象序列化流：ObjectOutputStream"></a>对象序列化流：ObjectOutputStream</h5><ul>
<li>将Java对象的原始数据类型和图形写入OutputStream.可以通过使用流的文件来实现对象的长时间保存，若流是网络套接字流，则可以在另一个主机或另一个进程中重构对象</li>
<li>构造方法：OutputStream（OutputSream out)</li>
<li>序列化对象的方法：void writeObject(Object obj):将其写入OutputStream</li>
<li>一个对象要实现序列化，该对象所属的类必须实现Serializable接口，Serializable接口是一个标记接口，不用重写方法</li>
</ul>
<h5 id="对象反序列化流：ObjictInputStrream"><a href="#对象反序列化流：ObjictInputStrream" class="headerlink" title="对象反序列化流：ObjictInputStrream"></a>对象反序列化流：ObjictInputStrream</h5><ul>
<li>ObjictInputStrream反序列化先前使用的bjectOutputStream编写的原始数据和对象</li>
<li>构造方法：ObjictInputStrream（InputStrream in）</li>
<li>Objict readObject():从ObjictInputStrream中读取一个对象</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> throwsIOException,ClassNotFoundException{</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>()) ;</span><br><span class="line">    Object obj=ois.readObject();</span><br><span class="line">    student s= (student) obj;</span><br><span class="line">    System.out.println(s.getName()+<span class="string">","</span>+s.getAge())</span><br><span class="line">        ois.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>用对象序列化了一个对象后，修改了对象所属的类文件，若不加serialersionUID会报错</p>
<p>private static final long serialVersionUID=42L;</p>
<p>如果一个对象的某个成员变量不想被序列化，要给该成员加transient关键字修饰，该关键字标记的成员变量不参与序列化过程</p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><ul>
<li>是一个Map体系的集合类</li>
<li>Properties可以保存到流中或从流中加载</li>
<li>ProPerties prop = new Properties();默认使用Object</li>
</ul>
<table>
<thead>
<tr>
<th>Object setProperty(String key,String value)</th>
<th>设置集合的键和值，都是String类型的，底层调用Hashable方法 put</th>
</tr>
</thead>
<tbody><tr>
<td>String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性</td>
</tr>
<tr>
<td>Set<string> stringPropertyNames()</string></td>
<td>从属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</td>
</tr>
</tbody></table>
<p>ProPerties与Io流结合的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void load(InputStream inStream)</td>
<td>从输入字节流<strong>读取数据列表</strong>（键和元素对）</td>
</tr>
<tr>
<td>void load(Reader reader)</td>
<td>从输入字符流<strong>读取属性列表</strong>（键和元素对）</td>
</tr>
<tr>
<td>void store(OutputStream out,String comments)</td>
<td>将此属性列表（键和元素对）写入此ProPerties表中，以适合与使用load(InputStream)方法的格式<strong>写入输出字节流</strong></td>
</tr>
<tr>
<td>void store(Write write,String comments)</td>
<td>将此属性列表（键和元素对）写入此ProPerties表中，以适合与使用load(InputStream)方法的格式<strong>写入输出字符流</strong></td>
</tr>
</tbody></table>
<h6 id="游戏次数"><a href="#游戏次数" class="headerlink" title="游戏次数"></a>游戏次数</h6><p>需求：请写一个猜数字小游戏只能玩三次，若还想玩请充值</p>
<p>思路：</p>
<ol>
<li><p>写一个游戏类，里有一个猜数字小游戏</p>
</li>
<li><p>写一个测试类，测试类中有main()方法</p>
<p>A:从文件中读取到Properties集合，用load方法实现</p>
<p>​    文件已经存在：game.txt</p>
<p>​    里面有一个数据值：count=0;</p>
<p>B:通过Properties集合获取到玩游戏的次数</p>
<p>C：判断次数是否到达3次，</p>
<p>  到了给提示</p>
<p>  不到：</p>
<p>​       玩游戏，次数加1，重回写回文件，用Properties的store()方法实现</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"E:\\Java\\study\\basis\\练习\\developing\\src\\Gather\\game.txt"</span>);</span><br><span class="line">        prop.load(fr);</span><br><span class="line">        fr.close();</span><br><span class="line">        <span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> prop.getProperty(<span class="string">"count"</span>);</span><br><span class="line">        <span class="type">int</span> ww=Integer.parseInt(w);</span><br><span class="line">        <span class="keyword">if</span>(ww&gt;=<span class="number">3</span>){</span><br><span class="line">            System.out.println(<span class="string">"游戏次数不够请充值，(www.platgame)"</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            playgame.guess();</span><br><span class="line">            ww++;</span><br><span class="line">            FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">"E:\\Java\\study\\basis\\练习\\developing\\src\\Gather\\game.txt"</span>);</span><br><span class="line">            prop.setProperty(<span class="string">"count"</span>,String.valueOf(ww));</span><br><span class="line">            prop.store(fw,<span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>是正在运行的程序</p>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>是进程中的单个顺序控制流，是一条执行路径</p>
<ul>
<li>单线程：一个进程只有一条执行路径</li>
<li>多线程：一个进程有多条执行路径</li>
</ul>
<h4 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h4><p>方式1：继承Thread类</p>
<ul>
<li>定义一个类MyThread继承Thread类</li>
<li>在MyThread类中重写run()方法</li>
<li>创建MYThread类的对象</li>
<li>start()方法启动线程</li>
</ul>
<p>run()方法是u用来封装被执行线性程序的代码</p>
<p>run():封装线性执行程序，直接调用相当于普通方法调用</p>
<p>start():启动线程；由JVM调用此线程的run()方法</p>
<p>设置和获取线程名称的方法</p>
<ul>
<li>void setName(String name): 更改线程名称</li>
<li>String getName():得到线程名称</li>
<li>构造方法：在自定类中提供带参构造方法,super(name)</li>
</ul>
<p>获取main()方法的线程名称：</p>
<p>public static Thread currentThread()：返回对当前正在执行的线程对象的引用</p>
<p>再获取线程名称</p>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><ul>
<li>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用的CPU时间</li>
<li>抢占式调度模型：优先让优先级高的现线程使用CPU，若优先级相同，则随机选择，优先级高的CPU获取的CPU时间片相对长</li>
<li>java使用的是抢占式调度模型</li>
</ul>
<p>假设计算机只有一个CPU,那么CPU在某一个时刻只能执行一天指令。所以说多线程程序的执行具有随机性</p>
<p>Thread类中设置和获取线程优先级的方法：</p>
<ul>
<li><p>public final int getPriority():返回此线程的优先级</p>
</li>
<li><p>public final void setPriority(int newPriority):更改此线程的优先级</p>
<p>线程默认优先级是5；范围是1~10</p>
<p>线程优先级高只表示线程获取CPU的时间片几率高，但是要在次数比较多，或多次运行的时候才能看到你想要的结果</p>
</li>
</ul>
<h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><table>
<thead>
<tr>
<th>static void sleep(long millis)</th>
<th>使当前正在执行的线程停留（暂停执行）指定的毫秒数</th>
</tr>
</thead>
<tbody><tr>
<td>void join()</td>
<td>等待这个线程死亡</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程，当运行的线程都是守护线程是java虚拟机将退出，随主线程的退出而停止</td>
</tr>
</tbody></table>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720084108566.png" alt="image-20240720084108566"></p>
<p><strong>若有程序在主函数中先运行主函数最后运行run()线程</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"张飞"</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"关羽"</span>);</span><br><span class="line"><span class="comment">//        mt.start();</span></span><br><span class="line"><span class="comment">//        mn.start();</span></span><br><span class="line">        mt.setName(<span class="string">"野蛮"</span>);</span><br><span class="line">        mn.setName(<span class="string">"武圣"</span>);</span><br><span class="line">        mn.setPriority(<span class="number">9</span>);</span><br><span class="line">        mn.start();</span><br><span class="line">        mt.start();</span><br><span class="line">        System.out.println(mt.getPriority());</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="多线程的实现方式-1"><a href="#多线程的实现方式-1" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h4><p>方式2：实现Runnable接口</p>
<ol>
<li>定义一个类MyRunnable实现Runnable接口</li>
<li>在MyRunnable类中重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li>
<li>启动线程</li>
</ol>
<p>好处：</p>
<ul>
<li>避免了java单继承的局限性</li>
<li>适合多高相同的程序的代码区处理同一个资源的情况，把线程和程序的代码，数据有效分离，较好的体现离面向对象的设计思想</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MtRunnable my=<span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">"高铁"</span>)；<span class="comment">//构造方法：Runnable的实现子类和线程的名称</span></span><br><span class="line">Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">"飞机"</span>);</span><br><span class="line">t1,start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></tbody></table></figure>

<h6 id="卖票"><a href="#卖票" class="headerlink" title="卖票"></a>卖票</h6><p>有三个窗口卖票，共有100张票</p>
<ol>
<li><p>定义一个类SelllTicket实现Runnable接口，里面定义一个成员变量：private int tickets=100;</p>
</li>
<li><p>在SellTicket类中重写run()方法实现卖票，并告知是那个窗口卖的</p>
<p>A：判断票数打印0，就卖票，并告知那个窗口卖的，每次出票的时间为0.1秒</p>
<p>B：卖票之后，中票数减1</p>
<p>C：票没有了，也可能有人来问，故让卖票的动作一直执行</p>
</li>
<li><p>定义一个测试类SellTicktDemo,里面有main方法</p>
<p>A:创建SellTicket类的对象</p>
<p>B:创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</p>
<p>C:启动线程</p>
</li>
</ol>
<p>相同的票出现了多次：当t1线程抢到的CPU之后要休息0.1秒，之后t2线程重复</p>
<p>线程执行的随机性：当第一个语句执行完后，第2个语句可能会被别的线程抢占</p>
<p>多线程的数据安全问题：</p>
<ul>
<li>多线程环境</li>
<li>共享数据</li>
<li>多条语句操作共享数据</li>
</ul>
<p>解决安全问题：</p>
<p>让程序没有安全数据环境</p>
<p>把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行，java提供了同步代码块的方式来解决</p>
<p>格式：</p>
<ul>
<li>synchronized(任意对象){</li>
<li>多条语句操作共享数据的代码}</li>
<li>synchronized(任意对象)：就相当于给代码加上了锁，任意对象可以看成是一把锁</li>
</ul>
<p>好处：解决了多线程的数据安全问题</p>
<p>弊端：但线程衡多是，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</p>
<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>就是把synchronized加到方法上</p>
<ul>
<li>格式：</li>
<li>修饰符 synchronized 返回值类型 方法名（方法参数）{}</li>
<li>同步方法的锁对象是：  this</li>
</ul>
<p>同步静态方法：就是把synchronized关键字加到静态方法上</p>
<ul>
<li>格式：</li>
<li>修饰符 static synchronized 放回值类型 方法名（方法参数）{}</li>
<li>同步静态方法的锁对象是： 类名.class</li>
</ul>
<h4 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h4><p>StringBUffer:</p>
<p>Vector:</p>
<p>Hashtable:</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720102511486.png" alt="image-20240720102511486"></p>
<p>可以使用Collections.synchronizedList(List<t> list)返回指定列表支持的同步列表</t></p>
<p>List<string> list = Collections.synchronizedList(new Arraylist<string>());</string></string></p>
<p>将线程不安全类变成线程安全类</p>
<h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p>是接口，是一个锁对象</p>
<p>提供比使用synchronized方法和语句更广泛的锁定操作</p>
<ul>
<li>void lock():获得锁</li>
<li>void unlock():释放锁</li>
</ul>
<p>Lock是接口不能直接实例化，这里才用实现类ReentrantLock来实例化</p>
<ul>
<li>ReentantLock():创建一个ReentrantLock的实例</li>
</ul>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><h5 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h5><p>省常中消费者模式是一个十分经典的多线程协助的模式</p>
<p>有2个线程：</p>
<ul>
<li>一个是生产者线程用于生产数据</li>
<li>一列是消费者线程用于消费数据</li>
</ul>
<p>为解耦生产者和消费者的关系，通常会在用共享的数据区域</p>
<ul>
<li>生产者生产数据之后直接凡在共享数据区域中，并不关心消费者的行为</li>
<li>消费者中需要从共享数据区域中去获取数据，并不关心生产者的行为</li>
</ul>
<p>Object类的等待和唤醒方法</p>
<table>
<thead>
<tr>
<th>void wait()</th>
<th>倒着当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</th>
</tr>
</thead>
<tbody><tr>
<td>void noify()</td>
<td>唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td>voidnotifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody></table>
<h6 id="奶箱类生产者与消费者"><a href="#奶箱类生产者与消费者" class="headerlink" title="奶箱类生产者与消费者"></a>奶箱类生产者与消费者</h6><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720105851313.png" alt="image-20240720105851313"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><p>计算机网络：将不同的独立的多台计算机及其外部设备，通过通信路线连接起来，在饿忘了操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息换的的计算机系统</p>
<p>网路编程：在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以实现数据交换</p>
<h5 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h5><ol>
<li>IP地址：为网络中的计算机指定一个标识号，通过标识号来指定要接收的计算机和识别发送的计算机，IP就是这个标识号</li>
<li>端口：端口号就是唯一标识设备中的应用程序的，是应用程序的标识</li>
<li>协议：网络规定 UDP协议和TCP协议</li>
</ol>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720120016831.png" alt="image-20240720120016831"></p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IPv4：是给连接在网络的主机分配的一个32bit地址，为4个字节</p>
<p>IPv6:每16个字节为一组，分成8组16进制数，128为地址长度</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720142350657.png" alt="image-20240720142350657"></p>
<p>命令：</p>
<ul>
<li>ipconfig:查看本机IP地址</li>
<li>ping IP地址：检查网络是否联通</li>
</ul>
<p>特殊IP地址：</p>
<p>127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用</p>
<h4 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h4><p>InetAddress:此类表示Internet协议(IP)地址</p>
<table>
<thead>
<tr>
<th>static InetAddress grtByName(String host)</th>
<th>确定直接名称的IP地址，主机名称可以是机器名称，也可以是IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>String getHostName()</td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td>String getHostAddress()</td>
<td>返回文本显示中的IP地址字符串</td>
</tr>
</tbody></table>
<h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><p>端口：设备上应用程序的唯一标识</p>
<p>端口号：用两个字节表示的整数，它的取值范围是0<del>65535.起重工0</del>1023之间的端口号用于一些知名的网路服务和应用，若端口号被另一个服务或应用所占用，会导致当前程序启动失败</p>
<h5 id="协议："><a href="#协议：" class="headerlink" title="协议："></a>协议：</h5><p>UDP协议：消耗资源小，通信效率高，但不确定接收端是否存在</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720154915128.png" alt="image-20240720154915128"></p>
<p>TCP协议：建立连接在传输数据，保证了数据传输的安全</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720155111982.png" alt="image-20240720155111982"></p>
<h3 id="UPD通信原理"><a href="#UPD通信原理" class="headerlink" title="UPD通信原理"></a>UPD通信原理</h3><p>是一种不可靠的网络协议，它在两端建立一个Socket对象，Socket只是发送，每有客户端和服务器的概念</p>
<h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><ol>
<li><p>创建发送端的Socket对象(DatagramSocket)</p>
<p>DatagramSocket()</p>
</li>
<li><p>创建数据，并把数据打包</p>
<p>DatagramPacket(byte[] buf,int length,InetAddress address,int port)</p>
</li>
<li><p>调用DatagramSocket对象的方法发送数据</p>
<p>void send(DatagramPacket p)</p>
</li>
<li><p>关闭发送端</p>
<p>void close()</p>
</li>
</ol>
<h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><ol>
<li><p>创建接收端的Socket对象(DatagramSocket)</p>
<p>DatagramSocket(int port)</p>
</li>
<li><p>创建一个数据包，用于接收数据</p>
<p>DatagramPacket(byte[] buf,int length)</p>
</li>
<li><p>调用DatagramSocket对象的方法接收数据</p>
<p>void receive(DategramPacket p)</p>
</li>
<li><p>解下数据包，并包数据在控制台上显示</p>
<p>byte[] getDate()</p>
<p>int getLength()</p>
</li>
<li><p>关闭接收端</p>
<p>void.close()</p>
</li>
</ol>
<h4 id="TCP通信原理"><a href="#TCP通信原理" class="headerlink" title="TCP通信原理"></a>TCP通信原理</h4><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240720172738749.png" alt="image-20240720172738749"></p>
<p>步骤：</p>
<ol>
<li><p>创建客户端的Socket对象(Socket)</p>
<p>Socket(String host,int port)</p>
</li>
<li><p>获取输出流，写数据</p>
<p>OutputStream getOutputStream()</p>
</li>
<li><p>释放资源</p>
<p>void close()</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Socket s=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"192.168.2.93"</span>,<span class="number">30006</span>)</span><br><span class="line">    </span><br><span class="line">    OutputStream os=s.getOutputStream();</span><br><span class="line">os.write(<span class="string">"hellow,wrold,"</span>.getBytes())</span><br><span class="line">    s.close();</span><br></pre></td></tr></tbody></table></figure>

<p>要进行三次握手</p>
<p>TCP接收数据</p>
<ol>
<li>创建服务器端的Socket对象(ServerSocket)</li>
<li>获取输入流，读数据，并把数据显示在控制台</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss= newServerSocket;</span><br><span class="line">Socket s=ss.accept();</span><br><span class="line">InputStream is==s.getInputStream();</span><br><span class="line">btte[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len=ia.read(bys);</span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> newString(bts,<span class="number">0</span>,len);</span><br><span class="line">System.out.println(<span class="string">"数据是："</span>+data);</span><br><span class="line">s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></tbody></table></figure>

<p>客户端：发送数据，接收服务器反馈，数据来自着键盘录入，知道输入的数据是886，发送数据接收</p>
<p>服务器：接收到的数据在控制台输出，并写进文本文档</p>
<p>客户端：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"192.168.2.93"</span>,<span class="number">30002</span>)</span><br><span class="line"><span class="type">BuuferReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine()！=<span class="literal">null</span>){</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"886"</span>.equals(line)){</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWreite</span>(<span class="keyword">new</span> <span class="title class_">OutputStream</span>(s.getOutputStream()));</span><br><span class="line">    bw.write(line);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.flush();</span><br><span class="line">    s.close();</span><br><span class="line">    bw.close();</span><br><span class="line">    bw.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>服务器：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SreverSocket ss=<span class="keyword">new</span> <span class="title class_">SeverSocket</span>(<span class="number">30002</span>);</span><br><span class="line">Socket s=ss.accept();</span><br><span class="line">BufferdReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(New <span class="title function_">inputStreamReader</span><span class="params">(s.getInputStream()</span>));</span><br><span class="line">BufferedWrite bw=<span class="keyword">new</span> <span class="title class_">BufferedWrite</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">""</span>))\\路径</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = br.readline())!=<span class="literal">null</span>){</span><br><span class="line">    System.out.println(line);</span><br><span class="line">    bw.write(line);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.flush();</span><br><span class="line">}</span><br><span class="line">BufferedWrite bwSeret=<span class="keyword">new</span> <span class="title class_">BufferdWrite</span></span><br><span class="line">ss.close();</span><br><span class="line">bw.close();</span><br></pre></td></tr></tbody></table></figure>

<h6 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a>练习5</h6><p>客户端：数据来着文本，接受服务器反馈</p>
<p>服务器：接收到的数据写入文本，给出反馈</p>
<p>出现问题：程序一直等待</p>
<p>原因：读数据的方法是阻塞式的</p>
<p>解决：自定义结束标志；使用shutdownOutput()方法</p>
<p>结束标记：shutdownOutput()</p>
<h6 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a>练习6</h6><p>多个线程的输入输出</p>
<p>服务器多线程：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss= <span class="keyword">new</span> <span class="title class_">SreverSocket</span>(<span class="number">30002</span>);</span><br><span class="line">Socket s=ss.accept();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ServerThread</span>(s)).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h4 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h4><p>做什么</p>
<p>Lambda表达式的标准格式</p>
<p>格式：（形参）-&gt;{代码块}</p>
<ul>
<li>形参：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</li>
<li>-&gt;:有英文中的画像和大于符号组成，固定写法，代表指向动作</li>
<li>代码块：之前的方法体</li>
</ul>
<p>使用前提：</p>
<p>有一个接口，且接口只有一个抽象方法</p>
<h6 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h6><p>定义一个接口，且只有一个抽象方法，在主方法中使用方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useFilable</span><span class="params">(Filable f)</span>{</span><br><span class="line">    f.fly(<span class="string">"风车"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">useFlyable((String s)-&gt;{</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(<span class="string">"飞机"</span>);</span><br><span class="line">})}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="省略模式"><a href="#省略模式" class="headerlink" title="省略模式"></a>省略模式</h5><p>参数的类型可以省略，但是有多个参数是要一致</p>
<p>参数有一个，小括号也能省略，</p>
<p>代码块只有一条可以省略大括号和分号，如果有return，return也要省略</p>
<p>useFlyable(s-&gt;System.out.println(s));</p>
<p>useFlyable((x,y)-&gt;x+y);</p>
<p>注意事项</p>
<p>接口中只有一个方法</p>
<p>有上下文环境，1在主函数中有相应的方法，2局部赋值，调用方法的参数</p>
<h5 id="匿名内部类和Lambda表达式的区别"><a href="#匿名内部类和Lambda表达式的区别" class="headerlink" title="匿名内部类和Lambda表达式的区别"></a>匿名内部类和Lambda表达式的区别</h5><p>所需类型不同：</p>
<ul>
<li><p>Lambda表达式必须是接口</p>
</li>
<li><p>匿名内部类：可也是接口，抽象类，具体类，可以多个方法</p>
</li>
</ul>
<p>实现原理不同：</p>
<ul>
<li>匿名内部类：编译之后，会产生一个单独的.class字节码文件</li>
<li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码文件会在运行的时候动态生成</li>
</ul>
<h4 id="接口的组成更新"><a href="#接口的组成更新" class="headerlink" title="接口的组成更新"></a>接口的组成更新</h4><p>接口的组成：</p>
<ul>
<li>常量</li>
<li>抽象方法</li>
<li>默认方法</li>
<li>静态方法</li>
<li>私有方法</li>
</ul>
<p>接口中不再只有抽象方法，默认方法等可以有方法体</p>
<h5 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h5><ul>
<li><p>格式：public default 返回值类型 方法名（参数列表）{}</p>
</li>
<li><p>puublic default void show(){}</p>
</li>
<li><p>可以直接调动方法</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>默认方法不是抽象方法，不强制被重写，办事可以被重写，重写的时候去掉default</li>
<li>public可以省略，default不能省略</li>
</ul>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><ul>
<li>public static void  show(){}</li>
<li>只能被接口调用，不能被实现类调用</li>
</ul>
<h5 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h5><p>private 返回值类型 方法名(参数列表){}</p>
<p>private void show(){}</p>
<p>private static void method(){}</p>
<p>在静态方法中只能调用静态方法</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用符 ：：</p>
<ul>
<li><p>Lambda表达式：usePrintable(s-&gt;System.out.println(s));</p>
<p>参数通过Lambda表达式，传递给System.out.println方法去处理</p>
</li>
<li><p>方法引用：usePrintable(System.out::println);</p>
<p>风险：直接使用System.out中的pringln方法来取代Lambda,代码更简洁</p>
</li>
<li><p>若使用Lambda，根据“可推导就是可省略”的原则，无需指定参数类型</p>
</li>
<li><p>若是方法引用同样可以根据上下文推导</p>
</li>
<li><p>方法引用是Lambda的孪生兄弟</p>
</li>
</ul>
<h5 id="Lambda表达式支持的方法引用"><a href="#Lambda表达式支持的方法引用" class="headerlink" title="Lambda表达式支持的方法引用"></a>Lambda表达式支持的方法引用</h5><p>引用类方法：引用类的静态方法</p>
<ul>
<li>格式：类名：：静态方法</li>
<li>Integer::parselent</li>
<li>Integer类的方法：pubilc static int parselent(String s)将String转换为int类型数据</li>
<li>Lambda表达式被类方法替代的时候，它的形参全部传递给静态方法作为参数</li>
</ul>
<h6 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h6><ol>
<li><p>定义一个接口（Coinverter,里面定义一个抽象方法</p>
</li>
<li><p>定义一个测试类（ConverterDemo）在测试类中提供两个方法</p>
<p>useConverterDemo(Converter c)</p>
<p>主方法</p>
</li>
</ol>
<h5 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h5><p>:就是引用类中的成员方法</p>
<ul>
<li><p>格式：对象：：成员方法</p>
</li>
<li><p>“HellowWorld”::toUpperCase</p>
<p>String类中的方将此String索引字符转化为大写</p>
</li>
</ul>
<p>Lambda表达式被对象的实例方法替代的时候，它的形参全部传递到该方法作为参数</p>
<h5 id="引用类的实例方法"><a href="#引用类的实例方法" class="headerlink" title="引用类的实例方法"></a>引用类的实例方法</h5><p>：就是引用类的成员方法</p>
<ul>
<li><p>格式：类名：：成员方法</p>
</li>
<li><p>String::substring</p>
</li>
<li><p>String中的方法：从beginIndex到endIndex结束，截取字符串。返回一个子串</p>
</li>
<li><p>Lambda表到时被类的实例方法代替的时候</p>
<p>第一个参数作为调用者，后面的参数全部传递给该方法作为参数</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>{</span><br><span class="line">    useMyString(String::substring);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useMyString</span><span class="params">(MyString my)</span>{</span><br><span class="line">    String s=my.myString(<span class="string">"Hellowrld"</span>,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h5><p>就是引用构造方法</p>
<ul>
<li><p>格式：类名::new</p>
</li>
<li><p>Student::new</p>
</li>
</ul>
<p>Lambda表达式被构造器代替的时候，它的全部形参传递给构造器作为参数</p>
<p>练习：</p>
<ul>
<li><p>定义一个类（Student），里面有两个成员变量（name，age）</p>
<p>并提供无参构造方法和带参构造方法</p>
</li>
<li><p>定义一个接口（StudentBuilder），里面定义一个抽象方法</p>
<p>Student build(String name,int age);</p>
</li>
<li><p>定义一个测试类（StudentDemo）,在测试类中提供两个方法</p>
<p>一个方法是：useStudentBuilder(StudentBuilder s)</p>
<p>一个方法是猪方法，在猪方法中调用useStudentBuilder方法</p>
</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口：尤其只有一个抽象方法的接口</p>
<p>java中的函数式编程体现就是Lambda表达式，函数式接口就是可以适用于Lambda表达式的接口</p>
<p>只有确保接口中只有一个抽象方法，java中的Lambda才能推导</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyInterface my=()-&gt;Systerm.out.println(<span class="string">"函数式接口"</span>)；</span><br></pre></td></tr></tbody></table></figure>

<p>函数式注解：@FunctionalInterface放在接口上方，通过就是</p>
<h5 id="函数式接口作为方法的参数"><a href="#函数式接口作为方法的参数" class="headerlink" title="函数式接口作为方法的参数"></a>函数式接口作为方法的参数</h5><p>如果方法的参数是一个函数式接口，我们可以使用Lambda表达式作为参数传递</p>
<ul>
<li>startThread(()-&gt;System.out.println(Thread.currentThread().getName()+”线程启动了”))；</li>
</ul>
<p>函数式接口作为方法的返回值</p>
<p>方法的返回值是函数式接口</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;Student&gt; <span class="title function_">getComparator</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> (s1,s2)-&gt;s1.getSid().compareTo(s2.getSid());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>自定义比较器</p>
<p>常用的函数式接口</p>
<ul>
<li>Supplier接口</li>
<li>Consumer接口</li>
<li>Predicate接口</li>
</ul>
<h5 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h5><p>Supplier<t>:包含一个无参的方法</t></p>
<ul>
<li>T get():获得结果</li>
<li>不需要参数，他会按照某种路基范湖一个数据</li>
<li>Supplier<t>接口也被称为生产型接口，指定接口的泛型是什么类型，接口get方法就会生产什么类型数据</t></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span>{</span><br><span class="line"><span class="keyword">return</span> suo.get();}</span><br><span class="line">String s=getString(()-&gt;<span class="string">"林青霞"</span>)；</span><br></pre></td></tr></tbody></table></figure>

<p>定义一个类提供两个方法</p>
<p>一个用于返回int数据的最大值</p>
<p>一个是主方法interest</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line"><span class="type">int</span>[] ar={<span class="number">12</span>,<span class="number">34</span>,<span class="number">5453</span>,<span class="number">2</span>};</span><br><span class="line">    <span class="type">int</span> maxValue=getMax(()-&gt;{</span><br><span class="line">        <span class="type">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ar.length;i++){</span><br><span class="line">                <span class="keyword">if</span>(ar[i]&lt;ma){</span><br><span class="line">                    ma=ar[i] ;} }<span class="keyword">return</span> ma;  });</span><br><span class="line">    System.out.println(max);}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; r)</span>{</span><br><span class="line">        <span class="keyword">return</span> r.get(); }</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h5><ul>
<li>void accept(T t):对给定的参数执行此操作</li>
<li>default Consumer<t> andThen(Consumer after):返回一个组合的Consumer，依次执行此操作，然后执行after操作</t></li>
<li>Consumer<t>接口也被称为消费型接口，他消费的数据好数据类型由泛型指定</t></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">    operatorString(<span class="string">"林青霞"</span>，s-&gt;System.out.println(s));</span><br><span class="line">    operatorString(<span class="string">"林青霞"</span>，s-&gt;System.out.println(s),s-&gt;System.out.println(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name,Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span>{</span><br><span class="line">    con1.andThen(con2).accept(name);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name,Consumer&lt;String&gt; con)</span>{</span><br><span class="line">    con.accept(name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>把字符串按指定的方式打印</p>
<h5 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h5><ul>
<li>boolean test(T t):对给定的参数进行判断（判断逻辑由Lambda表达式实现）返回一个布尔值</li>
<li>default Predicate<t> negate():返回一个逻辑的否定，对应逻辑非</t></li>
<li>default Predicate<t> and(Predicate other):返回一个组合判断，对应短路与</t></li>
<li>default Predicate<t> or(Predicate other):返回一个组合判断，对应短路或</t></li>
<li>Predicate<t>接口通常用于判断该参数是否满足条件</t></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> b1=checkString(<span class="string">"hellow"</span>,s-&gt;s.length()&gt;<span class="number">8</span>);</span><br><span class="line"><span class="type">boolean</span> b2=checkString(<span class="string">"hellowworld"</span>,s-&gt;length()&gt;<span class="number">8</span>,s-&gt;length()&lt;<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkString</span><span class="params">(String s,Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)</span>{</span><br><span class="line">    <span class="keyword">return</span> pre1.or(pre2).test(s);</span><br><span class="line">    <span class="comment">//return pre1.and(pre2).test;</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkString</span> <span class="params">(String Predicate&lt;String&gt;)</span>{</span><br><span class="line">    <span class="keyword">return</span> pre.negate().test(s);</span><br><span class="line">}</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure>

<h5 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h5><ul>
<li>R apply(T t):将此函数应用于给定的参数</li>
<li>default<v> Function andThen(Function after):返回一个组合函数，首先将函数应用于输入，然后将after函数应用于结果</v></li>
<li>Function&lt;T，R&gt;：接口通常用于对参数进行处理，转换（处理逻辑由Lamnda表达式实现），返回一个新的值</li>
</ul>
<p>要求：将字符串截取得到数字年龄部分，将年龄转成int类型的数据，将int类型的加70输出</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">"林青霞，30"</span>；</span><br><span class="line">    convert(s,ss-&gt;split(<span class="string">","</span>)[<span class="number">1</span>],ss-&gt;Integer.parseInt(ss),i-&gt;i+<span class="number">70</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s,Function&lt;String,String&gt; fun1,Functon&lt;String,Integer&gt; fun2,Function&lt;Integer,Integer&gt; fun3)</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fun1.andThen(fun2).andThen(fun3).apply(s);</span><br><span class="line">System.out.println(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>生成方式</p>
<ul>
<li><p>生成流：</p>
<p>通过数据源（集合等）生成流</p>
<p>list.stream()</p>
</li>
<li><p>中间操作</p>
<p>多个操作</p>
<p>filter()</p>
</li>
<li><p>终结操作</p>
<p>一个流只有一个终结操作</p>
<p>forEach()</p>
</li>
</ul>
<h5 id="常见的生成方式："><a href="#常见的生成方式：" class="headerlink" title="常见的生成方式："></a>常见的生成方式：</h5><ul>
<li><p>Collection体现的结合可以使用默认方法stream()生成流</p>
<p>default Stream<e> stream()</e></p>
</li>
<li><p>Map体现的集合间的生成流</p>
</li>
<li><p>数据可以通过流</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Stream&lt;String&gt; liststream = list.stream();<span class="comment">//Collection集合的默认方法Set HashSet也有默认方法</span></span><br><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">Stream&lt;String&gt; ketStream=map.KeySet().stream();</span><br><span class="line">Stream&lt;Integer&gt; valueStream=map.values().stream();</span><br><span class="line">Stream&lt;Map&lt;String,Integer&gt;&gt; entryStream = map.entrySet().stream();<span class="comment">//Map集合间接生成流</span></span><br><span class="line">Stream&lt;String&gt; strArrayStream = Stream.of(<span class="string">"hellow"</span>,<span class="string">"world"</span></span><br><span class="line">,<span class="string">"java"</span>);</span><br><span class="line">Stream&lt;Integer&gt; intStream=Stream.of(<span class="number">10</span>,<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h5><ul>
<li><p>Stream<t> <strong>filter(predicate predicate):</strong></t></p>
<p>Predicate接口中的方法boolean test(T,t);</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"林青霞"</span>)；</span><br><span class="line">list.stream().filter(s-&gt;s.startsWith(<span class="string">"张"</span>)).filter(s-&gt;s.lengtrh()==<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//1判断过滤</span></span><br><span class="line">list.stream().skip(<span class="number">2</span>).limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//2,3取前几个数据；跳过几个数据</span></span><br><span class="line">Stream&lt;String&gt; s1=list.stream().limit(<span class="number">4</span>);</span><br><span class="line">Stream&lt;String&gt; s2=list.stream().skip(<span class="number">2</span>);</span><br><span class="line">Stream.concat(s1,s2).distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,4.合并a和b流为一个流</span></span><br><span class="line"><span class="comment">//返回由流的不同元素(根据Object.equals(Object))组成的流,用的是equals方法</span></span><br><span class="line">list.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//返回由此流的元素组成的流，根据自然顺序排序</span></span><br><span class="line">list.stream().sorted((s1,s2)-&gt;{</span><br><span class="line">    <span class="type">int</span> num=s1.length()-s2.length();</span><br><span class="line">    <span class="type">int</span> num2=num==<span class="number">0</span>?s1.comparaTo(s2):num;</span><br><span class="line"><span class="keyword">return</span> num2;}).forEach(System.out::println);</span><br><span class="line"><span class="comment">//排序5,6返回由Comparator的排序之后的流</span></span><br><span class="line">list.stream().map(s-&gt;Integer::parseInt).forEach(System.out::println);</span><br><span class="line">list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);</span><br><span class="line"><span class="type">int</span> result= list.stream().mapToInt(Integer::parseInt).sum();</span><br><span class="line"><span class="comment">//有独属于IntStream的方法，sum求和</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>Stream<t> <strong>limit</strong>(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据，<strong>取前几个数据</strong>；</t></p>
</li>
<li><p>Stream<t> <strong>skip</strong>(long n):跳过指定参数个数的数据，返回由该留的剩余元素组成的流，<strong>跳过几个数据</strong></t></p>
</li>
<li><p>static<t> Streram<t> <strong>concat</strong>(Stream a,Stream b):<strong>合并</strong>a和b流为一个流</t></t></p>
</li>
<li><p>Stream<t> <strong>distinct</strong>():<strong>返回由流的不同元素</strong>(根据Object.equals(Object))组成的流,用的是equals方法</t></p>
</li>
<li><p>Stream<t> <strong>sorted</strong>():返回由此流的元素组成的流，根据自然顺序排序</t></p>
</li>
<li><p>Stream<t> <strong>sorted(Comparator comparator)</strong>:返回由Comparator的排序之后的流</t></p>
</li>
<li><p><r>Stream<r> map(unction mapper):返回由给定<strong>函数应用于此流的元素的结果的流</strong></r></r></p>
<p>Function 接口中的方法     Rapply(T t)</p>
</li>
<li><p>IntStream mapToInt(TIntFunction mapper):返回一个<strong>IntSream</strong>其中包含给定函数应用于此流的元素的结果</p>
<p>IntStream:表示原始int流</p>
<p>ToIntFunction接口中的方法     int applyAslnt(T value)</p>
</li>
</ul>
<h5 id="常见终结方法"><a href="#常见终结方法" class="headerlink" title="常见终结方法"></a>常见终结方法</h5><ul>
<li><p>void forEach(Consumer action):对此流的每一个元素执行操作</p>
<p>Consumer接口中的方法    void accept(T t):对参数执行此操作</p>
</li>
<li><p>long count():返回此流中的元素数</p>
</li>
</ul>
<p>练习</p>
<ol>
<li>有两个集合分别存储6名男演员和6名女演员，</li>
<li>男演员要名字为3个字段前三人</li>
<li>女演员只要姓林的，并且不要第一个</li>
<li>把过滤值后的男演员和女演员合并到一起</li>
<li>再创建一个集合，存储上面的对象，并遍历数据</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.concat(manList.stream().filter(s-.s.length()==<span class="number">3</span>).limit(<span class="number">3</span>),womanList.stream.filter(s-&gt;s.startsWith(<span class="string">"林"</span>)).skip(<span class="number">1</span>)).map(Actor::<span class="keyword">new</span>).forEach(p-&gt;System.out.println(p.getName()));</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Stream流的收集操作"><a href="#Stream流的收集操作" class="headerlink" title="Stream流的收集操作"></a>Stream流的收集操作</h5><p>Stream流的收集方法</p>
<ul>
<li>R collect(Collector collector)</li>
<li>这个收集参数是一个Collector接口</li>
</ul>
<p>工具类Collectors提供了具体的收集方式</p>
<ul>
<li>public static<t> Collector toKist():把元素收集到List集合中</t></li>
<li>public static<t> Collector toSet():把元素收集到Set集合中</t></li>
<li>public static Collector toMap(Functon keyMapper,Function valueMapper):把元素收集到Map集合中</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; listStream = list.stream().filter(s-&gt;s.length()==<span class="number">3</span>);</span><br><span class="line">List&lt;String&gt;names=listStream.collect(Collectors.toList());</span><br><span class="line">Stream&lt;Integer&gt; setStream= set.stream().filter(age-&gt;age&gt;<span class="number">25</span>);</span><br><span class="line">Set&lt;Integer&gt; ages=setStream.collect(Collection.toSet());</span><br><span class="line">arrayStream.collect(Collectros.toMpa(s-&gt;s.split(<span class="string">","</span>)[<span class="number">0</span>],s-&gt;Integer.parseInt(s.split(<span class="string">","</span>)[<span class="number">1</span>])));</span><br><span class="line"><span class="comment">//对键和值进行操作</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>当程序要使用蘑菇类是，若类还未加载到内存中，则系统会通过类的加载，类的连接， 类的初始化这三个步骤来对类进行初始化，</p>
<h5 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h5><ul>
<li>就是将类class文件读入内存中国，并为之建立一个java.lang.Class对象</li>
<li>任何类被使用时，系统都会为其奖励一个java.lang.Class对象</li>
</ul>
<h5 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h5><ul>
<li>验证阶段：用于检验被加载的类是否有正确的内部结构，并与其他类协调一致</li>
<li>………</li>
</ul>
<h5 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h5><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240723161132873.png" alt="image-20240723161132873"></p>
<p>初始化步骤：</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240723163136574.png" alt="image-20240723163136574"></p>
<h5 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h5><p>全盘机制：就是当类的加载器负责加载加载某个Class是，该Class所依赖的和引用的其他的Class也将由该加载器负责，除非显示使用另一个加载器</p>
<p>父类委托：先让父类的加载器尝试加载该类，父类加载器无法加载该类才从自己的类路径中加载该类</p>
<p>缓存机制：保证所有加载过的Class都会被缓存，当程序血药摸个Class对象时先从缓存中搜索，没有在读取转换成Class对象，并存储到缓存区</p>
<p>ClassLoader:是负责加载类的对象</p>
<p>java运行时具有以下的内置加载器</p>
<ul>
<li>Bootstrap class loader:他是虚拟机的内置类加载器，通常表示null,并且没有复null</li>
<li>Platform class loader:平台类加载器可以看到所有平台类包括平台类加载器和其祖先定义的javaSE平台API，其实现类和JDK特定的运行时的类</li>
<li>System class loader:它也被称为应用程序加载类，与平台类加载器不同，系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类</li>
<li>类加载器的继承关系：System的父加载器为Platform,而Platform的父加载器为Bootstrap</li>
</ul>
<p>ClassLoader中的方法</p>
<p>static ClassLonder getSystemClassLoader():返回用于委派的系统类加载器</p>
<p>ClassLoader getParent()：返回父类加载器进行委派</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>java反射机制：是值在运行时获取一个类的变量和方法信息，然后通过获取到的信息来创建对象，调用方法的机制。</p>
<p>成员变量：Field[] field</p>
<p>构造方法：Constructor[] cons</p>
<p>成员方法 Menthod[] menthods</p>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240724114236724.png" alt="image-20240724114236724"></p>
<h5 id="获取Class类的对象"><a href="#获取Class类的对象" class="headerlink" title="获取Class类的对象"></a>获取Class类的对象</h5><p>要想通过反射去使用一个类，首先要获取Class文件</p>
<p>获取Class文件的方法</p>
<ul>
<li>是有类的Class属性来获取Class对象。Student.class将会返回Student对应的Class对象</li>
<li>调用对象的getClass方法返回对象的Class对象</li>
<li>使用Class类中的静态方法forName(String className),该方法需要传入字符串参数，字符串参数的值是某个类的全路径，也就是完整包名的路径</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; c=Student.class;</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Student</span>&gt; c3=s.getClass();</span><br><span class="line">Class&lt;?&gt; c4=Class.forName(<span class="string">"包名.类名"</span>)<span class="comment">//完整包名的路径</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="反射获取构造方法并使用"><a href="#反射获取构造方法并使用" class="headerlink" title="反射获取构造方法并使用"></a>反射获取构造方法并使用</h5><p>Class类中用于获取构造方法的方法</p>
<ul>
<li>Constructor&lt;?&gt;[] getConstructors():返回所有公共构造方法对象的数组</li>
<li>Constructor&lt;?&gt;[] getDeclaredConstructors():返回所有构造方法对象的数组</li>
<li>Constructor&lt;?&gt; getConstructor():返回单个公共构造方法对象</li>
<li>Constructor&lt;?&gt; getDeclaredConstructor():返回单个构造方法对象</li>
</ul>
<p>Constructor类中用于创建对象的方法</p>
<ul>
<li>T newInstance(Object…initargs):根据指定的构造方法创建对象</li>
</ul>
<h6 id="通过反射实现："><a href="#通过反射实现：" class="headerlink" title="通过反射实现："></a>通过反射实现：</h6><p>Student s =new Student(“林青霞”，33，“西安”)；</p>
<p>System.out.priontln(s);</p>
<p>基本数据也可获得Class类型</p>
<p>con.setAccessible(true);解除访问权限</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c=Class.forName(<span class="string">""</span>);</span><br><span class="line">Constructor&lt;?&gt; con = c.getVonstructor(String.class,<span class="type">int</span>.class,String.class);</span><br><span class="line">Object obj=con.newInstance(<span class="string">"林青霞"</span>，<span class="number">30</span>,<span class="string">"西安"</span>);</span><br><span class="line">Constructor&lt;?&gt; cin= c.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//获取私有方法</span></span><br><span class="line"><span class="comment">//暴力反射使用私有方法</span></span><br><span class="line">con.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object obj=con.newInstance(<span class="string">"林青霞"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="反射获取成员变量并使用"><a href="#反射获取成员变量并使用" class="headerlink" title="反射获取成员变量并使用"></a>反射获取成员变量并使用</h5><ul>
<li><p>Field[] getFields()返回包含Field对象的数组，反映所有可访问的对象</p>
</li>
<li><p>Field[] getDetlareFields()返回所有的对象</p>
<p>例子：field[] s=c.getFields();</p>
</li>
<li><p>Field getField (String name):返回一个公共对象</p>
</li>
<li><p>Field getDetlareField(String name):返回对象</p>
</li>
<li><p>void set(Object obj,Object value)：给obj成员变量赋值</p>
<p>addressField.set(obj,”西安”)；</p>
</li>
</ul>
<h5 id="反射获取方法并使用"><a href="#反射获取方法并使用" class="headerlink" title="反射获取方法并使用"></a>反射获取方法并使用</h5><ul>
<li><p>Method[] getMethods():返回一个包含方法的数组，公共的,包括继承的</p>
</li>
<li><p>Method[] getDeclaredMethods():返回所有方法，不包括继承的</p>
</li>
<li><p>Method[] methods = c.getMethods();</p>
</li>
<li><p>Method getMethod(String name,Class&lt;?&gt;… parameterTypes):返回一个方法对象，公共的</p>
</li>
<li><p>Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes):返回一个方法对象</p>
<p>Method m=con.getMethod(“method”);</p>
</li>
<li><p>Object invoke(Object obj,Object…args):调用此方法</p>
<p>Object:表示返回值类型</p>
<p>obj:调用方法的对象</p>
<p>args:方法需要的参数</p>
<p>m.invoke(obj);</p>
</li>
</ul>
<p>通过反射实现</p>
<p>Student s= new Student();</p>
<p>s.method1();</p>
<p>s.method2(“林青霞”);</p>
<p>String ss=s.method3(“林青霞”，30)；</p>
<p>System.out.println(ss);</p>
<p>s.function();</p>
<p>通过配置文件运行文件类中的方法</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>把java分为N个模块</p>
<h4 id="模块的基本使用"><a href="#模块的基本使用" class="headerlink" title="模块的基本使用"></a>模块的基本使用</h4><ul>
<li>创建模块</li>
</ul>
<h4 id="模块服务"><a href="#模块服务" class="headerlink" title="模块服务"></a>模块服务</h4><p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240723213717957.png" alt="image-20240723213717957"></p>
<ul>
<li><p>在myOne模块下创建一个包com.ithema_03,在包下提供一个接口，在接口中定义一个抽象方法</p>
<p>public interface MyService{</p>
<p>void service();}</p>
</li>
<li><p>在com.ithema_03包下创建一个包impl,在改包下提供接口的两个实现类Itheima和Czxy</p>
</li>
</ul>
<p><img src="C:\Users\xiaoxin\AppData\Roaming\Typora\typora-user-images\image-20240723214525789.png" alt="image-20240723214525789"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/13/java%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">http://example.com/2024/09/13/java%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">study的记录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/17/javaweb%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="javaweb的基础知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">javaweb的基础知识</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/13/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BAIDEA%E8%BF%90%E8%A1%8CJunit%E6%88%96%E8%80%85%E8%BF%90%E8%A1%8Cmain%E6%96%B9%E6%B3%95%E6%97%B6%E5%80%99%E4%BC%9A%E9%BB%98%E8%AE%A4%E5%85%88%E7%BC%96%E8%AF%91%E6%95%B4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E3%80%82"><span class="toc-number">1.</span> <span class="toc-text">这是因为IDEA运行Junit或者运行main方法时候会默认先编译整个项目。</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%B3%A8%E9%87%8A%EF%BC%9A"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">1注释：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">标识符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.0.0.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.0.0.2.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.0.0.3.</span> <span class="toc-text">自增自减运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.0.0.4.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.0.0.5.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.0.0.6.</span> <span class="toc-text">短路运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.0.0.7.</span> <span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E5%8F%AA%E8%80%81%E8%99%8E"><span class="toc-number">1.1.0.0.8.</span> <span class="toc-text">两只老虎</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%92%8C%E5%B0%9A"><span class="toc-number">1.1.0.0.9.</span> <span class="toc-text">三个和尚</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5Scanner"><span class="toc-number">1.2.</span> <span class="toc-text">数据输入Scanner:</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%92%8C%E5%B0%9A-1"><span class="toc-number">1.2.0.0.1.</span> <span class="toc-text">三个和尚</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.</span> <span class="toc-text">分支语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.2.</span> <span class="toc-text">if语句</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%A5%87%E5%81%B6%E6%95%B0"><span class="toc-number">2.1.2.0.1.</span> <span class="toc-text">判断是奇偶数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E5%A5%96%E5%8A%B1"><span class="toc-number">2.1.2.0.2.</span> <span class="toc-text">考试奖励</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%EF%BC%9A%E6%AD%A3%E7%A1%AE%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BE%B9%E7%95%8C%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%94%99%E8%AF%AF%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.2.0.3.</span> <span class="toc-text">数据测试：正确数据，边界数据，错误数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.3.</span> <span class="toc-text">switch语句</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%98%A5%E5%A4%8F%E7%A7%8B%E5%86%AC"><span class="toc-number">2.1.3.0.1.</span> <span class="toc-text">春夏秋冬</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.</span> <span class="toc-text">循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">for循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.1.0.1.</span> <span class="toc-text">输出数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B1%82%E5%92%8C-sum%EF%BC%9B"><span class="toc-number">2.2.1.0.2.</span> <span class="toc-text">求和 sum；</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B1%82%E5%81%B6%E6%95%B0%E5%92%8C"><span class="toc-number">2.2.1.0.3.</span> <span class="toc-text">求偶数和</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0%E4%B8%89%E4%BD%8D%E6%95%B0%EF%BC%88%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0%E7%9A%84%E4%B8%AA%E4%BD%8D%E5%8D%81%E4%BD%8D%E7%99%BE%E4%BD%8D%E7%9A%84%E7%AB%8B%E6%96%B9%E5%92%8C%E7%AD%89%E4%BA%8E%E5%8E%9F%E6%95%B0%E5%AD%97%EF%BC%89"><span class="toc-number">2.2.1.0.4.</span> <span class="toc-text">输出水仙花数三位数（水仙花数的个位十位百位的立方和等于原数字）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0%E8%BE%93%E5%87%BA%E5%85%B6%E6%95%B0%E9%87%8F"><span class="toc-number">2.2.1.0.5.</span> <span class="toc-text">统计水仙花数输出其数量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">while循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8F%A0%E7%A9%86%E6%9C%97%E7%8E%9B%E5%B3%B08844-43%E7%B1%B3%E7%94%A8%E4%B8%80%E5%BC%A0%E5%8E%9A%E5%BA%A6%E4%B8%BA0-1%E6%AF%AB%E7%B1%B3%E3%80%82%E9%97%AE%E6%8A%98%E5%8F%A0%E5%87%A0%E6%AC%A1%E5%8F%AF%E6%8A%98%E6%88%90%E7%8F%A0%E5%B3%B0%E9%AB%98%E5%BA%A6"><span class="toc-number">2.2.2.1.1.</span> <span class="toc-text">珠穆朗玛峰8844.43米用一张厚度为0.1毫米。问折叠几次可折成珠峰高度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-while%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.3.</span> <span class="toc-text">do while语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.4.</span> <span class="toc-text">跳转控制语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97"><span class="toc-number">2.2.5.</span> <span class="toc-text">循环嵌套</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%B8%80%E5%A4%A9%E7%9A%84%E5%B0%8F%E6%97%B6%E5%92%8C%E5%88%86%E9%92%9F"><span class="toc-number">2.2.5.0.1.</span> <span class="toc-text">输出一天的小时和分钟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random"><span class="toc-number">2.3.</span> <span class="toc-text">Random</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8C%9C%E6%95%B0%E5%AD%97"><span class="toc-number">2.3.0.0.1.</span> <span class="toc-text">猜数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#idea"><span class="toc-number">3.</span> <span class="toc-text">idea</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.0.1.</span> <span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E8%BE%85%E5%8A%A9%E9%94%AE%E5%92%8C%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">3.0.2.</span> <span class="toc-text">内容辅助键和快捷键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.3.</span> <span class="toc-text">模块操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.0.1.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">4.0.2.</span> <span class="toc-text">数组元素访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">4.0.3.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA"><span class="toc-number">4.0.3.1.</span> <span class="toc-text">数组内存多个数组指向一个</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.0.4.</span> <span class="toc-text">数组的静态初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">4.0.4.2.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%80%BC"><span class="toc-number">4.0.4.3.</span> <span class="toc-text">最值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">方法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%89%93%E5%8D%B0%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">5.1.2.0.1.</span> <span class="toc-text">一个方法打印最大值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">通用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8"><span class="toc-number">5.1.4.</span> <span class="toc-text">调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">5.1.5.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">5.1.6.</span> <span class="toc-text">方法重载</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%BD%BF%E7%94%A8%E5%85%A8%E6%95%B4%E6%95%B0%EF%BC%88byte-short-int-long%EF%BC%89%E5%B9%B6%E7%A1%AE%E5%AE%9A%E6%98%AF%E5%93%AA%E4%B8%AA%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">5.1.6.0.1.</span> <span class="toc-text">比较两个数使用全整数（byte short int long）并确定是哪个方法。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">5.2.</span> <span class="toc-text">方法参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%A2%E5%8F%82%E5%BD%B1%E5%93%8D%E5%AE%9E%E5%8F%82%EF%BC%88%E7%94%A8%E5%9C%B0%E5%9D%80%E6%94%B9%E5%8F%98%E5%AE%9E%E5%8F%82%EF%BC%89"><span class="toc-number">5.2.3.</span> <span class="toc-text">对引用类型的形参影响实参（用地址改变实参）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E7%B1%BB%E5%9E%8B%E4%B8%BA%EF%BC%9A%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%95%B0%E7%BB%84%EF%BC%8CString%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">5.2.4.</span> <span class="toc-text">其类型为：类，接口，数组，String（字符串）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%82%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.4.0.1.</span> <span class="toc-text">用方法求数组遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%82%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">5.2.4.0.2.</span> <span class="toc-text">用方法求数组最大值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug"><span class="toc-number">6.</span> <span class="toc-text">Debug</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="toc-number">6.0.1.</span> <span class="toc-text">断点调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">7.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92%E6%98%9F%E6%9C%9F1-2-3-4-5-6-7%E5%88%86%E5%88%AB%E5%8E%BB%E8%B7%91%E6%AD%A5%EF%BC%8C%E6%B8%B8%E6%B3%B3%EF%BC%8C%E6%85%A2%E8%B5%B0%EF%BC%8C%E5%8D%95%E8%BD%A6%EF%BC%8C%E6%8B%B3%E5%87%BB%EF%BC%8C%E7%88%AC%E5%B1%B1%EF%BC%8C%E5%A5%BD%E5%90%83%E4%B8%80%E6%AC%A1%E3%80%82%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%89"><span class="toc-number">7.0.0.0.1.</span> <span class="toc-text">减肥计划星期1,2,3,4,5,6,7分别去跑步，游泳，慢走，单车，拳击，爬山，好吃一次。（测试）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85"><span class="toc-number">7.1.</span> <span class="toc-text">导包</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%A2%E4%B8%83%E8%BF%87%E5%8C%85%E5%90%AB7%E6%88%967%E7%9A%84%E5%80%8D%E6%95%B0"><span class="toc-number">7.1.0.0.1.</span> <span class="toc-text">逢七过包含7或7的倍数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E6%AD%BB%E7%A5%9E%E5%85%94%E4%B8%80%E5%AF%B9%E5%85%94%E5%AD%90%E4%BB%8E%E5%87%BA%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E6%9C%88%E5%BC%80%E5%A7%8B%E9%83%BD%E7%94%9F%E4%B8%80%E5%AF%B9%E5%85%94%E5%AD%90%EF%BC%8C%E9%97%AE%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%AA%E6%9C%88%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AF%B9%E5%85%94%E5%AD%90%E3%80%82"><span class="toc-number">7.1.0.0.2.</span> <span class="toc-text">不死神兔一对兔子从出生的第三个月开始都生一对兔子，问第二十个月有多少对兔子。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%99%BE%E9%92%B1%E7%99%BD%E9%B8%A1%E4%B8%80%E9%B8%A1%E7%BF%81%E4%BA%94%E9%92%B1%E4%B8%80%E9%B8%A1%E6%AF%8D%E4%B8%89%E9%92%B1%E4%B8%89%E9%B8%A1%E9%9B%8F%E4%B8%80%E9%92%B1%E9%97%AE%E7%99%BE%E9%92%B1%E4%B9%B0%E7%99%BE%E9%B8%A1%E5%85%B6%E9%B8%A1%E5%90%84%E5%87%A0%E4%B8%AA%E3%80%82"><span class="toc-number">7.1.0.0.3.</span> <span class="toc-text">百钱白鸡一鸡翁五钱一鸡母三钱三鸡雏一钱问百钱买百鸡其鸡各几个。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%B1%82%E5%92%8C%E6%B1%82%E5%92%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E4%BD%8D%E5%92%8C%E5%8D%81%E4%BD%8D%E9%83%BD%E4%B8%8D%E8%83%BD%E6%98%AF%E4%B8%83%E5%B9%B6%E5%8F%AA%E8%83%BD%E6%98%AF%E5%81%B6%E6%95%B0arr-68-27-95-88-171-996-51-210"><span class="toc-number">7.1.0.0.4.</span> <span class="toc-text">数组元素求和求和的数字个位和十位都不能是七并只能是偶数arr[]={68,27,95,88,171,996,51,210}</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="toc-number">7.1.0.0.5.</span> <span class="toc-text">数组内容是否相同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%89%BE%E6%95%B0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">7.1.0.0.6.</span> <span class="toc-text">查找找数在数组中的位置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E5%8F%8D%E8%BD%AC%EF%BC%88%E5%80%9F%E5%8A%A9%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">7.1.0.0.7.</span> <span class="toc-text">反转：把数组反转（借助一个空间）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86%E5%8E%BB%E6%8E%89%E6%9C%80%E9%AB%98%E5%88%86%E5%92%8C%E6%9C%80%E4%BD%8E%E5%88%86%E5%86%8D%E7%AE%97%E5%B9%B3%E5%9D%87%E5%88%86"><span class="toc-number">7.1.0.0.8.</span> <span class="toc-text">评委打分去掉最高分和最低分再算平均分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">面向对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.0.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.0.2.</span> <span class="toc-text">对象的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E7%94%9F%E5%AE%9A%E4%B9%89%E5%AD%A6%E7%94%9F%E7%B1%BB%EF%BC%8C%E5%86%8D%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AD%A6%E7%94%9F%E6%B5%8B%E8%AF%95%E7%B1%BB%EF%BC%8C%E5%9C%A8%E5%AD%A6%E7%94%9F%E6%B5%8B%E8%AF%95%E7%B1%BB%E4%B8%AD%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E5%AE%8C%E6%88%90%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">案例：学生定义学生类，再定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">对象内存图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">成员变量和局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#private%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.1.</span> <span class="toc-text">private关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">this的内存原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">封装概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.3.</span> <span class="toc-text">封装原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">1.4.4.</span> <span class="toc-text">好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.5.</span> <span class="toc-text">构造方法。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%B1%BB%E5%88%B6%E4%BD%9C"><span class="toc-number">1.5.1.</span> <span class="toc-text">标准类制作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API"><span class="toc-number"></span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">String（字符串）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.4.</span> <span class="toc-text">String对象的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83equals"><span class="toc-number">1.0.5.</span> <span class="toc-text">比较equals</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%EF%BC%9A%E5%B7%B2%E7%9F%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%EF%BC%8C%E8%AF%B7%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E3%80%82%E6%80%BB%E5%85%B1%E4%B8%89%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%99%BB%E5%BD%95%E4%B9%8B%E5%90%8E%E4%BC%9A%E6%9C%89%E6%8F%90%E7%A4%BA%E3%80%82"><span class="toc-number">1.0.5.0.1.</span> <span class="toc-text">用户登录：已知用户名和密码，请用程序模拟用户登录。总共三次机会登录之后会有提示。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">遍历字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E6%AC%A1%E6%95%B0"><span class="toc-number">1.0.5.1.1.</span> <span class="toc-text">统计字符次数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.5.1.2.</span> <span class="toc-text">拼接字符串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.0.5.1.3.</span> <span class="toc-text">字符串反转</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">StringBuilder概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.1.3.</span> <span class="toc-text">添加和反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E4%B8%8EStringBuiler%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">String与StringBuiler的相互转化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%8A%8Aint%E6%95%B0%E7%BB%84%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%94%E5%9B%9E"><span class="toc-number">1.1.4.0.1.</span> <span class="toc-text">定义一个方法把int数组用字符串返回</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC-%E7%94%A8StringBuiler"><span class="toc-number">1.1.4.0.2.</span> <span class="toc-text">字符串反转(用StringBuiler)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.0.1.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">2.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.0.0.1.</span> <span class="toc-text">存储字符串并遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.0.0.2.</span> <span class="toc-text">存储学生对象并遍历</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">学生管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%EF%BC%9A"><span class="toc-number">2.1.0.1.1.</span> <span class="toc-text">要求：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">2.1.0.1.2.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AD%A6%E7%94%9F%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99%EF%BC%9A"><span class="toc-number">2.1.0.1.3.</span> <span class="toc-text">添加学生方法编写：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AD%A6%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.0.1.4.</span> <span class="toc-text">查看学生方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%A6%E7%94%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.0.1.5.</span> <span class="toc-text">删除学生的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%A6%E7%94%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.0.1.6.</span> <span class="toc-text">修改学生的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.0.1.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.</span> <span class="toc-text">super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">访问子类方法的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">子类构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">子类方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#super%E7%9A%84%E5%86%85%E5%AD%98%E6%89%A7%E8%A1%8C"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">super的内存执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">方法重写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%B3%A8%E6%84%8F"><span class="toc-number">3.2.</span> <span class="toc-text">继承的注意</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%81%E5%B8%88%E5%92%8C%E5%AD%A6%E7%94%9F%EF%BC%9B%E5%AE%9A%E4%B9%89%E8%80%81%E5%B8%88%E5%92%8C%E5%AD%A6%E7%94%9F%E7%B1%BB%EF%BC%8C%E5%86%99%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%89%BE%E5%88%B0%E5%85%B6%E4%B8%A4%E8%80%85%E7%9A%84%E5%85%B1%E6%80%A7%E5%86%85%E5%AE%B9%E6%8A%BD%E5%8F%96%E9%9B%8F%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%EF%BC%8C%E7%94%A8%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%94%B9%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.0.0.1.</span> <span class="toc-text">老师和学生；定义老师和学生类，写代码测试，找到其两者的共性内容抽取雏一个父类，用继承的方式改写代码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8C%AB%E5%92%8C%E7%8B%97%EF%BC%9A%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.0.0.2.</span> <span class="toc-text">猫和狗：直接使用继承实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">4.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">4.0.1.</span> <span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85-1"><span class="toc-number">4.1.</span> <span class="toc-text">导包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text">权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">final修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.3.</span> <span class="toc-text">static修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%E6%84%8F%E6%80%9D"><span class="toc-number">5.3.0.0.1.</span> <span class="toc-text">static关键字是静态的意思</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%A0%E9%9C%80%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%B0%83%E5%8A%A8"><span class="toc-number">5.3.0.0.2.</span> <span class="toc-text">无需创建实例就可以被调动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">6.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E6%8F%90"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">前提</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="toc-number">6.0.1.</span> <span class="toc-text">实际操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%9E%8B"><span class="toc-number">6.0.2.</span> <span class="toc-text">转型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8C%AB%E5%92%8C%E7%8B%97%E6%A1%88%E4%BE%8B%EF%BC%88%E5%8F%98%E9%87%8F%E5%A7%93%E5%90%8D%EF%BC%8C%E5%B9%B4%E9%BE%84%EF%BC%8C%E6%96%B9%E6%B3%95-%E6%A0%87%E5%87%86%E7%B1%BB%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E6%97%A0%E5%8F%82%EF%BC%8Ceat%E6%96%B9%E6%B3%95%EF%BC%89%E5%A4%9A%E6%80%81"><span class="toc-number">6.0.2.0.1.</span> <span class="toc-text">猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">抽象类概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">6.1.1.</span> <span class="toc-text">抽象类中的成员特点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8C%AB%E5%92%8C%E7%8B%97%E6%A1%88%E4%BE%8B%EF%BC%88%E5%8F%98%E9%87%8F%E5%A7%93%E5%90%8D%EF%BC%8C%E5%B9%B4%E9%BE%84%EF%BC%8C%E6%96%B9%E6%B3%95-%E6%A0%87%E5%87%86%E7%B1%BB%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E6%97%A0%E5%8F%82%EF%BC%8Ceat%E6%96%B9%E6%B3%95%EF%BC%89%E6%8A%BD%E8%B1%A1%E6%80%9D%E6%83%B3"><span class="toc-number">6.1.1.0.1.</span> <span class="toc-text">猫和狗案例（变量姓名，年龄，方法:标准类，构造方法有无参，eat方法）抽象思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">6.2.0.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.0.2.</span> <span class="toc-text">成员特点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8C%AB%E5%92%8C%E7%8B%97%EF%BC%8C%E5%AF%B9%E7%8C%AB%E5%92%8C%E7%8B%97%E8%AE%AD%E7%BB%83%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%B7%B3%E9%AB%98%E4%BA%86%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%9D%A5%E5%AE%8C%E6%88%90"><span class="toc-number">6.2.0.2.1.</span> <span class="toc-text">猫和狗，对猫和狗训练就可以跳高了用接口和抽象来完成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">类和接口的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8%E5%91%98%E5%92%8C%E6%95%99%E7%BB%83"><span class="toc-number">6.2.1.0.1.</span> <span class="toc-text">运动员和教练</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.2.</span> <span class="toc-text">形参和返回值的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">6.3.0.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API-1"><span class="toc-number"></span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Math类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">1.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.0.2.</span> <span class="toc-text">方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">System类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.0.1.</span> <span class="toc-text">方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">3.0.1.</span> <span class="toc-text">冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">基本类型包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Integer%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">Integer类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">构造方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int%E4%B8%8EString%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">int与String的相互转化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.1.2.1.</span> <span class="toc-text">字符串数据排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">3.2.2.</span> <span class="toc-text">自动装箱和拆箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleDateFormat"><span class="toc-number">3.3.1.</span> <span class="toc-text">SimpleDateFormat</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E8%A7%A3%E6%9E%90%E6%97%A5%E6%9C%9F"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">格式化和解析日期</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%97%A5%E6%9C%9F%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8A%8A%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9B%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E4%B8%BA%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%97%A5%E6%9C%9F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">3.3.1.2.1.</span> <span class="toc-text">定义一个日期工具类包含两个方法：把日期转化为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">Calendar类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E6%9C%88%E5%A4%A9%E8%8E%B7%E5%8F%96%E4%BB%BB%E6%84%8F%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BA%8C%E6%9C%88%E6%9C%89%E5%A4%9A%E5%B0%91%E5%A4%A9"><span class="toc-number">3.3.2.0.1.</span> <span class="toc-text">二月天获取任意一年的二月有多少天</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">4.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JVM%E7%9A%84%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">JVM的默认处理方案：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E6%89%8B%E5%8A%A8%EF%BC%89"><span class="toc-number">4.0.1.</span> <span class="toc-text">异常处理（手动）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#try%E2%80%A6catch%E2%80%A6"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">try…catch…</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Throwable%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">Throwable的成员方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throws%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">4.0.2.</span> <span class="toc-text">throws处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">4.0.3.</span> <span class="toc-text">自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.3.1.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6"><span class="toc-number"></span> <span class="toc-text">集合进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E4%BD%93%E7%B3%BB%EF%BC%9A"><span class="toc-number">0.0.1.</span> <span class="toc-text">集合类体系：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">Collection集合：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.0.1.</span> <span class="toc-text">Collection集合的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.0.2.</span> <span class="toc-text">集合的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88%E5%82%A8%E5%AD%98%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%81%8D%E5%8E%86"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">Collection集合储存学生对象并遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">2.</span> <span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%81%8D%E5%8E%86"><span class="toc-number">3.0.0.1.1.</span> <span class="toc-text">List集合存储学生对象并遍历</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">并发修改异常：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listlterator%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">listlterator列表迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">常用方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.2.</span> <span class="toc-text">增强for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E5%82%A8%E5%AD%98%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.0.0.1.</span> <span class="toc-text">List集合储存学生对象用三种方式遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.3.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">3.3.2.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E5%AD%90%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">List集合子类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8ArrayList%E5%92%8CLinkedList%E5%AE%8C%E6%88%90%E5%AD%98%E5%82%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.0.0.1.</span> <span class="toc-text">分别使用ArrayList和LinkedList完成存储字符串并遍历</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">3.4.0.1.</span> <span class="toc-text">LinkedList集合的特有功能：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">4.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">4.0.2.</span> <span class="toc-text">哈希值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">4.0.3.</span> <span class="toc-text">HashSet集合概述和特点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-number">4.0.3.0.1.</span> <span class="toc-text">用哈希表遍历集合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.0.4.</span> <span class="toc-text">数据结构之哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#HashSet%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%81%8D%E5%8E%86"><span class="toc-number">4.0.4.0.1.</span> <span class="toc-text">HashSet集合存储学生对象并遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashSet%E9%9B%86%E5%90%88"><span class="toc-number">4.0.5.</span> <span class="toc-text">LinkedHashSet集合</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E9%81%8D%E5%8E%86-1"><span class="toc-number">4.0.5.0.1.</span> <span class="toc-text">存储字符串并遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet%E9%9B%86%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">TreeSet集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8FComparable%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">自然排序Comparable的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8%E6%8E%92%E5%BA%8FComparator"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">比较器排序Comparator</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.0.2.1.</span> <span class="toc-text">成绩排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">4.1.0.2.2.</span> <span class="toc-text">不重复的随机数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">泛型类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.3.</span> <span class="toc-text">泛型接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">类型通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">4.4.0.1.</span> <span class="toc-text">注意：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">4.4.0.2.</span> <span class="toc-text">使用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%861"><span class="toc-number">5.0.0.0.1.</span> <span class="toc-text">Map集合遍历1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HashMap%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%81%8D%E5%8E%86"><span class="toc-number">5.0.0.0.2.</span> <span class="toc-text">HashMap集合存储学生对象并遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HashMap%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%81%8D%E5%8E%86-1"><span class="toc-number">5.0.0.0.3.</span> <span class="toc-text">HashMap集合存储学生对象并遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97"><span class="toc-number">5.0.0.0.4.</span> <span class="toc-text">集合嵌套</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">5.0.0.0.5.</span> <span class="toc-text">统计字符串中每个字符出现的次数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collections%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">5.0.1.</span> <span class="toc-text">Collections的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ArrayList%E5%AD%98%E5%82%A8%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%BD%BF%E7%94%A8Collections"><span class="toc-number">5.0.1.0.1.</span> <span class="toc-text">ArrayList存储大学生并排序使用Collections</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%96%97%E5%9C%B0%E4%B8%BB%E7%9A%84%E6%B4%97%E7%89%8C%EF%BC%8C%E5%8F%91%E7%89%8C%E5%92%8C%E7%9C%8B%E7%89%8C"><span class="toc-number">5.0.1.0.2.</span> <span class="toc-text">模拟斗地主的洗牌，发牌和看牌</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Io%E6%B5%81"><span class="toc-number"></span> <span class="toc-text">Io流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">File类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">创建功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#File%E7%9A%84%E5%88%A4%E6%96%AD%E5%92%8C%E8%8E%B7%E5%8F%96"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">File的判断和获取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">2.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98"><span class="toc-number">2.0.0.0.1.</span> <span class="toc-text">递归求阶乘</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E8%AF%A5%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9"><span class="toc-number">2.0.0.0.2.</span> <span class="toc-text">用递归遍历该目录下的所有内容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">2.0.1.</span> <span class="toc-text">字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">字节流写数据加异常处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">字节流读数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">复制文本文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">读取一个字节数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87"><span class="toc-number">2.0.1.5.</span> <span class="toc-text">复制图片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.0.1.6.</span> <span class="toc-text">字节缓冲流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E8%A7%86%E9%A2%91"><span class="toc-number">2.0.1.7.</span> <span class="toc-text">复制视频</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%9A"><span class="toc-number">2.0.2.</span> <span class="toc-text">字符流：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A1%A8%EF%BC%9A"><span class="toc-number">2.0.3.</span> <span class="toc-text">编码表：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ASCII%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%9A"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">ASCII字符集：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GBXXX%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">GBXXX字符集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unicode%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">Unicode字符集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-number">2.0.3.4.</span> <span class="toc-text">字符串中编码解码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">2.0.3.5.</span> <span class="toc-text">写读数据</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6java%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.3.5.1.</span> <span class="toc-text">复制java文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.0.3.6.</span> <span class="toc-text">字符缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6java%E6%96%87%E4%BB%B6%EF%BC%88%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%89"><span class="toc-number">2.0.3.6.1.</span> <span class="toc-text">复制java文件（字符缓冲流）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Io%E6%B5%81%E5%B0%8F%E7%BB%93"><span class="toc-number">2.0.4.</span> <span class="toc-text">Io流小结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%B0%8F%E7%BB%93"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">字节流小结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%B0%8F%E7%BB%93"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">字符流小结</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%8A%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.4.2.1.</span> <span class="toc-text">把集合中的数据写入文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%8A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%88%B0%E9%9B%86%E5%90%88%E4%B8%AD"><span class="toc-number">2.0.4.2.2.</span> <span class="toc-text">把文件中的数据读到集合中</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%82%B9%E5%90%8D%E5%99%A8"><span class="toc-number">2.0.4.2.3.</span> <span class="toc-text">点名器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%8A%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6-1"><span class="toc-number">2.0.4.2.4.</span> <span class="toc-text">把集合中的数据写入文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%8A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%88%B0%E9%9B%86%E5%90%88%E4%B8%AD%EF%BC%88%E6%96%87%E4%BB%B6%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%80%BC"><span class="toc-number">2.0.4.2.5.</span> <span class="toc-text">把文件中的数据读到集合中（文件的每一行数据都是学生对象的成员变量值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.4.2.6.</span> <span class="toc-text">集合到文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8D%95%E7%BA%A7%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.0.4.3.</span> <span class="toc-text">复制单级文件夹</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%A4%9A%E7%BA%A7%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.0.4.4.</span> <span class="toc-text">复制多级文件夹</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.0.5.</span> <span class="toc-text">复制文件的异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81"><span class="toc-number">3.</span> <span class="toc-text">特殊操作流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">3.1.</span> <span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">3.2.</span> <span class="toc-text">打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">字节打印流:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">字符打印流:</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6java%E6%96%87%E4%BB%B6%EF%BC%88%E7%94%A8%E6%89%93%E5%8D%B0%E6%B5%81%EF%BC%89"><span class="toc-number">3.2.0.3.1.</span> <span class="toc-text">复制java文件（用打印流）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">3.3.</span> <span class="toc-text">对象序列化流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%EF%BC%9AObjectOutputStream"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">对象序列化流：ObjectOutputStream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%EF%BC%9AObjictInputStrream"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">对象反序列化流：ObjictInputStrream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties"><span class="toc-number">3.4.</span> <span class="toc-text">Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="toc-number">3.4.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E6%AC%A1%E6%95%B0"><span class="toc-number">3.4.1.0.1.</span> <span class="toc-text">游戏次数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.0.1.</span> <span class="toc-text">多线程的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">4.0.2.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.0.3.</span> <span class="toc-text">线程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-number">4.0.4.</span> <span class="toc-text">多线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%96%E7%A5%A8"><span class="toc-number">4.0.4.0.1.</span> <span class="toc-text">卖票</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">4.0.5.</span> <span class="toc-text">线程安全的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock%E9%94%81"><span class="toc-number">4.0.6.</span> <span class="toc-text">Lock锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">4.1.</span> <span class="toc-text">生产者消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%B6%E7%AE%B1%E7%B1%BB%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">4.1.0.1.1.</span> <span class="toc-text">奶箱类生产者与消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="toc-number">0.0.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">0.0.1.1.</span> <span class="toc-text">网络编程三要素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">0.0.2.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InetAddress%E7%B1%BB"><span class="toc-number">0.0.3.</span> <span class="toc-text">InetAddress类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">0.0.3.1.</span> <span class="toc-text">端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-number">0.0.3.2.</span> <span class="toc-text">协议：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UPD%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">0.1.</span> <span class="toc-text">UPD通信原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">0.1.0.1.</span> <span class="toc-text">发送数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">0.1.0.2.</span> <span class="toc-text">接收数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">0.1.1.</span> <span class="toc-text">TCP通信原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%83%E4%B9%A05"><span class="toc-number">0.1.1.0.1.</span> <span class="toc-text">练习5</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%83%E4%B9%A06"><span class="toc-number">0.1.1.0.2.</span> <span class="toc-text">练习6</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">1.0.1.</span> <span class="toc-text">函数式编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="toc-number">1.0.1.0.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">省略模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">匿名内部类和Lambda表达式的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0"><span class="toc-number">1.0.2.</span> <span class="toc-text">接口的组成更新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">默认方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">私有方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">Lambda表达式支持的方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A"><span class="toc-number">1.0.3.1.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">引用对象的实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">引用类的实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">引用构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">函数式接口作为方法的参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Supplier%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">Supplier接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Consumer%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">Consumer接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Predicate%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">Predicate接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Function%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">Function接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">常见的生成方式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">常见终结方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">Stream流的收集操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">类的加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">类的连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">类的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">3.0.0.4.</span> <span class="toc-text">类加载机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">3.1.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">获取Class类的对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">反射获取构造方法并使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">3.1.0.2.1.</span> <span class="toc-text">通过反射实现：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">反射获取成员变量并使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">反射获取方法并使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">模块的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.0.2.</span> <span class="toc-text">模块服务</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/09/Mybatis/" title="Mybatis">Mybatis</a><time datetime="2024-10-09T12:50:21.000Z" title="发表于 2024-10-09 20:50:21">2024-10-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/17/javaweb%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="javaweb的基础知识">javaweb的基础知识</a><time datetime="2024-09-17T06:13:42.000Z" title="发表于 2024-09-17 14:13:42">2024-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/13/java%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="java的基础知识">java的基础知识</a><time datetime="2024-09-13T12:14:58.000Z" title="发表于 2024-09-13 20:14:58">2024-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/13/hello-world/" title="Hello World">Hello World</a><time datetime="2024-09-13T01:09:01.342Z" title="发表于 2024-09-13 09:09:01">2024-09-13</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>